

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="JS基础0. 邂逅JavaScript（了解）0.0 认识编程语言 HTML-标记语言    CSS-样式语言  HTML、CSS、JS都属于计算机语言（我们人和计算机进行沟通交流的语言）  JS不仅属于计算机语言，精确来说是一门编程语言  编程语言特征  数据和数据结构(变量、数组、对象等) 指令及流程控制（if&#x2F;for） 引用机制和重用机制 设计哲学    0.1 编程语言发展历史 机器语言">
<meta property="og:type" content="article">
<meta property="og:title" content="Javascript详解">
<meta property="og:url" content="https://kygo.top/2022/03/24/3.%20js/index.html">
<meta property="og:site_name" content="欢迎来到Kygo的博客">
<meta property="og:description" content="JS基础0. 邂逅JavaScript（了解）0.0 认识编程语言 HTML-标记语言    CSS-样式语言  HTML、CSS、JS都属于计算机语言（我们人和计算机进行沟通交流的语言）  JS不仅属于计算机语言，精确来说是一门编程语言  编程语言特征  数据和数据结构(变量、数组、对象等) 指令及流程控制（if&#x2F;for） 引用机制和重用机制 设计哲学    0.1 编程语言发展历史 机器语言">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kygo.top/2022/03/public/img/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E4%B8%80.png">
<meta property="og:image" content="https://kygo.top/2022/03/public/img/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E4%BA%8C.png">
<meta property="og:image" content="https://kygo.top/2022/03/public/img/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E4%B8%89.png">
<meta property="og:image" content="https://kygo.top/2022/03/public/img/DOM%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE.png">
<meta property="og:image" content="c:/Users/Administrator/Desktop/2022/img/js高级_浏览器渲染过程.png">
<meta property="og:image" content="c:/Users/Administrator/Desktop/2022/img/js高级_V8引擎的原理.png">
<meta property="og:image" content="file:///C:/Users/ADMINI~1/AppData/Local/Temp/ksohtml2868/wps1.png">
<meta property="og:image" content="file:///C:/Users/ADMINI~1/AppData/Local/Temp/ksohtml2868/wps2.png">
<meta property="og:image" content="file:///C:/Users/ADMINI~1/AppData/Local/Temp/ksohtml2868/wps3.png">
<meta property="article:published_time" content="2022-03-24T05:40:04.000Z">
<meta property="article:modified_time" content="2023-02-20T00:48:28.664Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="JS">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://kygo.top/2022/03/public/img/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E4%B8%80.png">
  
  
  <title>Javascript详解 - 欢迎来到Kygo的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"kygo.top","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>东白</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/article.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Javascript详解">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-24 13:40" pubdate>
        2022-03-24 13:40:04
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      57k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      472 分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Javascript详解</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2023-02-20 08:48:28
                
              </p>
            
            <div class="markdown-body">
              <h1 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h1><h2 id="0-邂逅JavaScript（了解）"><a href="#0-邂逅JavaScript（了解）" class="headerlink" title="0. 邂逅JavaScript（了解）"></a>0. 邂逅JavaScript（了解）</h2><h3 id="0-0-认识编程语言"><a href="#0-0-认识编程语言" class="headerlink" title="0.0 认识编程语言"></a>0.0 认识编程语言</h3><ul>
<li><p>HTML-标记语言    CSS-样式语言</p>
</li>
<li><p>HTML、CSS、JS都属于<strong>计算机语言</strong>（我们人和计算机进行沟通交流的语言）</p>
</li>
<li><p>JS不仅属于计算机语言，精确来说是一门<strong>编程语言</strong></p>
</li>
<li><p><strong>编程语言特征</strong></p>
<ul>
<li>数据和数据结构(变量、数组、对象等)</li>
<li>指令及流程控制（if/for）</li>
<li>引用机制和重用机制</li>
<li>设计哲学</li>
</ul>
</li>
</ul>
<h3 id="0-1-编程语言发展历史"><a href="#0-1-编程语言发展历史" class="headerlink" title="0.1 编程语言发展历史"></a>0.1 编程语言发展历史</h3><ul>
<li>机器语言<ul>
<li>由0、1组成，也叫做机器码或二进制编码</li>
<li>一定长度的机器码组成了机器指令，用机器指令编写的程序就是机器语言</li>
<li>优点：直接被计算机识别，不需编译解析，直接对硬件产生作用，程序效率高</li>
<li>缺点：可读性差、容易出错、不易编写</li>
</ul>
</li>
<li>汇编语言<ul>
<li>用符号代替冗长的0、1代码（通过汇编器将汇编码转成0、1，从而被机器识别）</li>
<li>优点：和机器语言一样，可以直接访问、控制计算机的各种硬件设备，占用内存少执行速度快</li>
<li>缺点：代码缺乏可移植性（不同语言有不同汇编语言语法和编译器）、符号非常多难记</li>
<li>应用场景：操作系统内核、单片机程序、驱动程序</li>
</ul>
</li>
<li>高级语言<ul>
<li>高级语言就是更接近自然的语言，更符合人类的思维方式，一般使用英文编写</li>
<li>优点<ul>
<li>简单、易用、易于理解，语法结构类似于普通英文</li>
<li>远离对硬件的直接操作</li>
<li>具有可移植性，一个程序可以在不同机器上运行</li>
</ul>
</li>
<li>缺点<ul>
<li>不能直接被计算机识别，需要经编译器翻译成二进制指令后，才能运行到计算机上</li>
<li>种类繁多</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="0-2-js的历史"><a href="#0-2-js的历史" class="headerlink" title="0.2 js的历史"></a>0.2 js的历史</h3><ul>
<li><p>认识JavaScript</p>
<ul>
<li>JavaScript是一门高级的、解释型的编程语言</li>
<li>是一门基于原型的、头等函数的语言，是一门多范式的语言…</li>
<li>JavaScript是前端开发的灵魂</li>
</ul>
</li>
<li><p>1994年，网景公司（Netscape）发布了Navigator浏览器0.9版本</p>
<ul>
<li>这是历史上第一个比较成熟的网络浏览器</li>
<li>但是这个版本浏览器只能用来浏览，不能与用户互动，网景公司急需一种网页脚本语言</li>
</ul>
</li>
<li><p>网景公司当时想要选择一门语言来嵌入到浏览器中</p>
<ul>
<li>网景公司招募了程序员Brendan Eich，希望将Scheme语言作为网页脚本语言的可能</li>
<li>同时发生了一件大事：1995年Sun公司将Oka语言改名Java，正式向市场推出</li>
<li>网景公司动了心，希望和Sun公司结成联盟，将Java嵌入到网页中来运行</li>
<li>Brendan Eich本人非常热衷于Scheme，但管理层那时候有点倾向于Java</li>
</ul>
</li>
<li><p>Brendan Eich用10天时间设计出JavaScript</p>
<ul>
<li>最初这门语言得名字叫Mocha（摩卡），Navigator2.0 beta版本改名为LiveScript</li>
<li>Navigator2.0 beta 3版本正式命名为JavaScript（当时是为了给这门语言搭上Java这个热词）</li>
<li>这门语言更像是很多语言的大杂烩<ul>
<li>借鉴C语言的基本语法</li>
<li>借鉴Java语言的数据类型和内存管理</li>
<li>借鉴Scheme语言，将函数提升到”一等公民”（first class）的地位</li>
<li>借鉴Self语言，使用基于原型（prototype）的继承机制</li>
</ul>
</li>
</ul>
</li>
<li><p>微软公司于1995年首次推出Internet Explorer，从而引发了与Netscape的浏览器大战</p>
<ul>
<li>微软创建了JScript语言，这时对开发者来说是一种噩耗，因为要适配不同浏览器</li>
</ul>
</li>
<li><p>1996年11月，网景正式向ECMA（欧洲计算机制造商协会）提交语言标准</p>
<ul>
<li>1997年6月，ECMA以JavaScript语言为基础制定了ECMAScript标准规范ECMA-262</li>
<li>JavaScript成为ECMAScript最著名的实现之一（ActionScript和JScript也都是ECMAScript规范的实现语言）</li>
</ul>
</li>
<li><p>所以说，ECMAScript是一种规范，而JavaScript是这种规范的一种实现</p>
</li>
</ul>
<h3 id="0-3-js的组成"><a href="#0-3-js的组成" class="headerlink" title="0.3 js的组成"></a>0.3 js的组成</h3><ul>
<li>JavaScript是ECMAScript标准的<strong>语言层面</strong>实现</li>
<li>除了语言规范外，JS还需要对页面(DOM)和浏览器(BOM)进行各种操作</li>
<li>所以JS由三大部分组成：ECMAScript、DOM、BOM</li>
</ul>
<h3 id="0-4-js运行引擎"><a href="#0-4-js运行引擎" class="headerlink" title="0.4 js运行引擎"></a>0.4 js运行引擎</h3><ul>
<li>不同的浏览器由不同的内核组成，如：Webkit、Blink</li>
<li>通常我们说的浏览器内核是指：排版引擎，而JS是由JS引擎来执行的</li>
<li>JS引擎<ul>
<li>为什么需要JS引擎：将JS(高级语言)=&gt;CPU指令(机器码)来执行</li>
<li>常见的JS引擎<ul>
<li>SpiderMonkey：第一款JS引擎，由Brendan Eich开发（JS作者）</li>
<li>Chakra：微软开发，用于IE浏览器</li>
<li>JavaScriptCore：Webkit中的JS引擎，Apple公司开发</li>
<li>V8：Google开发的强大JS引擎，帮助Chrome浏览器脱颖而出</li>
</ul>
</li>
</ul>
</li>
<li>浏览器内核和JS引擎的关系<ul>
<li>以WebKit内核为例，由两部分组成<ul>
<li>WebCore：负责HTML解析、布局渲染等</li>
<li>JavaScriptCore：解析、执行JS代码</li>
</ul>
</li>
<li>在小程序中编写的JS也是由JSCore执行的</li>
</ul>
</li>
</ul>
<h3 id="0-5-js应用场景"><a href="#0-5-js应用场景" class="headerlink" title="0.5 js应用场景"></a>0.5 js应用场景</h3><ul>
<li>Web开发（原生JS、Vue、React、Angular开发）</li>
<li>移动端开发（ReactNative、Weex）</li>
<li>小程序开发（微信小程序、支付宝小程序、uniapp、taro）</li>
<li>桌面端开发（Electron，如VSCode）</li>
<li>后端开发（Node框架，koa、express…）</li>
</ul>
<h2 id="1-JavaScript基本知识"><a href="#1-JavaScript基本知识" class="headerlink" title="1. JavaScript基本知识"></a>1. JavaScript基本知识</h2><h3 id="1-1-JS编写方式"><a href="#1-1-JS编写方式" class="headerlink" title="1.1 JS编写方式"></a>1.1 JS编写方式</h3><ul>
<li>位置：行内/内部/外部引入  (外部src引入的script标签中不能写js代码，不然无效)</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 行内引入-HTML代码行内（不推荐） --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;行内引入js&#x27;)&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>点一下<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:alert(&#x27;行内引入js方式二&#x27;)&quot;</span>&gt;</span>点一下<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 内部引入-script标签中 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  alert(<span class="hljs-string">&quot;内部引入js&quot;</span>)</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 外部引入-外部js文件，通过script元素的src属性引入文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./out.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>注意点：js代码放到head，并需要通过js操作页面元素时就会失效(HTML从上至下执行)</p>
</li>
<li><p>解决</p>
<ul>
<li>加上window.onload=function(){ js代码 }  (内部外部都可以加)</li>
<li>将script或script-src放到body结束标签之前</li>
</ul>
</li>
</ul>
<h3 id="1-2-noscript元素"><a href="#1-2-noscript元素" class="headerlink" title="1.2 noscript元素"></a>1.2 noscript元素</h3><ul>
<li><p>浏览器不支持JavaScript或者用户关闭了浏览器的JavaScirpt功能时，可以使用noscript元素</p>
</li>
<li><p>noscript元素用于给不支持JavaScript的浏览器提供替代内容</p>
</li>
<li><p>注意：只有当浏览器不支持或关闭了javascript时，noscirpt元素才会起作用（显示出来）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>您的浏览器不支持或关闭运行JavaScript<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-3-JavaScript编写注意事项"><a href="#1-3-JavaScript编写注意事项" class="headerlink" title="1.3 JavaScript编写注意事项"></a>1.3 JavaScript编写注意事项</h3><ul>
<li>script元素不能写成单标签</li>
<li>自动省略type属性（以前的代码script中会使用type=”text/javascript”，现在不用写了）</li>
<li>加载顺序<ul>
<li>作为HTML文档的一部分，自上而下加载，<strong>推荐将js放在body子元素的最后一行</strong></li>
</ul>
</li>
<li>js代码严格区分大小写</li>
<li>script元素还有defer、async属性（后续学习）</li>
</ul>
<h3 id="1-4-JS和浏览器的交互方式"><a href="#1-4-JS和浏览器的交互方式" class="headerlink" title="1.4 JS和浏览器的交互方式"></a>1.4 JS和浏览器的交互方式</h3><ul>
<li><p>弹窗：alert()-确定按钮  confirm()-确定取消  prompt()-确定取消获取用户输入框    </p>
</li>
<li><p>网页内容区域：document.write()  </p>
</li>
<li><p>控制台：普通console.log(a,b…)  警告console.warn()  错误console.error()</p>
</li>
</ul>
<h3 id="1-5-Chrome调试工具"><a href="#1-5-Chrome调试工具" class="headerlink" title="1.5 Chrome调试工具"></a>1.5 Chrome调试工具</h3><ul>
<li><p>可以在开发者工具中的console查看log出的内容</p>
</li>
<li><p>如果代码中出现了错误或警告，会在console中显示</p>
</li>
<li><p>console中有个 &gt; 符号，表示控制台的命令行</p>
<ul>
<li>在命令行中可以直接编写js代码，按下enter键执行</li>
<li>如果想编写多行代码，按住shift+enter来换行</li>
</ul>
</li>
<li><p>还可以通过debug方式来调试、查看代码的执行流程</p>
</li>
</ul>
<h3 id="1-6-JS的语句和分号"><a href="#1-6-JS的语句和分号" class="headerlink" title="1.6 JS的语句和分号"></a>1.6 JS的语句和分号</h3><ul>
<li>语句是向浏览器发出的指令，通常表达一个操作或行为</li>
<li>通常每条语句后都会加上一个分号，表示语句的结束</li>
<li>当存在换行符时，大多数情况可以省略分号（JS将换行符理解成”隐式”的分号，也称为自动插入分号）</li>
</ul>
<h3 id="1-7-JS的注释"><a href="#1-7-JS的注释" class="headerlink" title="1.7 JS的注释"></a>1.7 JS的注释</h3><ul>
<li><p>三种注释：单行注释、多行注释、文档注释</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//我是js单行注释</span><br><br><span class="hljs-comment">/*我是js多行注释*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">文档注释：VSCode中在单独的JS文件中编写才有效，当我们调用函数时就会有提示，快捷键：&quot;/**&quot;，如下：</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 向某人打招呼</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> </span>name 姓名</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>age 年龄</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span>(<span class="hljs-params">name,age</span>)</span>&#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>注意：JS不支持注释嵌套</p>
</li>
</ul>
<h2 id="2-ECMAScript"><a href="#2-ECMAScript" class="headerlink" title="2. ECMAScript"></a>2. ECMAScript</h2><h3 id="2-1-变量和数据类型"><a href="#2-1-变量和数据类型" class="headerlink" title="2.1 变量和数据类型"></a>2.1 变量和数据类型</h3><h4 id="2-1-1-变量"><a href="#2-1-1-变量" class="headerlink" title="2.1.1 变量"></a>2.1.1 变量</h4><ul>
<li><p>作用：记录某一个之后会变化的数据</p>
</li>
<li><p>变量定义</p>
<ul>
<li><p>变量声明（var关键字） + 变量赋值（=）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//声明并且赋值，也可给多个变量声明和赋值</span><br><span class="hljs-keyword">var</span> age=<span class="hljs-number">18</span>;<br><span class="hljs-comment">//先声明再赋值（不推荐），没有初始化值为undefined</span><br><span class="hljs-keyword">var</span> a,b;  <br>a=b=<span class="hljs-number">213</span>;  <br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>变量(标识符)的命名规范（标识符-凡是自己命名的都叫标识符）</p>
<ul>
<li>命名规则（必须遵守）<ul>
<li>第一个字符必须是一个字母、下划线、美元符号，其他字符可以是数字、字母、下划线、美元符号</li>
<li>不能使用关键字和保留字命名</li>
<li>变量严格区分大小写</li>
</ul>
</li>
<li>命名规范（建议遵守）<ul>
<li>多个单词时，驼峰命名：一般小驼峰</li>
<li>= 号两边加上空格</li>
<li>每条语句结束加上分号</li>
<li>变量见名知意</li>
</ul>
</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>变量不声明直接使用会报错</li>
<li>变量有声明但没有赋值，值为undefined（不推荐，一般会给初始值如：0、””、null…）</li>
<li>不使用var声明直接赋值，也可以，但不推荐（对将变量加到window对象上）</li>
</ul>
</li>
<li><p>ES6</p>
</li>
</ul>
<p>常量：整形、实型、字符串、布尔、自定义常量(ES6: const关键字/不能改变)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span> <span class="hljs-number">1.2</span> <span class="hljs-string">&quot;2&quot;</span> <span class="hljs-literal">true</span> <br><span class="hljs-keyword">const</span> name=<span class="hljs-string">&quot;cth&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>预处理(解析)：将所有变量和函数的定义放到所有代码最前面，所以可以先使用再定义变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(a);  <span class="hljs-comment">//undefined</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>ES6变量定义：let 变量名称;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a=<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>注：let定义过的变量重新定义报错(方便查找)，而老版本的var不会</p>
<p>​        let定义的变量不会预解析，必须先定义再使用，否则会报错</p>
<p>补：字面量是具体的值，存储在常量或变量中</p>
<h4 id="2-1-2-数据类型"><a href="#2-1-2-数据类型" class="headerlink" title="2.1.2 数据类型"></a>2.1.2 数据类型</h4><ul>
<li><p>javascript是一门”动态类型”的编程语言</p>
<ul>
<li>javascript中的值都具有特定的数据类型</li>
<li>一个变量可以在上一刻是字符串，下一个是一个数字</li>
</ul>
</li>
<li><p>8种基本数据类型（7种原始类型/基本数据类型和1种复杂类型）</p>
<ul>
<li>number string boolean</li>
<li>undefined null object(引用类型)</li>
<li>BigInt Symbol（后续了解）</li>
</ul>
</li>
<li><p>typoef操作符的使用</p>
<ul>
<li><p>由来：因为ECMAScript的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型</p>
</li>
<li><p>用法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">typeof x 因为是操作符所以中间用空格连接即可</span><br><span class="hljs-comment">typeof(x) 不是一个函数，括号只是代表后面是一个整体，如：(1+2)*3</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">var</span> age = <span class="hljs-number">19</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> age)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span>(age))<br></code></pre></td></tr></table></figure></li>
<li><p>返回以下任意值之一</p>
<ul>
<li>“number”、”string” 、”boolean”、 “undefined” - 未赋值</li>
<li>“object” - 对象或null</li>
<li>“function” - 函数     “symbol”- 符号</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Number类型</strong></p>
<ul>
<li><p>范围：JS所有数值 - 整数和浮点数</p>
</li>
<li><p>除了常规数字，还包括一些 “特殊数值”：Infinity、NaN（了解）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//NAN(not a number)非数值，表示一个错误操作得到的结果</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;123cth&quot;</span>),<span class="hljs-number">3</span>*<span class="hljs-string">&quot;abc&quot;</span>);<br><span class="hljs-comment">//Infinity/-Infinity（无穷大和无穷小，全局对象的属性 window.Infinity）</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> / <span class="hljs-number">0</span>);   <span class="hljs-comment">//Infinity  0/0=NaN</span><br><span class="hljs-built_in">console</span>.log(-<span class="hljs-number">1</span> / <span class="hljs-number">0</span>);  <span class="hljs-comment">//-Infinity</span><br></code></pre></td></tr></table></figure></li>
<li><p>数字的进制表示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//十进制</span><br><span class="hljs-keyword">var</span> num1=<span class="hljs-number">111</span>;<br><span class="hljs-comment">//十六进制</span><br><span class="hljs-keyword">var</span> num2=<span class="hljs-number">0x111</span>;<br><span class="hljs-comment">//八进制</span><br><span class="hljs-keyword">var</span> num3=<span class="hljs-number">0o111</span>;<br><span class="hljs-comment">//二进制</span><br><span class="hljs-keyword">var</span> num4=<span class="hljs-number">0b111</span>;<br><span class="hljs-built_in">console</span>.log(num1,num2,num3,num4);<br></code></pre></td></tr></table></figure></li>
<li><p>数字表示范围</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.MAX_VALUE); <span class="hljs-comment">//最大正数值</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.MIN_VALUE); <span class="hljs-comment">//最小正数值，小于这个数会转化为0</span><br></code></pre></td></tr></table></figure></li>
<li><p>isNaN: 判断是否不是一个数字（NAN），不是数字返回true</p>
</li>
<li><p>注意：不要使用js进行精度要求较高的计算</p>
</li>
</ul>
</li>
<li><p><strong>String类型</strong></p>
<ul>
<li><p>用途：表示一段文本</p>
</li>
<li><p>三种使用方法：单引号””、双引号’’、反引号`（ES6语法）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name=<span class="hljs-string">&quot;kygo&quot;</span><br><span class="hljs-keyword">var</span> name=<span class="hljs-string">&#x27;kygo~&#x27;</span><br><span class="hljs-keyword">var</span> name=<span class="hljs-string">`kygo~~`</span><br><span class="hljs-comment">//反引号,$&#123;变量/表达式&#125;</span><br><span class="hljs-keyword">var</span> msg=<span class="hljs-string">`my name is <span class="hljs-subst">$&#123;name&#125;</span>,age is <span class="hljs-subst">$&#123;<span class="hljs-number">17</span>+<span class="hljs-number">1</span>&#125;</span>`</span><br></code></pre></td></tr></table></figure></li>
<li><p>如果字符串本身使用双引号，那么字符串中可以使用单引号，反之也可</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> desc=<span class="hljs-string">&quot;kygo is &#x27;shuaige&#x27;&quot;</span><br><span class="hljs-keyword">var</span> desc1=<span class="hljs-string">&#x27;kygo is &quot;shuaige&quot;&#x27;</span><br></code></pre></td></tr></table></figure></li>
<li><p>转义字符（了解）</p>
<ul>
<li><p>一些有特殊功能的字符可以通过转移字符的形式放入字符串中</p>
</li>
<li><p>都是斜杠\开头</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">\\ 斜杠<br>\n \t 换行符、制表符<br>\<span class="hljs-string">&#x27; \&quot;  单引号、双引号</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>字符串的属性和方法</p>
<ul>
<li><p>字符串拼接：通过 + 连接</p>
</li>
<li><p>获取字符串长度</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> msg1 = <span class="hljs-string">&quot;my name is&quot;</span><br><span class="hljs-keyword">var</span> msg2 = <span class="hljs-string">&quot;kygo&quot;</span><br><span class="hljs-keyword">var</span> msg3 = msg1 + msg2<br><span class="hljs-keyword">var</span> msg4 = <span class="hljs-string">`my name is <span class="hljs-subst">$&#123;msg2&#125;</span>`</span> <span class="hljs-comment">//推荐</span><br><span class="hljs-built_in">console</span>.log(msg3,msg3.length);<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>Boolean类型</p>
<ul>
<li>作用：用于表示真假</li>
<li>值：真、假 - true/false</li>
</ul>
</li>
</ul>
<ul>
<li><p>Undefined类型</p>
<ul>
<li><p>只有一个值，就是undefined</p>
<ul>
<li>如果只声明变量没有赋值，默认值就是undefined</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>最好在变量定义时进行初始化，而不是只是声明变量</li>
<li>不要把变量显示的赋值为undefined（可以初始化为0、””、null等）</li>
</ul>
</li>
</ul>
</li>
<li><p>Object类型和Null类型</p>
<ul>
<li><p>通常被称为引用类型或复杂类型</p>
</li>
<li><p>作用：表示一组数据，是其他数据的一个集合</p>
</li>
<li><p>表示方法：用花括号{}的方式来表示一个对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj=&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-attr">height</span>: <span class="hljs-number">1.88</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(obj.name);<br></code></pre></td></tr></table></figure></li>
<li><p>Null类型</p>
<ul>
<li>值：只有一个值null</li>
<li>作用：通常用来表示一个对象为空，用来给一个对象进行初始化时，会赋值为null</li>
<li>也属于object类型：使用typeof操作符返回object</li>
</ul>
</li>
<li><p>null和undefined的关系</p>
<ul>
<li><p>undefined通常只有在一个变量声明但未初始化时，默认值是undefined才会用到</p>
</li>
<li><p>不推荐直接给变量赋值为undefined，所以很少主动来使用</p>
</li>
<li><p>null值非常常用，当我们变量准备保存一个对象，而对象不确定时，可以先赋值null</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-1-3-数据类型的转换"><a href="#2-1-3-数据类型的转换" class="headerlink" title="2.1.3 数据类型的转换"></a>2.1.3 数据类型的转换</h4><ul>
<li>String类型的转换<ul>
<li>隐式类型转换：一个字符串和其他类型进行+操作</li>
<li>显示转换：String()函数、toString()方法</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//三种方法：toString()  String()  +&quot;&quot;</span><br><span class="hljs-keyword">var</span> num = <span class="hljs-number">2</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">String</span>(num) + <span class="hljs-string">&quot; 类型：&quot;</span> + <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">String</span>(num));<br><span class="hljs-built_in">console</span>.log(num.toString() + <span class="hljs-string">&quot; 类型：&quot;</span> + <span class="hljs-keyword">typeof</span> num.toString());<br><span class="hljs-built_in">console</span>.log(num + <span class="hljs-string">&quot;&quot;</span> + <span class="hljs-string">&quot; 类型：&quot;</span> + <span class="hljs-keyword">typeof</span>(num + <span class="hljs-string">&quot;&quot;</span>));<br><span class="hljs-comment">/*Result</span><br><span class="hljs-comment">2 类型：string</span><br><span class="hljs-comment">2 类型：string</span><br><span class="hljs-comment">2 类型：string */</span><br><br><span class="hljs-comment">//toString()转换undefined与null类型会报错,toString()可以转换数字进制，在()指定</span><br><span class="hljs-keyword">var</span> num = <span class="hljs-number">7</span><br><span class="hljs-built_in">console</span>.log(num.toString(<span class="hljs-number">2</span>));	<span class="hljs-comment">//进制转换 111</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span>.toString()); <span class="hljs-comment">//报错</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span>.toString());	<span class="hljs-comment">//报错</span><br></code></pre></td></tr></table></figure>



<ul>
<li><p>Number类型的转换</p>
<ul>
<li><p>隐式转换：在算术运算时，通常会将其他类型转成数字类型来运行（除了+运算且一边是字符串）</p>
</li>
<li><p>显示转换：Number()函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//Number()  +  </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> + <span class="hljs-number">0</span>);  <span class="hljs-comment">//+不能转换字符串为数字</span><br><br><span class="hljs-comment">//string转number 如果不是纯数字-&gt; NaN</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;value=&quot;</span> + <span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;123a&quot;</span>) + <span class="hljs-string">&quot; type=&quot;</span> + <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;123a&quot;</span>));<br></code></pre></td></tr></table></figure></li>
<li><p>其他类型转数字的规则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//空、空格字符串/null/false都是0  undefined/非纯数字-&gt;NaN</span><br>console.log(<span class="hljs-string">&quot;false:&quot;</span> + Number(<span class="hljs-keyword">false</span>) + <span class="hljs-string">&quot; 空:&quot;</span> + Number(<span class="hljs-string">&quot; &quot;</span>) + <span class="hljs-string">&quot; null:&quot;</span> + Number(<span class="hljs-keyword">null</span>) <br>            + <span class="hljs-string">&quot; undefined:&quot;</span> + Number(undefined));<br><span class="hljs-comment">//Result</span><br><span class="hljs-keyword">false</span>:<span class="hljs-number">0</span> 空:<span class="hljs-number">0</span> <span class="hljs-keyword">null</span>:<span class="hljs-number">0</span> undefined:NaN<br></code></pre></td></tr></table></figure></li>
<li><p>扩展：parseInt/parseFloat-字符串转数字专用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">parseInt() 和 parseFloat()专门用于转换非纯数字</span><br><span class="hljs-comment">解析到第一个非数值为止  如parseInt(c3px) -&gt;NaN */</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;value=&quot;</span> + <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;123a&quot;</span>) + <span class="hljs-string">&quot; type=&quot;</span> + <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;123a&quot;</span>));<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;value=&quot;</span> + <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;123.123a&quot;</span>) + <span class="hljs-string">&quot; type=&quot;</span> + <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;123a&quot;</span>));<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>Boolean类型的转换  <ul>
<li>通过Boolean()函数 或 隐式转换!!</li>
<li>转换规则：直观上为空的值（0、””、null、undefined和NaN）都转成false</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//Boolean()  !!</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-string">&quot;Kygo&quot;</span>));<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Res: &quot;</span> + !!<span class="hljs-string">&quot;kygo&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>注意：空字符串/0/NaN/null/undefined  -&gt;false</p>
<p>​    </p>
<h3 id="2-2-运算符"><a href="#2-2-运算符" class="headerlink" title="2.2 运算符"></a>2.2 运算符</h3><ul>
<li><p>运算符和运算元</p>
<ul>
<li><p>运算符：计算机最基本的操作就是执行运算，而执行运算就需要使用运算符来操作</p>
</li>
<li><p>运算元</p>
<ul>
<li>运算符应用的对象</li>
<li>一个运算符对应的只有一个运算元叫一元运算符，一个运算符对应两个运算元…</li>
</ul>
</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li><p>功能分：算数运算符/赋值运算符/关系(比较)运算符/逻辑运算符</p>
</li>
<li><p>操作数分：单目/双目/三目运算符</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-2-1-算数运算符"><a href="#2-2-1-算数运算符" class="headerlink" title="2.2.1 算数运算符"></a>2.2.1 算数运算符</h4><ul>
<li>注意<ul>
<li>左结合性(从左到右计算)</li>
<li>NaN和任何运算都是NaN，都会先转换为number再计算(+””除外)</li>
<li>取余操作：m%n=余数  m&gt;n<del>余数  m&lt;n</del>m  n=0~NaN  （结果正负性取决于m）</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//加减乘除、取余、幂(ES7，和Math.pow()函数类似)</span><br>+ - * / % **<br></code></pre></td></tr></table></figure>

<h4 id="2-2-2-赋值运算符"><a href="#2-2-2-赋值运算符" class="headerlink" title="2.2.2 赋值运算符"></a>2.2.2 赋值运算符</h4><ul>
<li>优先级低于算数运算符、右结合性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//最常用的赋值运算符：=</span><br>=   <br><span class="hljs-comment">//链式赋值，从右往左计算</span><br><span class="hljs-keyword">var</span> num=num1=num2=<span class="hljs-number">1</span>+<span class="hljs-number">1</span><br><span class="hljs-comment">//原地修改：对一个变量做运算，并将新的结果存储到同一个变量中</span><br>+=  -=  *=  /=  %= **=<br></code></pre></td></tr></table></figure>

<h4 id="2-2-3-自增自减运算符"><a href="#2-2-3-自增自减运算符" class="headerlink" title="2.2.3 自增自减运算符"></a>2.2.3 自增自减运算符</h4><ul>
<li>注意<ul>
<li>自增/自减只能应用于变量，应用于数值（比如5++）会报错</li>
<li>尽量单独出现，不推荐在表达式中写（阅读性较差）</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//n++和++n区别：n++表达式值为n, ++n为n+1</span><br>++  --  <br><span class="hljs-comment">//四种实现方法</span><br><span class="hljs-keyword">var</span> Index=<span class="hljs-number">0</span><br>index=index+<span class="hljs-number">1</span><br>index+=<span class="hljs-number">1</span><br>index++<br>++index<br></code></pre></td></tr></table></figure>

<h4 id="2-2-4-关系-比较-运算符"><a href="#2-2-4-关系-比较-运算符" class="headerlink" title="2.2.4 关系(比较)运算符"></a>2.2.4 关系(比较)运算符</h4><ul>
<li>注意：<ul>
<li>关系运算符返回布尔值：关系成立就返回true，不成立就返回false</li>
<li>任何非数值类型，先转换为数值类型再判断(字符串和字符串比较除外)</li>
<li>参与比较的都是字符串，比较对应的Unicode编码(一位一位比较Unicode)</li>
<li>任何数据和NaN比较，返回值都是false</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//左结合性,前四个优先级高后四</span><br>&gt;  &lt;  &gt;=  &lt;=  ==  !=  ===  !==  <br> <br><span class="hljs-comment">/*== 和 ===区别：===只有取值和数据类型完全相同才会返回true（完全相等）</span><br><span class="hljs-comment">比较不同类型时，==两侧的值会先转成数字再进行比较（null除外）</span><br><span class="hljs-comment">开发建议都使用===、!==来降低犯错的可能性</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1&quot;</span> == <span class="hljs-literal">true</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1&quot;</span> === <span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">//三种特殊比较 （了解）</span><br><span class="hljs-literal">null</span>==<span class="hljs-number">0</span> <span class="hljs-literal">false</span> <br><span class="hljs-literal">undefined</span>==<span class="hljs-number">0</span> <span class="hljs-literal">false</span>  <br><span class="hljs-literal">null</span>==<span class="hljs-literal">undefined</span> <span class="hljs-literal">true</span> 	<span class="hljs-comment">//null衍生的</span><br><br><span class="hljs-comment">//判断是否是NaN，NaN==NaN(不能这样判断)  </span><br><span class="hljs-built_in">isNaN</span>()  <br></code></pre></td></tr></table></figure>



<h4 id="2-2-5-逻辑运算符"><a href="#2-2-5-逻辑运算符" class="headerlink" title="2.2.5 逻辑运算符"></a>2.2.5 逻辑运算符</h4><ul>
<li><p>三个逻辑运算符：&amp;&amp;(与)、 ||(或)、 !(非)</p>
</li>
<li><p>作用：将多个表达式或值放到一起来获得最终值</p>
</li>
<li><p>规则</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&amp;&amp;  	<span class="hljs-comment">//逻辑与 一假则假  </span><br>||  	<span class="hljs-comment">//逻辑或 一真则真  </span><br>!   	<span class="hljs-comment">//逻辑非 取反</span><br></code></pre></td></tr></table></figure></li>
<li><p>注意</p>
<ul>
<li>左结合性 、&amp;&amp;优先级高于||  </li>
<li>不是boolean先转换为boolean再计算</li>
</ul>
</li>
</ul>
<ul>
<li><p>短路现象：&amp;&amp;只要前面是假，后面的语句不会执行(检查)，||相反</p>
</li>
<li><p><strong>逻辑与/或的本质</strong></p>
<ul>
<li><p>逻辑或的本质（返回第一个真值运算元的初始值，不存在真值就返回最后一个）</p>
<ul>
<li>从左到右依次计算操作数，处理每一个运算元时都将其转成布尔值</li>
<li>一旦遇到某个运算元结果是true则停止计算，返回这个运算元的<strong>初始值</strong></li>
<li>如果所有运算元都被计算过（转换结果是true），则返回最后一个</li>
</ul>
</li>
<li><p>逻辑与的本质：返回第一个假值的运算元初始值，不存在返回最后一个</p>
</li>
<li><p>注意：返回的值是运算元的初始形式，不会转化为Boolean类型</p>
</li>
<li><p>总结：返回第一个能够决定表达式真假的运算元，如果没有则返回最后一个</p>
</li>
</ul>
</li>
<li><p>逻辑与、或在开发中的应用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//逻辑或-获取第一个有值的结果</span><br><span class="hljs-keyword">var</span> info=<span class="hljs-string">&quot;123&quot;</span><br><span class="hljs-keyword">var</span> message=info||<span class="hljs-string">&quot;默认值&quot;</span><br><br><span class="hljs-comment">//逻辑与-对一些对象中的方法进行有值判断</span><br><span class="hljs-keyword">var</span> obj=&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Kygo&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-function"><span class="hljs-title">sayHello</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;hello&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">//调用sayHello函数</span><br>obj &amp;&amp; obj.sayHello &amp;&amp; obj.sayHello()<br></code></pre></td></tr></table></figure></li>
<li><p>逻辑非 !</p>
<ul>
<li>接收一个参数，先将操作数转为布尔类型，再返回取反的值</li>
<li>应用：两个非运算符!!用来将某个值转为布尔类型</li>
</ul>
</li>
</ul>
<ul>
<li><p>其他运算符</p>
<ul>
<li><p>三元运算符：条件表达式 ? 结果A : 结果B  true-返回A</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//常见用法：如果info有值就使用info，否则给个默认值</span><br>info=&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span>&#125;<br><span class="hljs-keyword">var</span> obj = info ? info : &#123;&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>逗号运算符：简化代码/优先级最低/左结合性/运算结果是最后一个表达式结果</p>
</li>
<li><p>单目运算符：typeof/+/ -  +可用于隐式类型转换为number  </p>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-流程控制"><a href="#2-3-流程控制" class="headerlink" title="2.3 流程控制"></a>2.3 流程控制</h3><ul>
<li>流程控制基本知识<ul>
<li>程序的执行顺序：顺序结构、选择(分支)结构、循环结构</li>
<li>代码块{}<ul>
<li>多行代码的集合，通过一个花括号{}放到一起</li>
<li>可以通过流程控制语句来指定如何执行一个代码块</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-3-1-选择结构（分支语句）"><a href="#2-3-1-选择结构（分支语句）" class="headerlink" title="2.3.1 选择结构（分支语句）"></a>2.3.1 选择结构（分支语句）</h4><ul>
<li><p>if 分支语句、if else多分支语句、if  else if … else多分支语句</p>
</li>
<li><p>switch分支语句</p>
<ul>
<li>通过判断表达式结果（或变量）是否等于case语句的常量</li>
<li>if可以做值的范围判断，switch语句只能做值的相等判断（全等===）</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>如果代码块中语句只有一行，花括号{}可以省略</li>
<li>()括号内的表达式会自动转成布尔类型来判断是否执行代码块</li>
</ul>
</li>
<li><p>if/switch如何选择：对区间判断用if  对固定值判断用switch（能用if就用if）</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//只有一个会执行非布尔先转布尔再判断 </span><br><span class="hljs-keyword">if</span> / <span class="hljs-keyword">if</span> <span class="hljs-keyword">else</span> / <span class="hljs-keyword">if</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ...  <span class="hljs-keyword">else</span> <br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">switch语句中至少有一个case代码块和一个可选的default代码块</span><br><span class="hljs-comment">case穿透问题：一条case语句执行完后会自动指定下一条，使用break解决</span><br><span class="hljs-comment">break关键字：结束整个switch语句，一般在每个case后都加</span><br><span class="hljs-comment">case判断的是===  ()和case的表达式可以是常量/变量/表达式</span><br><span class="hljs-comment">default可以省略且不一定在最后（一般放在最后）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">switch</span>(表达式/变量)&#123;<br>  <span class="hljs-keyword">case</span> 常量<span class="hljs-number">1</span>: <br>    <span class="hljs-comment">//语句一</span><br>    <span class="hljs-keyword">break</span> <br>  <span class="hljs-keyword">case</span>... <br>  <span class="hljs-attr">default</span>: <br>    <span class="hljs-comment">//语句n</span><br>&#125;  <br></code></pre></td></tr></table></figure>



<h4 id="2-3-2-循环结构（循环语句）"><a href="#2-3-2-循环结构（循环语句）" class="headerlink" title="2.3.2 循环结构（循环语句）"></a>2.3.2 循环结构（循环语句）</h4><ul>
<li><p>重复运行同一段代码的方法，对列表进行循环操作也叫遍历或迭代</p>
</li>
<li><p>三种循环方式：while、do-while、for</p>
</li>
<li><p>注意</p>
<ul>
<li>尽量避免条件一直成立，造成死循环</li>
<li>for中用let定义的i只能在for中使用,变量作用域-let定义的变量在{}中有局部作用域</li>
<li>循环是可以嵌套的</li>
</ul>
</li>
<li><p>循环控制-break/continue关键字</p>
<ul>
<li>作用：终止循环的执行，可以是某次循环或直接结束整个循环</li>
<li>break：跳出当前循环</li>
<li>continue：本次循环不再执行continue后面的代码，跳入下次循环</li>
</ul>
</li>
<li><p>使用场景：在不知道具体循环次数的时候用while（for循环更加灵活，能用for就用for）</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//执行顺序：先执行begin(只执行一次)，然后进行迭代（先判断condition，成立再执行body，然后step...）</span><br><span class="hljs-keyword">for</span>(begin;condition;step)&#123;<br>  <span class="hljs-comment">//循环代码块</span><br>&#125;<br><span class="hljs-comment">//条件成立执行代码块，不成立不执行</span><br><span class="hljs-keyword">while</span>(循环条件)&#123;<br>  <span class="hljs-comment">//循环代码块</span><br>&#125;<br><span class="hljs-comment">//不管条件成不成立，都会先执行一次循环  </span><br><span class="hljs-keyword">do</span>&#123;<br>	<span class="hljs-comment">//循环代码块 </span><br>&#125;<span class="hljs-keyword">while</span>(循环条件)<br></code></pre></td></tr></table></figure>

<h3 id="2-4-函数"><a href="#2-4-函数" class="headerlink" title="2.4 函数"></a>2.4 函数</h3><h4 id="2-4-1-认识函数"><a href="#2-4-1-认识函数" class="headerlink" title="2.4.1 认识函数"></a>2.4.1 认识函数</h4><ul>
<li><p>程序中的foo、bar、baz</p>
<ul>
<li>作用：经常用作函数、变量、文件的名称，本身没有特殊意义</li>
</ul>
</li>
<li><p>什么是函数</p>
<ul>
<li>已经学习过的函数：alert、prompt、consloe.log、Number…</li>
<li>作用：用于封装一段可以随时反复执行的代码块</li>
</ul>
</li>
</ul>
<h4 id="2-4-2-函数的使用步骤"><a href="#2-4-2-函数的使用步骤" class="headerlink" title="2.4.2 函数的使用步骤"></a>2.4.2 函数的使用步骤</h4><ul>
<li><p>声明函数(定义函数) ：是对某些功能的封装过程</p>
</li>
<li><p>调用函数：调用自己封装好的某个函数，也可调用默认提供的或第三方库定义好的函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//使用关键字function声明函数，()调用函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params">形参列表</span>)</span>&#123;... <span class="hljs-keyword">return</span>;&#125;  <br>fun();<br></code></pre></td></tr></table></figure></li>
<li><p>注意</p>
<ul>
<li>函数命名规则和变量一样，定义完函数是不会执行的，必须通过()调用才会执行</li>
<li>形参和返回值可有可无，无返回值默认返回undefined</li>
<li>return语句和break语句一样后面不要跟代码，永远不会执行</li>
</ul>
</li>
<li><p>函数的参数</p>
<ul>
<li>形参(parameter)：定义函数时，小括号中的参数，用来接收参数用的，在函数内部作为变量使用</li>
<li>实参(argument)：调用函数时，小括号中的参数，用来把数据传递到函数内部用的</li>
</ul>
</li>
<li><p>函数的返回值</p>
<ul>
<li>使用return关键字来返回结果</li>
<li>一旦在函数中执行return，当前函数会终止</li>
<li>没有使用return或return后什么也不跟，都是返回undefined</li>
</ul>
</li>
<li><p>arguments变量(JS高级学习)</p>
<ul>
<li>由来：arguments对象是所有(非箭头)函数中都可用的局部变量</li>
<li>作用：该对象中保存所有传递给函数的实参（从0位置开始，依次存放）</li>
<li>注意：arguments变量类型是object(array-like)，不是一个数组</li>
</ul>
</li>
</ul>
<h4 id="2-4-3-函数的递归"><a href="#2-4-3-函数的递归" class="headerlink" title="2.4.3 函数的递归"></a>2.4.3 函数的递归</h4><ul>
<li><p>作用：将一个复杂的任务，转换成可以重复执行的相同任务</p>
</li>
<li><p>函数自己调用自己的过程就叫做递归-Recursion（必须有结束条件，否则会无限调用，造成报错）</p>
</li>
<li><p>练习</p>
<ul>
<li>用递归实现一个自己的幂函数pow</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//x的n次幂: pow(x,n)=x * pow(x,n-1)</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pow</span>(<span class="hljs-params">x,n</span>)</span>&#123;<br>  <span class="hljs-keyword">if</span>(n === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x<br>  <span class="hljs-keyword">return</span> x * pow(x,n-<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>实现斐波那契数列（使用递归和不使用递归都实现一编）<ul>
<li>某一个数是前两个数的和：1 1 2 3 5 8 13 21… （第一第二个数都是1）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-4-4-函数作用域"><a href="#2-4-4-函数作用域" class="headerlink" title="2.4.4 函数作用域"></a>2.4.4 函数作用域</h4><ul>
<li><p>什么是作用域：变量在某一个范围内可以使用</p>
</li>
<li><p>由来：在JS(ES5之前-var定义的)中没有块级作用域的概念，但是函数可以定义自己的作用域</p>
</li>
<li><p>函数作用域定义：函数作用域表示在函数内部定义的变量，只有在函数内部才能访问到</p>
</li>
<li><p>外部变量、局部变量</p>
<ul>
<li>局部变量：定义在函数内部的变量</li>
<li>外部变量：定义在函数外部的变量（在a函数外，但可能在其他函数中，叫做a的外部变量）</li>
</ul>
</li>
<li><p>全局变量</p>
<ul>
<li>范围：在所有函数外部(script中)声明的变量</li>
<li>全局变量在任何函数中都是可见的</li>
<li>通过var声明的全局变量会在window对象上添加一个属性</li>
</ul>
</li>
<li><p>函数中的变量访问顺序</p>
<ul>
<li>优先访问自己函数中的变量=&gt;没有找到就依次往外部找</li>
<li>外部函数里也没有=&gt;window对象=&gt;没有定义报错</li>
</ul>
</li>
<li><p>后续学习的：块级作用域、作用域链、变量提升、AO VO GO</p>
</li>
</ul>
<h4 id="2-4-5-函数表达式"><a href="#2-4-5-函数表达式" class="headerlink" title="2.4.5 函数表达式"></a>2.4.5 函数表达式</h4><ul>
<li><p>函数的另外一种定义方式 - 函数表达式</p>
<ul>
<li>函数也是引用数据类型(对象)，所以可以保存到变量中</li>
<li>function 后面一般省略函数名</li>
<li>无论怎么创建函数，函数都是一个特殊的值，值类型是一个对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;...&#125;<br>foo()<br></code></pre></td></tr></table></figure></li>
<li><p>函数声明 VS 函数表达式</p>
<ul>
<li><p>语法不同：函数声明是单独的语句声明函数，函数表达式是在表达式或另外的语句中创建函数</p>
</li>
<li><p>JS内部创建函数的时机不同</p>
<ul>
<li><p>函数表达式是代码执行到的时候函数才被创建，函数仅从那一刻开始可用</p>
</li>
<li><p>当JS准备运行脚本时，会在脚本寻找全局函数声明，并创建这些函数，然后再去运行脚本</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">foo()  <span class="hljs-comment">//可以成功调用foo函数，因为JS引擎在执行js脚本前会提前创建全局声明的函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;...&#125;<br><br>bar()  <span class="hljs-comment">//报错，找不到bar，因为是使用函数表达式创建函数，属于表达式，不会提前创建函数</span><br><span class="hljs-keyword">var</span> bar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;...&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>开发选择：首先考虑函数声明语法，因为它更加灵活 - 可以在声明函数前就调用这些函数</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-4-6-头等函数"><a href="#2-4-6-头等函数" class="headerlink" title="2.4.6 头等函数"></a>2.4.6 头等函数</h4><ul>
<li><p>定义：是指在程序设计语言中，函数被当做头等公民</p>
<ul>
<li>函数可以作为<strong>别的函数的参数、返回值、赋值给变量或存储在数据结构中</strong></li>
</ul>
</li>
<li><p>函数式编程 - 函数作为头等公民的编程方式</p>
</li>
<li><p>头等函数的体现</p>
<ul>
<li><p>函数可以被赋值给变量 - 函数表达式写法就是它的一种体现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;...&#125;<br><span class="hljs-keyword">var</span> bar = foo<br>bar()<br></code></pre></td></tr></table></figure></li>
<li><p>函数作为另外一个函数的参数、返回值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>)</span>&#123;...&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">fn</span>)</span>&#123;<br>  fn()<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baz</span>(<span class="hljs-params"></span>)</span>&#123;...&#125;<br>  <span class="hljs-comment">//函数作为返回值</span><br>  <span class="hljs-keyword">return</span> baz<br>&#125;<br><span class="hljs-comment">//函数作为参数传递</span><br>foo(bar)<br></code></pre></td></tr></table></figure></li>
<li><p>将函数存储在另外一个数据结构中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span>,<br>  <span class="hljs-attr">running</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;...&#125;<br>&#125;<br>foo.running()<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="2-4-7-回调函数"><a href="#2-4-7-回调函数" class="headerlink" title="2.4.7 回调函数"></a>2.4.7 回调函数</h4><ul>
<li><p>函数回调的理解（Callback Function）</p>
<ul>
<li><p>函数作为参数传递到另外一个函数内部，通过参数去调用函数称为函数的回调</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>)</span>&#123;...&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">fn</span>)</span>&#123;<br>  <span class="hljs-comment">//通过fn去调用bar的过程称为函数的回调</span><br>  fn()<br>&#125;<br>foo(bar)<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>函数回调的案例</p>
<ul>
<li><p>需求：通过URL向服务器发送网络请求，需要花较长时间拿到返回的结果</p>
</li>
<li><p>因为拿到结果需要一定的时间，所以我们可以传入一个回调函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span>(<span class="hljs-params">url,callback</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;通过URL向服务器发送网络请求，需要花较长时间拿到返回的结果&quot;</span>)<br>  <span class="hljs-comment">//假如拿到了结果</span><br>  <span class="hljs-keyword">var</span> resultList = [<span class="hljs-string">&quot;JS&quot;</span>, <span class="hljs-string">&quot;Vue&quot;</span>, <span class="hljs-string">&quot;React&quot;</span>]<br>  callback(resultList)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleResult</span>(<span class="hljs-params">res</span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;在handleResult中拿到的结果:&quot;</span>,res)&#125;<br><span class="hljs-comment">//传入函数，拿到结果</span><br>request(<span class="hljs-string">&quot;http://www.baidu.com/abc/getResult&quot;</span>, handleResult)<br><br><span class="hljs-comment">/*-----------代码重构--------------*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span>(<span class="hljs-params">url,callback</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;通过URL向服务器发送网络请求，需要花较长时间拿到返回的结果&quot;</span>)<br>  <span class="hljs-comment">//假如拿到了结果</span><br>  <span class="hljs-keyword">var</span> resultList = [<span class="hljs-string">&quot;JS&quot;</span>, <span class="hljs-string">&quot;Vue&quot;</span>, <span class="hljs-string">&quot;React&quot;</span>]<br>  callback(resultList)<br>&#125;<br><span class="hljs-comment">//传入的函数是没有名字的 - 匿名函数</span><br>request(<span class="hljs-string">&quot;http://www.baidu.com/abc/getResult&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;在handleResult中拿到的结果:&quot;</span>,res<br>&#125;)<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>高阶函数和匿名函数</p>
<ul>
<li>高阶函数至少满足两个条件<ul>
<li>接受一个或多个函数作为输入</li>
<li>输出一个函数</li>
</ul>
</li>
<li><strong>匿名函数</strong><ul>
<li>如果在传入一个函数时，我们没有指定这个变量的名称或通过函数表达式创建函数就称为匿名函数</li>
<li>应用：匿名函数经常作为其他函数的参数或返回值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-4-8-立即执行函数"><a href="#2-4-8-立即执行函数" class="headerlink" title="2.4.8 立即执行函数"></a>2.4.8 立即执行函数</h4><ul>
<li><p>什么是立即执行函数</p>
<ul>
<li><p>专业名字：IIFE - Immediately-Invoked Function Expression（立即调用函数表达式）</p>
</li>
<li><p>含义：函数定义完后立即执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//匿名函数 + ()</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是一个立即执行函数&quot;</span>)<br>&#125;)()<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>立即执行函数的作用</p>
<ul>
<li>立即执行函数中定义的变量有自己的作用域 - 函数作用域</li>
<li>会创建一个函数作用域，可以避免外界访问或修改内部变量</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li><p>场景一：ES6之前的协同开发就是使用这种方式-防止全局变量的命名冲突</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//应用一: 有自己的函数作用域,可以防止变量的命名冲突</span><br><span class="hljs-keyword">var</span> kygoModule = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">//定义要对外暴露的对象</span><br>  <span class="hljs-keyword">var</span> kygoModule = &#123;&#125;<br>  <br>  <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;kygo&quot;</span><br>  <span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span><br>  <br>  <span class="hljs-comment">//将外界需要用到的变量和函数添加到对象上</span><br>  kygoModule.age = age<br>  <span class="hljs-keyword">return</span> kygoModule<br>&#125;)()<br><span class="hljs-comment">//只能通过暴露的对象访问</span><br><span class="hljs-built_in">console</span>.log(kygoModule.age)<br></code></pre></td></tr></table></figure></li>
<li><p>场景二：获取所有按钮的监听点击</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//应用二: 遍历按钮并依次添加点击事件,要求打印出第n个按钮被点击了</span><br><span class="hljs-comment">//问题: 每次点击任意按钮都会打印出: 第4个按钮被点击了</span><br><span class="hljs-keyword">var</span> Eles = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;.btn&quot;</span>)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  Eles[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`我是第<span class="hljs-subst">$&#123;i + <span class="hljs-number">1</span>&#125;</span>个按钮`</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//重构代码: 使用立即执行函数的函数作用域解决问题</span><br><span class="hljs-comment">//也可以直接使用let定义i就可解决问题</span><br><span class="hljs-keyword">var</span> Eles = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;.btn&quot;</span>)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  <span class="hljs-comment">//这里光光使用立即执行函数包裹是不行的,需要每次传递i进入立即函数作用域中</span><br>  (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>)</span>&#123;<br>    Eles[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`我是第<span class="hljs-subst">$&#123;j + <span class="hljs-number">1</span>&#125;</span>个按钮`</span>)<br>  &#125;<br>  &#125;)(i)<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>立即执行函数的其他写法</p>
<ul>
<li><p>立即执行函数必须是一个表达式（整体），不能是一个函数声明</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//错误的写法，这种情况()前面的会被当做函数声明，因为不是一个整体</span><br><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;...&#125;()<br><span class="hljs-comment">//正确写法，()前面会被当做一个表达式</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;...&#125;)()<br><span class="hljs-comment">//其他写法(了解即可)</span><br>+<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;...&#125;()<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="2-5-对象"><a href="#2-5-对象" class="headerlink" title="2.5 对象"></a>2.5 对象</h3><h4 id="2-5-1-对象的基本使用"><a href="#2-5-1-对象的基本使用" class="headerlink" title="2.5.1 对象的基本使用"></a>2.5.1 对象的基本使用</h4><ul>
<li><p>为什么需要对象类型？</p>
<ul>
<li>基本数据类型可以存储一些简单的值，但是当需要存储比如：一辆车的信息，一个人的信息</li>
<li>对象类型就是将一类事物的特征和行为组织到了一起</li>
</ul>
</li>
<li><p>对象类型的语法和使用</p>
<ul>
<li><p>使用{Key: Value}  键值对的方式来表示对象</p>
</li>
<li><p>键值对可以是：属性、方法</p>
</li>
<li><p>Key是字符串（我们一般省略引号不写）</p>
</li>
<li><p>value可以是任意类型：基本数据类型、函数、对象等</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//创建一个对象</span><br><span class="hljs-keyword">var</span> foo = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span>,<br>  <span class="hljs-attr">running</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;I am Running!&quot;</span>)<br>  &#125;,<br>  <span class="hljs-string">&quot;my friend&quot;</span>: &#123;  <span class="hljs-comment">//不推荐这样写，只是为了验证key是字符串</span><br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobe&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>函数和方法</p>
<ul>
<li>Function  通过function默认定义的结构就是函数</li>
<li>Method  将一个函数放到对象中作为对象的一个属性，那么这个函数称为方法</li>
</ul>
</li>
</ul>
<h4 id="2-5-2-对象的创建方式"><a href="#2-5-2-对象的创建方式" class="headerlink" title="2.5.2 对象的创建方式"></a>2.5.2 对象的创建方式</h4><ul>
<li><p>创建对象的三种方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//方式一: 对象字面量创建</span><br><span class="hljs-keyword">var</span> foo = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span><br>&#125;<br><br><span class="hljs-comment">//方式二: 通过new Obj创建</span><br><span class="hljs-keyword">var</span> foo1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()<br>foo1.name = <span class="hljs-string">&quot;kygo1&quot;</span><br><br><span class="hljs-comment">//方式三: 通过其他类创建</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Bar</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><span class="hljs-keyword">var</span> foo2 = <span class="hljs-keyword">new</span> Bar()<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-5-3-对象的常见操作"><a href="#2-5-3-对象的常见操作" class="headerlink" title="2.5.3 对象的常见操作"></a>2.5.3 对象的常见操作</h4><ul>
<li><p>对象属性、方法的增删改查</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = &#123;&#125;<br><span class="hljs-comment">//增加</span><br>foo.name = <span class="hljs-string">&quot;kygo&quot;</span><br>foo.age = <span class="hljs-number">18</span><br>foo.bar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><br><span class="hljs-comment">//删除 delete操作符</span><br><span class="hljs-keyword">delete</span> foo.age<br><br><span class="hljs-comment">//修改（没有属性增加，有属性修改）</span><br>foo.name = <span class="hljs-string">&quot;kygo1&quot;</span><br><br><span class="hljs-comment">//查询</span><br><span class="hljs-built_in">console</span>.log(foo.name)<br><br><span class="hljs-comment">//删除对象属性: </span><br><span class="hljs-keyword">delete</span> obj.name;<br></code></pre></td></tr></table></figure></li>
<li><p>对象的方括号使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//操作对象属性另一种方式:对象[&quot;属性名&quot;]=属性值 (属性名可不遵守规则)</span><br><span class="hljs-keyword">var</span> baz = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span>,<br>  <span class="hljs-string">&quot;my friend&quot;</span>: <span class="hljs-string">&quot;kobe&quot;</span>,<br>  <span class="hljs-string">&quot;eating something&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(baz[<span class="hljs-string">&quot;my friend&quot;</span>])<br><span class="hljs-comment">//将字符串保存在变量中,通过[]使用属性、调用方法</span><br><span class="hljs-keyword">var</span> nameKey = <span class="hljs-string">&quot;name&quot;</span>,eatKey = <span class="hljs-string">&quot;eating something&quot;</span><br><span class="hljs-built_in">console</span>.log(baz[nameKey])<br>baz[eatKey]()<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-5-4-对象的遍历"><a href="#2-5-4-对象的遍历" class="headerlink" title="2.5.4 对象的遍历"></a>2.5.4 对象的遍历</h4><ul>
<li><p>两种遍历数组的方式</p>
<ul>
<li>遍历/迭代：获取对象的所有属性和方法</li>
<li>Object.key(obj) 会返回一个对象的属性名组成的数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-attr">height</span>: <span class="hljs-number">1.88</span><br>&#125;<br><br><span class="hljs-comment">//普通for循环遍历: 先拿到对象的属性名和属性个数-object.keys</span><br><span class="hljs-keyword">var</span> items = <span class="hljs-built_in">Object</span>.keys(foo)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; items.length; i++) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;items[i]&#125;</span>: <span class="hljs-subst">$&#123;foo[items[i]]&#125;</span>`</span>)<br>&#125;<br><br><span class="hljs-comment">//for...in遍历数组,item会依次拿到每个属性名</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> foo)&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;item&#125;</span>: <span class="hljs-subst">$&#123;foo[item]&#125;</span>`</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-5-5-JS内存分配"><a href="#2-5-5-JS内存分配" class="headerlink" title="2.5.5 JS内存分配"></a>2.5.5 JS内存分配</h4><ul>
<li><p>堆内存heap和栈内存stack</p>
<ul>
<li>程序是需要加载到内存中执行的，而内存可以分为堆内存和栈内存</li>
<li>原始类型占据的空间是在栈内存中分配的</li>
<li>对象类型占据的空间是在堆内存中分配的</li>
</ul>
</li>
<li><p>值类型和引用类型</p>
<ul>
<li><p>值类型：原始数据类型在变量中保存的是值本身</p>
</li>
<li><p>引用类型：对象类型在变量中保存的是对象的 “引用”</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//bar存储在栈内存中，保存的是值类型</span><br><span class="hljs-keyword">var</span> bar = <span class="hljs-string">&quot;kygo&quot;</span><br><br><span class="hljs-comment">//foo对象是分为两个地方存储</span><br><span class="hljs-comment">//&#123;...&#125;对象存储在堆内存中: 假如内存地址是0X110</span><br><span class="hljs-comment">//在栈内存中会存储对象的引用: foo = 0X110 来指向对象</span><br><span class="hljs-keyword">var</span> foo = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>一些现象的解释</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//现象一： 引用类型的比较</span><br><span class="hljs-keyword">var</span> foo = &#123;&#125;<br><span class="hljs-keyword">var</span> foo1 = &#123;&#125;<br><span class="hljs-built_in">console</span>.log(foo === foo1)<span class="hljs-comment">//false</span><br><br><span class="hljs-comment">//现象二： 引用类型的赋值</span><br><span class="hljs-keyword">var</span> bar = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span>,<br>  <span class="hljs-attr">friend</span>: &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobe&quot;</span><br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> friend = bar.friend<br>friend.name = <span class="hljs-string">&quot;kobe1&quot;</span><br><span class="hljs-built_in">console</span>.log(bar.friend.name)<span class="hljs-comment">//kobe1</span><br><br><span class="hljs-comment">//现象三： 值传递</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-number">213</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baz</span>(<span class="hljs-params">arg</span>) </span>&#123;<br>  arg = <span class="hljs-number">318</span><br>&#125;<br>baz(b)<br><span class="hljs-built_in">console</span>.log(b)<span class="hljs-comment">//213</span><br><br><span class="hljs-comment">//现象四： 引用传递，但是在函数中创建了一个新对象，没有对传入对象进行修改</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo2</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>  obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobe&quot;</span><br>  &#125;<br>&#125;<br>foo2(obj)<br><span class="hljs-built_in">console</span>.log(obj)<span class="hljs-comment">//&quot;kygo&quot;</span><br><br><span class="hljs-comment">//现象五： 引用传递，但是对传入的对象进行了修改</span><br><span class="hljs-keyword">var</span> obj1 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo3</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>  obj.name = <span class="hljs-string">&quot;kobe&quot;</span><br>&#125;<br>foo3(obj1)<br><span class="hljs-built_in">console</span>.log(obj1)<span class="hljs-comment">//&quot;kobe&quot;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-5-6-函数中的this指向"><a href="#2-5-6-函数中的this指向" class="headerlink" title="2.5.6 函数中的this指向"></a>2.5.6 函数中的this指向</h4><ul>
<li><p>什么是this</p>
<ul>
<li>函数中有一个this的变量，大多数情况下this会指向一个对象</li>
</ul>
</li>
<li><p>this的指向</p>
<ul>
<li><p>以默认的方式调用一个函数，this指向window</p>
</li>
<li><p>通过对象调用，this指向调用的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//普通函数声明的this</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>&#125; <br>foo() <span class="hljs-comment">//指向window</span><br><br><span class="hljs-comment">//方法的调用（通过对象调用）</span><br><span class="hljs-keyword">var</span> bar = &#123;<br>  <span class="hljs-attr">baz</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>  &#125;,<br>  <span class="hljs-attr">friend</span>: &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobe&quot;</span>,<br>    <span class="hljs-attr">running</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">//谁调用this就指向谁</span><br><span class="hljs-built_in">console</span>.log(bar.baz())  <span class="hljs-comment">//指向bar对象</span><br>bar.friend.running()  <span class="hljs-comment">//指向bar.friend对象</span><br><br><br><span class="hljs-comment">//考验题目一</span><br><span class="hljs-keyword">var</span> baz = bar.baz<br>baz() <span class="hljs-comment">//  this指向window对象</span><br><span class="hljs-comment">//考验题目二</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>&#125;<br><span class="hljs-keyword">var</span> foo1 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span>,<br>  <span class="hljs-attr">fun</span>: fun<br>&#125;<br>foo1.fun()  <span class="hljs-comment">//this指向foo1</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>this的应用</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-attr">running</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">//没有this的情况</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;foo.name&#125;</span> is running! age is <span class="hljs-subst">$&#123;foo.age&#125;</span>`</span>)<br>    <span class="hljs-comment">//使用this</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> is running! age is <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.age&#125;</span>`</span>)<br>  &#125;<br>&#125;<br>foo.running()<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-5-7-构造函数和类"><a href="#2-5-7-构造函数和类" class="headerlink" title="2.5.7 构造函数和类"></a>2.5.7 构造函数和类</h4><ul>
<li><p>创建一系列相似对象的方式</p>
<ul>
<li>在开发中需要创建一系列的相似对象，如一系列的学生对象</li>
<li>一种方法是直接创建一系列对象，但是这样重复代码太多</li>
<li>第二种方法是封装一个函数用于创建对象 - 工厂函数</li>
<li>第三种方法就是使用构造函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//方式一: 挨个创建</span><br><span class="hljs-keyword">var</span> obj1 = &#123;&#125;<br><span class="hljs-keyword">var</span> obj2 = &#123;&#125;<br><br><span class="hljs-comment">//方式二: 工厂函数创建对象，缺点-打印的对象都是Object类型</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">name, age, heigt</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> obj = &#123;&#125;<br>  obj.name = name<br>  obj.age = age<br>  obj.height = heigt<br>  <span class="hljs-keyword">return</span> obj<br>&#125;<br><span class="hljs-keyword">var</span> foo1 = foo(<span class="hljs-string">&quot;kygo&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">1.88</span>)<br><span class="hljs-keyword">var</span> foo2 = foo(<span class="hljs-string">&quot;kobe&quot;</span>, <span class="hljs-number">30</span>, <span class="hljs-number">1.98</span>)<br><span class="hljs-built_in">console</span>.log(foo1, foo2)<br></code></pre></td></tr></table></figure></li>
<li><p>认识构造函数</p>
<ul>
<li>构造函数也称为构造器constructor，是我们在创建对象时会调用的函数</li>
<li>在其他编程语言中，构造函数其实是类中的一个方法，称之为构造方法</li>
<li>JS中的构造函数有点不太一样，构造函数扮演了其他语言中类的角色</li>
<li>ES5之前，都是通过function来声明一个构造函数(类)，之后通过new关键字来对其调用</li>
<li>ES6之后，JS可以向别的语言一样，通过class来声明一个类</li>
<li>类和对象的关系：类是一类事物的统称(如：水果)，而对象是具体的体现（如：苹果）</li>
</ul>
</li>
</ul>
<ul>
<li><p>类(ES5)</p>
<ul>
<li>JS中的类的表示形式就是构造函数，构造函数===类</li>
<li>构造函数<ul>
<li>构造函数也是一个普通的函数，表现形式和其他函数没有任何区别</li>
<li>如果一个普通函数使用new操作符来调用了，这个函数就称为构造函数</li>
</ul>
</li>
<li>函数被new操作符调用了，会执行以下操作（了解）<ul>
<li>在内存中创建一个新的空对象</li>
<li>这个对象内部的[prototype]属性会被赋值为该构造函数的[prototype]属性</li>
<li>构造函数内部的this，会指向创建出来的新对象</li>
<li>执行函数的内部代码</li>
<li>如果构造函数没有返回非空对象，则返回创建出来的新对象</li>
</ul>
</li>
<li>构造函数的补充<ul>
<li>构造函数的名称：使用大驼峰</li>
</ul>
</li>
</ul>
</li>
<li><p>创建对象的方案 - 类</p>
<ul>
<li><p>构造函数可以确保创建的对象是Person类型的(实际是constructor属性)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//构造函数创建对象</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age, height</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name<br>  <span class="hljs-built_in">this</span>.age = age<br>  <span class="hljs-built_in">this</span>.height = height<br>  <span class="hljs-built_in">this</span>.running = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`my name is <span class="hljs-subst">$&#123;name&#125;</span>`</span>)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;kygo&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">1.88</span>)<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;kobe&quot;</span>, <span class="hljs-number">30</span>, <span class="hljs-number">1.98</span>)<br><span class="hljs-built_in">console</span>.log(person1, person2)<br></code></pre></td></tr></table></figure></li>
<li><p>构造函数的其他特征（JS高级）</p>
<ul>
<li>原型、原型链、实现继承的方案</li>
<li>ES6中的类、继承的实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-5-8-全局对象window"><a href="#2-5-8-全局对象window" class="headerlink" title="2.5.8 全局对象window"></a>2.5.8 全局对象window</h4><ul>
<li><p>由来</p>
<ul>
<li>浏览器中有一个全局对象window</li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li><p>查找变量最终会查找到window上</p>
</li>
<li><p>将一些浏览器全局提供给我们的变量、函数、对象，放在window对象上</p>
</li>
<li><p>使用var定义的变量会被默认添加到window上面</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.console === <span class="hljs-built_in">console</span>)  <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.document === <span class="hljs-built_in">document</span>)  <span class="hljs-comment">//true</span><br><br><span class="hljs-keyword">var</span> foo = <span class="hljs-number">213</span>, bar = &#123;&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.foo, <span class="hljs-built_in">window</span>.bar === bar) <span class="hljs-comment">//213</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="2-5-9-函数也是对象"><a href="#2-5-9-函数也是对象" class="headerlink" title="2.5.9 函数也是对象"></a>2.5.9 函数也是对象</h4><ul>
<li><p>函数也是引用类型，存储在堆内存中</p>
<ul>
<li>虽然typeof函数结果为function，但是function类型都是对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//foo中存储的是函数的内存地址,如0X101</span><br><span class="hljs-comment">//栈内存存储：foo = 0X101  堆内存中存储： function()&#123;&#125; 内存地址为0X101</span><br><span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><span class="hljs-comment">//将foo中存储的内存地址赋值给bar</span><br><span class="hljs-keyword">var</span> bar = foo<br><span class="hljs-comment">//通过内存地址来调用堆内存中的函数</span><br>bar()<br>foo()<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> foo)  <span class="hljs-comment">//function =&gt; Object</span><br><span class="hljs-comment">//地址-指针-引用</span><br><span class="hljs-comment">//定义对象类型的变量,obj/foo/bar都是存储在堆内存中的</span><br><span class="hljs-keyword">var</span> obj = &#123;&#125;<br><span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-6-常见内置类"><a href="#2-6-常见内置类" class="headerlink" title="2.6. 常见内置类"></a>2.6. 常见内置类</h3><ul>
<li>内置类：默认javascript已经给我们封装好的类(构造函数)，我们只需要去使用即可</li>
</ul>
<h4 id="3-1-认识包装类型"><a href="#3-1-认识包装类型" class="headerlink" title="3.1 认识包装类型"></a>3.1 认识包装类型</h4><ul>
<li><p>JS的原始类型并非对象类型，从理论上来说是没办法获取属性和方法的</p>
</li>
<li><p>奇怪的现象</p>
<ul>
<li><p>我们可以看到原始类型调用了属性和方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> msg = <span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-built_in">console</span>.log(msg.length) <span class="hljs-comment">//11</span><br><span class="hljs-built_in">console</span>.log(msg.split(<span class="hljs-string">&quot; &quot;</span>)) <span class="hljs-comment">//[&#x27;hello&#x27;,&#x27;world&#x27;]</span><br><br><span class="hljs-keyword">var</span> num = <span class="hljs-number">3.14159</span><br><span class="hljs-built_in">console</span>.log(num.toFixed(<span class="hljs-number">2</span>)) <span class="hljs-comment">//3.14</span><br></code></pre></td></tr></table></figure></li>
<li><p>现象解释：JS为了其可以调用属性和方法，封装了对应的包装类型（String、Number）</p>
</li>
</ul>
</li>
<li><p>常见的包装类型</p>
<ul>
<li>String、Number、Boolean、Symbol、BigInt类型</li>
</ul>
</li>
<li><p>包装类型的使用过程</p>
<ul>
<li><p>默认情况，当我们调用一个原始类型的属性或者方法时，会进行以下操作</p>
</li>
<li><p>通常JS引擎会做很多优化：它可以跳过创建包装类过程，在内部直接完成属性的获取或方法调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num = <span class="hljs-number">3.14159</span><br><span class="hljs-built_in">console</span>.log(num.toFixed(<span class="hljs-number">2</span>)) <span class="hljs-comment">//3.14</span><br><br><span class="hljs-comment">//js内部做了以下操作</span><br><span class="hljs-comment">//1.根据原始值，创建一个原始类型对应的包装类型对象</span><br><span class="hljs-keyword">var</span> numObj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(num)<br><span class="hljs-comment">//2.调用对应的属性和方法，返回一个新的值</span><br><span class="hljs-keyword">var</span> result = numObj.toFixed(<span class="hljs-number">2</span>)<br><span class="hljs-comment">//3.创建的包装类对象被销毁</span><br><span class="hljs-built_in">console</span>.log(result)<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="3-2-数字包装类Number"><a href="#3-2-数字包装类Number" class="headerlink" title="3.2 数字包装类Number"></a>3.2 数字包装类Number</h4><ul>
<li><p>属性的补充</p>
<ul>
<li>最大/小安全整数<ul>
<li>Number.MAX_SAFE_INTEGER/Number.MIN_SAFE_INTEGER</li>
</ul>
</li>
</ul>
</li>
<li><p>实例方法的补充</p>
<ul>
<li>toString([base])<ul>
<li>数字转字符串，并且按照base进制转化</li>
<li>注意：直接对数字操作需要使用..运算符(如：123..toString())</li>
</ul>
</li>
<li>toFixed(digits)<ul>
<li>格式化数字，保留digits位小数，返回字符串(注意)</li>
</ul>
</li>
</ul>
</li>
<li><p>类方法的补充</p>
<ul>
<li>Number.parseInt(string [, base]) 字符串转整数，也有对应的全局方法parseInt</li>
<li>Number.parseFloat(string)  字符串转浮点数，也有全局方法parseFloat</li>
</ul>
</li>
<li><p>其他方法用到查MDN即可</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number</a></li>
</ul>
</li>
<li><p>程序示例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//数字静态属性</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER, <span class="hljs-built_in">Number</span>.MIN_SAFE_INTEGER)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.MAX_VALUE, <span class="hljs-built_in">Number</span>.MIN_VALUE)<br><br><span class="hljs-comment">//实例方法: toString/toFixed</span><br><span class="hljs-keyword">var</span> num = <span class="hljs-number">213</span><br><span class="hljs-built_in">console</span>.log(num.toString(<span class="hljs-number">8</span>), <span class="hljs-keyword">typeof</span> num.toString(<span class="hljs-number">8</span>))  <span class="hljs-comment">//325 string</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">123.</span>.toString(), <span class="hljs-number">123.321</span>.toFixed(<span class="hljs-number">1</span>))  <span class="hljs-comment">//123 123.3</span><br><br><span class="hljs-keyword">var</span> num1 = <span class="hljs-number">213.318</span><br><span class="hljs-built_in">console</span>.log(num1.toFixed(<span class="hljs-number">2</span>), <span class="hljs-keyword">typeof</span> num1.toFixed(<span class="hljs-number">2</span>))  <span class="hljs-comment">//213.32 string</span><br><br><span class="hljs-comment">//静态方法/全局对象方法 parseInt/parseFloat</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.parseInt(<span class="hljs-string">&quot;213aaa&quot;</span>))  <span class="hljs-comment">//213</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.parseFloat(<span class="hljs-string">&quot;213.318bbb&quot;</span>))  <span class="hljs-comment">//213.318</span><br><span class="hljs-comment">//同一个方法</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.parseInt === <span class="hljs-built_in">parseInt</span>) <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-3-数学对象Math"><a href="#3-3-数学对象Math" class="headerlink" title="3.3 数学对象Math"></a>3.3 数学对象Math</h4><ul>
<li><p>Math对象简单认识</p>
<ul>
<li>除了Number类可以对数字进行处理外，JS还提供了一个Math对象</li>
<li>Math是一个内置对象（不是一个构造函数），它有一些数学常数属性和数学函数方法</li>
</ul>
</li>
<li><p>Math常用属性</p>
<ul>
<li>Math.PI - 圆周率</li>
</ul>
</li>
<li><p>Math常见方法</p>
<ul>
<li>Math.floor - 向下取整</li>
<li>Math.ceil - 向上取整</li>
<li>Math.round - 四舍五入取整</li>
<li>Math.random - 生成[0,1)的随机数</li>
<li>Math.pow(x,y) - 返回x的y次幂</li>
</ul>
</li>
<li><p>其他方法见MDN</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math</a></li>
</ul>
</li>
<li><p>程序示例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//静态属性</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.PI)  <span class="hljs-comment">//3.14159...</span><br><br><span class="hljs-comment">//静态方法</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.floor(<span class="hljs-number">3.14</span>)) <span class="hljs-comment">//3</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.ceil(<span class="hljs-number">3.14</span>))  <span class="hljs-comment">//4</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.round(<span class="hljs-number">2.4</span>))  <span class="hljs-comment">//2</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.round(<span class="hljs-number">2.5</span>))  <span class="hljs-comment">//3</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))  <span class="hljs-comment">//8</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.random())<br><span class="hljs-comment">//获取任意区间随机数 m~n x=n-m y=m   </span><br><span class="hljs-comment">//Math.floor(Math.random() * x + y)</span><br><span class="hljs-comment">//100个[10,100)的数字</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random()* <span class="hljs-number">90</span> + <span class="hljs-number">10</span>))<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-4-字符串包装类String"><a href="#3-4-字符串包装类String" class="headerlink" title="3.4 字符串包装类String"></a>3.4 字符串包装类String</h4><ul>
<li><p>String类的基本使用</p>
<ul>
<li>开发中，我们经常需要对字符串进行各种操作，String类给我们提供了对应的属性和方法</li>
<li>String类常见属性<ul>
<li>length - 获取字符串长度</li>
</ul>
</li>
<li>访问字符串的字符<ul>
<li>方法一：字符串索引 arr[0]</li>
<li>方法二：通过str.charAt(pos)方法</li>
<li>区别：索引方式没有找到会返回undefined，charAt没有找到会回空字符串</li>
</ul>
</li>
<li>字符串的遍历<ul>
<li>方法一：普通for循环</li>
<li>方法二：for…of遍历</li>
</ul>
</li>
</ul>
</li>
<li><p>修改字符串</p>
<ul>
<li>字符串的不可变性<ul>
<li>字符串定义后是不可修改的，如：str[1] = “A” 不会起作用</li>
</ul>
</li>
<li>以下修改字符串的方法，都是返回新的字符串（不修改原字符串）<ul>
<li>toLowerCase() - 将所有字符串转为小写</li>
<li>toUpperCase() - 将所有字符串转为大写</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;Hello World!&quot;</span><br><span class="hljs-comment">//获取字符串长度</span><br><span class="hljs-built_in">console</span>.log(str.length)  <span class="hljs-comment">//12</span><br><span class="hljs-comment">//访问字符串字符</span><br><span class="hljs-built_in">console</span>.log(str[<span class="hljs-number">4</span>])  <span class="hljs-comment">//o</span><br><span class="hljs-built_in">console</span>.log(str.charAt(<span class="hljs-number">4</span>))  <span class="hljs-comment">//o</span><br><span class="hljs-built_in">console</span>.log(str[<span class="hljs-number">100</span>], str.charAt(<span class="hljs-number">100</span>))  <span class="hljs-comment">//undefined &#x27;&#x27;</span><br><span class="hljs-comment">//字符串的遍历</span><br><span class="hljs-comment">//普通for遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i++) &#123;<br>  <span class="hljs-built_in">console</span>.log(str[i])<br>&#125;<br><span class="hljs-comment">//for...of 迭代器遍历</span><br><span class="hljs-comment">//目前支持可迭代对象: 字符串/数组(对象不支持)</span><br><span class="hljs-comment">//String对象内部把字符串变成了一个可迭代对象</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> char <span class="hljs-keyword">of</span> str) &#123;<br>  <span class="hljs-built_in">console</span>.log(char)<br>&#125;<br><br><span class="hljs-comment">//修改字符串</span><br>str[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;c&#x27;</span><br><span class="hljs-built_in">console</span>.log(str)  <span class="hljs-comment">//字符串不可变性,这样操作无意义</span><br><span class="hljs-comment">//两个转小写大写方法(重要)</span><br><span class="hljs-built_in">console</span>.log(str.toLowerCase())  <span class="hljs-comment">//hello world!</span><br><span class="hljs-built_in">console</span>.log(str.toUpperCase())  <span class="hljs-comment">//HELLO WORLD!</span><br></code></pre></td></tr></table></figure></li>
<li><p>查找字符串</p>
<ul>
<li>开发中经常会在一个字符串中查找或获取另外一个字符串</li>
<li>方法一：查找字符串位置<ul>
<li>str . indexOf(searchValue [, fromIndex])</li>
<li>方法解释：从fromIndex开始，查找searchValue的索引，没有找到返回-1</li>
<li>相似方法：lastIndexOf，从最后开始查找（用得较少）</li>
</ul>
</li>
<li>方法二：是否包含字符串<ul>
<li>str . Includes (searchString [, position])    (ES6中新增方法)</li>
<li>从position位置开始查找searchString，返回true或false</li>
</ul>
</li>
<li>方法三：以XXX开头<ul>
<li>str . startsWith(searchString [, position])</li>
<li>从position位置开始，判断字符串是否以searchString开头(ES6 新增方法)</li>
</ul>
</li>
<li>方法四：以XXX结尾<ul>
<li>str.endsWith(searchString[, length])</li>
<li>在length长度内，判断是否以searchString结束</li>
</ul>
</li>
<li>方法五：替换字符串<ul>
<li>str.replace(regexp|substr, newSubStr|function)</li>
<li>查找substr字符串(也可使用regexp正则表达式)，使用新的字符串替换(也可传入函数替换)</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;Hello World!&quot;</span><br><span class="hljs-comment">//indexOf/lastIndexOf查找字符串(没有找到返回-1)</span><br><span class="hljs-built_in">console</span>.log(str.indexOf(<span class="hljs-string">&quot;llo&quot;</span>))  <span class="hljs-comment">//2</span><br><span class="hljs-built_in">console</span>.log(str.indexOf(<span class="hljs-string">&quot;He&quot;</span>, <span class="hljs-number">2</span>))  <span class="hljs-comment">//-1 </span><br><span class="hljs-built_in">console</span>.log(str.lastIndexOf(<span class="hljs-string">&quot;He&quot;</span>))  <span class="hljs-comment">//0</span><br><span class="hljs-comment">//includes是否包含字符串</span><br><span class="hljs-built_in">console</span>.log(str.includes(<span class="hljs-string">&quot;lo&quot;</span>))  <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(str.includes(<span class="hljs-string">&quot;lo&quot;</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment">//false</span><br><br><span class="hljs-comment">//以XXX开始,XXX结尾</span><br><span class="hljs-built_in">console</span>.log(str.startsWith(<span class="hljs-string">&quot;llo&quot;</span>))  <span class="hljs-comment">//false</span><br><span class="hljs-built_in">console</span>.log(str.startsWith(<span class="hljs-string">&quot;llo&quot;</span>, <span class="hljs-number">2</span>))  <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(str.endsWith(<span class="hljs-string">&quot;ld!&quot;</span>))  <span class="hljs-comment">//true</span><br><br><span class="hljs-comment">//字符串的替换</span><br><span class="hljs-built_in">console</span>.log(str.replace(<span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-string">&quot;cth&quot;</span>))  <span class="hljs-comment">//Hellcth World!</span><br><span class="hljs-comment">//将o替换为大写O</span><br><span class="hljs-built_in">console</span>.log(str.replace(<span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;O&quot;</span>	<span class="hljs-comment">//返回的值即替换的值</span><br>&#125;))<br></code></pre></td></tr></table></figure></li>
<li><p>获取子字符串（开发推荐slice方法）</p>
<ul>
<li>slice(start, end)    [start, end) 切割字符串，获得子串</li>
<li>substring(start, end)    [start, end) 切割字符串</li>
<li>substr(start, length)    从start开始获取长度为length的字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;hi kygo!&quot;</span><br><span class="hljs-comment">//三种获取子字符串的方法</span><br><span class="hljs-comment">//推荐slice,支持负数(从右往左数)</span><br><span class="hljs-built_in">console</span>.log(str.slice(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>))  <span class="hljs-comment">//kygo  [3,7)</span><br><span class="hljs-built_in">console</span>.log(str.slice(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>))  <span class="hljs-comment">//hi kygo  [0,-1)</span><br><span class="hljs-built_in">console</span>.log(str.substring(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>))  <span class="hljs-comment">//kygo  [3,7)</span><br><span class="hljs-comment">//第三个位置开始,截取4个字符</span><br><span class="hljs-built_in">console</span>.log(str.substr(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))  <span class="hljs-comment">//kygo</span><br></code></pre></td></tr></table></figure></li>
<li><p>其他方法</p>
<ul>
<li><p>拼接字符串</p>
<ul>
<li>str.concat(str2[,…strN])</li>
</ul>
</li>
<li><p>删除首尾空格</p>
<ul>
<li>str.trim()</li>
</ul>
</li>
<li><p>字符串分割</p>
<ul>
<li>str.split([separator[, limit]])</li>
<li>以separator分割，也可是一个正则表达式，limit限制返回分割后片断的数量</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//拼接字符串: +/concat</span><br><span class="hljs-built_in">console</span>.log(str.concat(<span class="hljs-string">&quot;go&quot;</span>).concat(<span class="hljs-string">&quot;go&quot;</span>).concat(<span class="hljs-string">&quot;go!&quot;</span>))  <span class="hljs-comment">//链式调用</span><br><span class="hljs-built_in">console</span>.log(str.concat(<span class="hljs-string">&quot;gogogo&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>))  <span class="hljs-comment">//hi kygo!gogogog</span><br><br><span class="hljs-comment">//删除字符串首尾空格</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot; ky  go &quot;</span>.trim())  <span class="hljs-comment">//ky  go</span><br><br><span class="hljs-comment">//字符串分割,默认每个字母为单位分割</span><br><span class="hljs-keyword">var</span> str1 = <span class="hljs-string">&quot;ab-cd-ef-gh&quot;</span><br><span class="hljs-keyword">var</span> items = str1.split(<span class="hljs-string">&quot;-&quot;</span>)<br><span class="hljs-keyword">var</span> newStr1 = items.join(<span class="hljs-string">&quot;*&quot;</span>) <span class="hljs-comment">//数组的join</span><br><span class="hljs-built_in">console</span>.log(items)  <span class="hljs-comment">//[&#x27;ab&#x27;, &#x27;cd&#x27;, &#x27;ef&#x27;, &#x27;gh&#x27;]</span><br><span class="hljs-built_in">console</span>.log(newStr1)  <span class="hljs-comment">//ab*cd*ef*gh</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>MDN文档：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String</a></p>
</li>
</ul>
<h4 id="3-5-Date类型的使用"><a href="#3-5-Date类型的使用" class="headerlink" title="3.5 Date类型的使用"></a>3.5 Date类型的使用</h4><ul>
<li><p>时间的表示方式（了解）</p>
<ul>
<li>最初通过观测太阳的位置决定时间，缺点：不同区域位置使用的时间不同</li>
<li>之后开始制作标准时间：英国伦敦格的皇家格林威治天文台的标准时间(GMT)<ul>
<li>以本初子午线为标准（经度0度）</li>
<li>其他时区根据地理位置确定：往东的时区(GMT+hh:mm)  往西的时区(GMT-hh)</li>
</ul>
</li>
<li>但是公转有一定误差，所以造成GMT的时间有一定误差，于是提出了根<strong>据原子钟计算的标准时间UTC</strong></li>
<li>目前GMT依然在使用，主要表示某个时区中的时间，而UTC是标准的时间</li>
<li>举例：中国在UTC往东(东八区)，所以北京标准时间是在UTC时间上加8小时</li>
</ul>
</li>
<li><p>Date对象的创建</p>
<ul>
<li><p>JS中使用Date来表示和处理时间</p>
</li>
<li><p>Date构造函数用法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1. 没有传入获取当前时间</span><br><span class="hljs-keyword">var</span> date1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br><span class="hljs-built_in">console</span>.log(date1)<br><span class="hljs-comment">//2. 传入时间字符串获取时间</span><br><span class="hljs-keyword">var</span> date2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&quot;2023-02-18&quot;</span>)<br><span class="hljs-built_in">console</span>.log(date2)<br><span class="hljs-comment">//3. 传入Unix时间戳获取时间</span><br><span class="hljs-keyword">var</span> date3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">1321331211312</span>)<br><span class="hljs-built_in">console</span>.log(date3)<br><span class="hljs-comment">//4. 依次传入 年月日时分秒毫秒 获取时间</span><br><span class="hljs-keyword">var</span> date4 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2023</span>,<span class="hljs-number">2</span>,<span class="hljs-number">18</span>,<span class="hljs-number">14</span>,<span class="hljs-number">54</span>,<span class="hljs-number">10</span>,<span class="hljs-number">123</span>)<br><span class="hljs-built_in">console</span>.log(date4)<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>dateString时间的表示方式</p>
<ul>
<li><p>RFC 2822标准</p>
<ul>
<li>默认打印的时间格式就是RFC标准的：new Date()</li>
</ul>
</li>
<li><p>ISO 8601标准</p>
<ul>
<li>转成ISO标准：new Date().toISOString()</li>
<li>YYYY-MM-DDTHH:mm:ss.sssZ    （T用于分隔可省略，Z表示时区，SSS表示毫秒）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//时间格式</span><br><span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br><span class="hljs-built_in">console</span>.log(date) <span class="hljs-comment">//Sat Feb 18 2023 15:01:14 GMT+0800 (中国标准时间)</span><br><span class="hljs-built_in">console</span>.log(date.toISOString()) <span class="hljs-comment">//2023-02-18T07:01:14.835Z</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Date获取信息的方法</p>
<ul>
<li><p>从Date对象中获取各种详细的信息</p>
</li>
<li><p>getFullYear()  getMonth()  getDate()    获取年月日(注意：月份是0-11)</p>
</li>
<li><p>getHours()  getMinutes()  getSeconds()  getMilliseconds   获取时分秒毫秒</p>
</li>
<li><p>getDay()    获取一周中的第几天，从0(周天)-6(周六)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//date获取信息方法</span><br><span class="hljs-keyword">var</span> nowDate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br><span class="hljs-built_in">console</span>.log(nowDate.getFullYear())  <span class="hljs-comment">//2023</span><br><span class="hljs-built_in">console</span>.log(nowDate.getMonth())  <span class="hljs-comment">//1 (当前是2月)</span><br><span class="hljs-comment">//获取当前是一周的第几天</span><br><span class="hljs-built_in">console</span>.log(nowDate.getDay())  <span class="hljs-comment">//6 (星期六)</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Date的设置方法</p>
<ul>
<li><p>setFullYear…（get方法也有对应的set方法）</p>
</li>
<li><p>不同的是setFullYear(year,[month],[date])、setHours(hour,[min]…)可以设置多个参数</p>
</li>
<li><p>setTime(milliseconds)    传入时间戳设置时间</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//date的设置方法</span><br><span class="hljs-keyword">var</span> setDate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br>setDate.setFullYear(<span class="hljs-number">2050</span>) <br><span class="hljs-built_in">console</span>.log(setDate)  <span class="hljs-comment">//Fri Feb 18 2050 15:10:19 GMT+0800 (中国标准时间)</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Date获取Unix时间戳</p>
<ul>
<li><p>Unix时间戳：一个整数值，表示自1970年1月1日00:00:00 UTC以来的毫秒数</p>
</li>
<li><p>JS中，有多个方法可以获取到时间戳</p>
<ul>
<li>new Date().getTime()</li>
<li>new Date().valueOf()</li>
<li>Date.now()</li>
<li>+new Date()  算数运算符自动转换</li>
</ul>
</li>
<li><p>获取到Unix时间戳后，可以用作测试代码性能(运行时间)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//Date获取Unix时间戳</span><br><span class="hljs-keyword">var</span> unixDate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br><span class="hljs-comment">//将一个date对象转成时间戳</span><br><span class="hljs-built_in">console</span>.log(unixDate.getTime())<br><span class="hljs-built_in">console</span>.log(unixDate.valueOf())<br><span class="hljs-comment">//获取当前时间戳</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Date</span>.now())<br><span class="hljs-built_in">console</span>.log(+unixDate)  <span class="hljs-comment">//不推荐</span><br><br><span class="hljs-comment">//计算操作所花时间</span><br><span class="hljs-keyword">var</span> startTime = <span class="hljs-built_in">Date</span>.now()<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>  <span class="hljs-built_in">console</span>.log(i)<br>&#125;<br><span class="hljs-keyword">var</span> endTime = <span class="hljs-built_in">Date</span>.now()<br><span class="hljs-built_in">console</span>.log(endTime - startTime)  <span class="hljs-comment">//147ms</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Date.parse方法</p>
<ul>
<li>作用：将时间字符串转为时间戳</li>
<li>注意<ul>
<li>作用等同于new Date(dateString).getTime()操作</li>
<li>需要符合RFC或ISO日期格式的字符串，如：YYYY-MM-DDTHH:mm:ss:sssZ</li>
<li>如果输入的格式不能被解析，则返回NaN</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//字符串转时间戳</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Date</span>.parse(<span class="hljs-string">&quot;2023-3-18&quot;</span>))<br><span class="hljs-comment">//以上方法和以下方法同样的效果</span><br><span class="hljs-built_in">console</span>.log((<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&quot;2023-3-18&quot;</span>)).getTime())<br><span class="hljs-built_in">console</span>.log((<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&quot;2023-3-18&quot;</span>)).valueOf())<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-7-数组Array使用详解"><a href="#2-7-数组Array使用详解" class="headerlink" title="2.7 数组Array使用详解"></a>2.7 数组Array使用详解</h3><ul>
<li><p>什么是数组</p>
<ul>
<li>可以通过索引来访问的有序集合叫做数组，通过[]创建</li>
<li>数组是一种特殊的对象类型</li>
</ul>
</li>
<li><p>数组的注意点</p>
<ul>
<li><p>数组对应索引没有存储数据时默认为undefined</p>
</li>
<li><p>访问数组不存在的索引不会报错，返回undefined</p>
</li>
<li><p>数组存储空间不足时会自动扩容</p>
</li>
<li><p>数组可以存储不同的数据类型</p>
</li>
<li><p>数组分配的存储空间不一定是连续的(因为存储的数据类型不同)</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-7-1-数组的创建方式"><a href="#2-7-1-数组的创建方式" class="headerlink" title="2.7.1 数组的创建方式"></a>2.7.1 数组的创建方式</h4><ul>
<li><p>两种方式：通过[ ]创建、通过new Array创建</p>
</li>
<li><p>创建数组时，设置数组长度（少用）</p>
</li>
<li><p>代码示例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//[]字面量创建数组</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-keyword">var</span> student = [<br>  &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">111</span>, <span class="hljs-attr">name</span>: kygo, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;,<br>  &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">222</span>, <span class="hljs-attr">name</span>: kygo1, <span class="hljs-attr">age</span>: <span class="hljs-number">19</span>&#125;,<br>  &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">333</span>, <span class="hljs-attr">name</span>: kygo2, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>&#125;<br>] <br><span class="hljs-comment">//new创建数组</span><br><span class="hljs-keyword">var</span> arr1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br><span class="hljs-comment">//创建一个长度为5的空数组</span><br><span class="hljs-keyword">var</span> arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-7-2-数组的基本操作"><a href="#2-7-2-数组的基本操作" class="headerlink" title="2.7.2 数组的基本操作"></a>2.7.2 数组的基本操作</h4><ul>
<li><p>基本操作</p>
<ul>
<li><p>访问数组元素：arr[]/arr.at()</p>
<ul>
<li>区别：at可以设置负数，从数组后面往前数</li>
</ul>
</li>
<li><p>修改数组元素：arr[0] = “cth”</p>
</li>
<li><p>删除和添加数组</p>
<ul>
<li>也可以通过索引来操作(开发很少这样做)：delete arr[1]   arr[100]=100</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-comment">//访问数组元素[]/at</span><br><span class="hljs-built_in">console</span>.log(arr[<span class="hljs-number">0</span>])  <span class="hljs-comment">//1</span><br><span class="hljs-built_in">console</span>.log(arr.at(-<span class="hljs-number">1</span>))  <span class="hljs-comment">//3</span><br><span class="hljs-comment">//修改数组元素</span><br>arr[<span class="hljs-number">1</span>] = <span class="hljs-number">100</span><br><span class="hljs-comment">//删除/增加数组元素(这种方式不常用)</span><br><span class="hljs-keyword">delete</span> arr[<span class="hljs-number">2</span>]<br>arr[<span class="hljs-number">5</span>] = <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>数组的添加、删除方法一</p>
<ul>
<li><p>push/pop</p>
<ul>
<li>从数组末端增加、删除元素</li>
</ul>
</li>
<li><p>unshift/shift</p>
<ul>
<li>从数组首端添加、删除元素，整个数组元素向后、前移动</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>添加元素可添加多个，但删除只能一个个删</li>
<li>push/pop方法比unshift/shift效率高很多</li>
<li>增加元素方法会返回增加后数组长度，删除会返回删除的那个元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//数组尾部增加/删除数组元素-push/pop</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br>arr.push(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment">//[3, 2, 1, 0, 1, 2]</span><br><span class="hljs-keyword">var</span> popitem = arr.pop()  <span class="hljs-comment">//[3, 2, 1, 0, 1]</span><br><span class="hljs-built_in">console</span>.log(popitem)  <span class="hljs-comment">//2</span><br><br><br><span class="hljs-comment">//数组首部增加/删除数组元素-unshift/shift</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br>arr.unshift(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment">//[0, 1, 3, 2, 1]</span><br>arr.shift()  <span class="hljs-comment">//[1, 3, 2, 1]</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>数组的添加、删除方法二</strong></p>
<ul>
<li><p>如果想在数组中间某个位置添加、删除元素，就必须使用splice方法了</p>
</li>
<li><p>语法：arr.splice(start[, deleteCount[, item1[, item2[,…]]]])</p>
<ul>
<li>从start位置开始处理数组元素</li>
<li>deleteCount：要删除元素的个数，为0或负数表示不删除</li>
<li>item1,item2,…：需要添加的元素</li>
</ul>
</li>
<li><p>注意：splice方法会修改原数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//数组增删改通用-splice</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-comment">//在数组开头增加6,7两个元素</span><br>arr.splice(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>)<br><span class="hljs-built_in">console</span>.log(arr)  <span class="hljs-comment">//[6,7,1,2,3,4,5]</span><br><span class="hljs-comment">//删除索引为2,3的两个元素</span><br>arr.splice(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br><span class="hljs-built_in">console</span>.log(arr)  <span class="hljs-comment">//[6,7,3,4,5]</span><br><span class="hljs-comment">//修改索引为4的元素值为100</span><br>arr.splice(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>)<br><span class="hljs-built_in">console</span>.log(arr)  <span class="hljs-comment">//[6,7,3,4,100]</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="2-7-3-数组的遍历和length属性"><a href="#2-7-3-数组的遍历和length属性" class="headerlink" title="2.7.3 数组的遍历和length属性"></a>2.7.3 数组的遍历和length属性</h4><ul>
<li><p>length属性</p>
<ul>
<li>作用：获取数组长度，当修改数组时length会自动更新</li>
<li>length是可写的<ul>
<li>如果设置大于默认lenght数值会增加数组长度</li>
<li>设置小于默认length的数值会截断数组</li>
</ul>
</li>
<li>清空数组最简单的方法：arr.length = 0</li>
</ul>
</li>
<li><p>数组的遍历</p>
<ul>
<li><p>普通for循环/for…in/for…of</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//length属性</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br>arr.length = <span class="hljs-number">4</span><br><span class="hljs-built_in">console</span>.log(arr)  <span class="hljs-comment">//扩容: [3,2,1,empty]</span><br>arr.length = <span class="hljs-number">0</span><br><span class="hljs-built_in">console</span>.log(arr)  <span class="hljs-comment">//被截断: [] </span><br><br><span class="hljs-comment">//数组的遍历</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-comment">//1. 普通的for遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>  <span class="hljs-built_in">console</span>.log(arr[i])<br>&#125;<br><span class="hljs-comment">//2. for...in循环</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> index <span class="hljs-keyword">in</span> arr)&#123;<br>  <span class="hljs-built_in">console</span>.log(arr[index])<br>&#125;<br><span class="hljs-comment">//3. for...of循环</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">of</span> arr)&#123;<br>  <span class="hljs-built_in">console</span>.log(item)<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="2-7-4-数组slice-concat-join"><a href="#2-7-4-数组slice-concat-join" class="headerlink" title="2.7.4 数组slice/concat/join"></a>2.7.4 数组slice/concat/join</h4><ul>
<li><p>slice方法</p>
<ul>
<li>截取数组，类似于字符串的slice方法</li>
<li>arr.slice([begin[, end]])  包含begin不包含end</li>
</ul>
</li>
<li><p>concat方法</p>
<ul>
<li>创建一个新数组，其中包含其他数组和其他项</li>
<li>arr.concat(value1[, value2[,…]])  value可以是数组或其他值</li>
</ul>
</li>
<li><p>join方法</p>
<ul>
<li>将一个数组连接成一个字符串并返回</li>
<li>arr.join([separator])</li>
</ul>
</li>
<li><p>toString</p>
<ul>
<li>将数组转化成字符串</li>
<li>arr.toString === arr.join()</li>
</ul>
</li>
<li><p>程序示例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-comment">//slice方法[a, b),不会修改原数组,splice会修改原数组</span><br><span class="hljs-built_in">console</span>.log(arr.slice(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), arr)  <span class="hljs-comment">//[2]</span><br><span class="hljs-comment">//concat方法</span><br><span class="hljs-built_in">console</span>.log(arr.concat(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>]).concat(<span class="hljs-number">8</span>))  <span class="hljs-comment">//[1,2,3...8]</span><br><span class="hljs-comment">//join方法</span><br><span class="hljs-built_in">console</span>.log(arr.join(<span class="hljs-string">&quot;-&quot;</span>))  <span class="hljs-comment">//1-2-3</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-7-5-数组中查找元素"><a href="#2-7-5-数组中查找元素" class="headerlink" title="2.7.5 数组中查找元素"></a>2.7.5 数组中查找元素</h4><ul>
<li><p>arr.indexOf</p>
<ul>
<li>查找某个元素的索引</li>
<li>indexOf(searchElement[, fromIndex])</li>
<li>从formIndex找，没找到返回-1，也有lastIndexOf方法</li>
</ul>
</li>
<li><p>arr.includes</p>
<ul>
<li>判断数组是否包含某个元素</li>
<li>includes(valueToFind[, fromIndex])</li>
<li>从formIndex找，找到返回true，否则false</li>
</ul>
</li>
<li><p>find/findIndex（ES6新增）</p>
<ul>
<li>如果使用indexOf/includes来判断对象数组类型是做不了的，这时就需要find方法了</li>
<li>直接查找元素或元素的索引，高阶函数</li>
</ul>
</li>
<li><p>程序示例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]<br><span class="hljs-comment">//查找方式一: indexOf/lastIndexOf</span><br><span class="hljs-built_in">console</span>.log(arr.indexOf(<span class="hljs-number">7</span>, <span class="hljs-number">1</span>))  <span class="hljs-comment">//-1</span><br><br><span class="hljs-comment">//查找方式二: includes</span><br><span class="hljs-built_in">console</span>.log(arr.includes(<span class="hljs-number">9</span>))<br><br><span class="hljs-keyword">var</span> student = [<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span>, <span class="hljs-attr">id</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;,<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo1&quot;</span>, <span class="hljs-attr">id</span>: <span class="hljs-number">101</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">22</span>&#125;,<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo2&quot;</span>, <span class="hljs-attr">id</span>: <span class="hljs-number">102</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">60</span>&#125;<br>]<br><span class="hljs-comment">//查找方式三: find/findIndex</span><br><span class="hljs-comment">//findIndex和find完全相同,只是返回找到元素的索引</span><br><span class="hljs-keyword">var</span> findItem = student.find(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> item.age === <span class="hljs-number">22</span><br>&#125;)<br><span class="hljs-built_in">console</span>.log(findItem)  <span class="hljs-comment">//&#123;name: &#x27;kygo1&#x27;, id: 101, age: 2&#125;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-7-6-手动实现高阶函数"><a href="#2-7-6-手动实现高阶函数" class="headerlink" title="2.7.6 手动实现高阶函数"></a>2.7.6 手动实现高阶函数</h4><ul>
<li><p>forEach函数的实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 手动实现forEach高阶函数</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">2</span>, <span class="hljs-number">12</span>, <span class="hljs-number">32</span>]<br><span class="hljs-comment">// 版本一</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">kyForEach</span>(<span class="hljs-params">fn</span>)</span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    fn(arr[i], i, arr)<br>  &#125;<br>&#125;<br>kyForEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, arr</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(item, index, arr)<br>&#125;)<br><span class="hljs-comment">// 版本二: 传入数组arr作为参数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">kyForEach</span>(<span class="hljs-params">fn, arr</span>)</span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    fn(arr[i], i, arr)<br>  &#125;<br>&#125;<br>kyForEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, arr</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(item, index, arr)<br>&#125;, arr)<br><span class="hljs-comment">// 版本三: 将函数加到arr对象上</span><br><span class="hljs-comment">// 缺点: 函数不通用,并且打印的arr种有kyForEach</span><br>arr.kyForEach = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>)</span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;<br>    fn(arr[i], i, <span class="hljs-built_in">this</span>)<br>  &#125;<br>&#125;<br>arr.kyForEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, arr</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(item, index, arr)<br>&#125;)<br><br><span class="hljs-comment">//终极版本: 将方法绑定到Array.prototype上</span><br><span class="hljs-built_in">Array</span>.prototype.kyForEach = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>)</span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;<br>    fn(arr[i], i, <span class="hljs-built_in">this</span>)<br>  &#125;<br>&#125;<br><span class="hljs-comment">//所有数组都可调用,和原生forEach方法一模一样</span><br>arr.kyForEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, arr</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(item, index, arr)<br>&#125;)<br></code></pre></td></tr></table></figure></li>
<li><p>find函数的实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> student = [<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span>, <span class="hljs-attr">id</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;,<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo1&quot;</span>, <span class="hljs-attr">id</span>: <span class="hljs-number">101</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">22</span>&#125;,<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo2&quot;</span>, <span class="hljs-attr">id</span>: <span class="hljs-number">102</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">60</span>&#125;<br>]<br><br><span class="hljs-comment">// 手动实现find高阶函数</span><br><span class="hljs-built_in">Array</span>.prototype.kyFind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;<br>    <span class="hljs-keyword">if</span>(fn(<span class="hljs-built_in">this</span>[i], i, <span class="hljs-built_in">this</span>)) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>[i]<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> result = arr.find(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> item === <span class="hljs-number">2</span><br>&#125;)<br><span class="hljs-keyword">var</span> result1 = student.find(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> item.id === <span class="hljs-number">101</span><br>&#125;)<br><span class="hljs-built_in">console</span>.log(result) <span class="hljs-comment">//2</span><br><span class="hljs-built_in">console</span>.log(result1)  <span class="hljs-comment">//&#123;name: &#x27;kygo1&#x27;, id: 101, age:22&#125;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-7-7-数组的排序和反转"><a href="#2-7-7-数组的排序和反转" class="headerlink" title="2.7.7 数组的排序和反转"></a>2.7.7 数组的排序和反转</h4><ul>
<li><p>sort方法</p>
<ul>
<li>数组排序，返回排序后的新数组</li>
<li>sort([compareFunction])</li>
<li>规则：如果compareFunction(a, b)&gt;0，则a排在b后面，等于0顺序不变，小于0，a排b前面</li>
</ul>
</li>
<li><p>reverse方法</p>
<ul>
<li>反转数组元素并返回</li>
</ul>
</li>
<li><p>程序示例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//数组排序</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">12</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">34</span>, <span class="hljs-number">21</span>, <span class="hljs-number">213</span>, <span class="hljs-number">78</span>]<br><span class="hljs-comment">//a - b &gt; 0 a排在b后面,所以是升序排列</span><br><span class="hljs-keyword">var</span> newArr = arr.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a - b<br>&#125;)<br><span class="hljs-built_in">console</span>.log(arr === newArr)  <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(arr)  <span class="hljs-comment">//[1,12,21,34...]</span><br><br><span class="hljs-comment">//数组反转</span><br>arr.reverse()<br><span class="hljs-built_in">console</span>.log(arr)  <span class="hljs-comment">//[213,100,78,34...]</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-7-8-其他高阶函数的使用"><a href="#2-7-8-其他高阶函数的使用" class="headerlink" title="2.7.8 其他高阶函数的使用"></a>2.7.8 其他高阶函数的使用</h4><ul>
<li><p>arr.forEach</p>
<ul>
<li>遍历数组，让数组中的每个元素都执行一次对应方法</li>
</ul>
</li>
<li><p>arr.map</p>
<ul>
<li>创建一个新数组</li>
<li>这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成</li>
</ul>
</li>
<li><p>arr.filter</p>
<ul>
<li>创建一个新数组</li>
<li>新数组中只包含每个元素调用函数返回为true的元素</li>
</ul>
</li>
<li><p>arr.reduce</p>
<ul>
<li>用于计算数组中所有元素的总和</li>
<li>对数组中的每个元素按序执行一个由您提供的 reducer 函数</li>
<li>每一次运行 reducer 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值</li>
</ul>
</li>
<li><p>程序示例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-comment">//forEach方法: item等参数可按需求写</span><br><span class="hljs-comment">//this绑定的是window,可以传入第二个参数作为this绑定的对象</span><br>arr.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, arr</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(item, <span class="hljs-built_in">this</span>) <span class="hljs-comment">//1 &#123;name: &quot;kygo&quot;&#125;...</span><br>&#125;, &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span>&#125;)<br><br><span class="hljs-comment">//map: 数组映射</span><br><span class="hljs-keyword">var</span> newArr1 = arr.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> item * item<br>&#125;)<br><span class="hljs-built_in">console</span>.log(newArr1)  <span class="hljs-comment">//[1, 4, 9, 16]</span><br><br><span class="hljs-comment">//filter: 数组筛选</span><br><span class="hljs-keyword">var</span> newArr2 = arr.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> item % <span class="hljs-number">2</span> ===<span class="hljs-number">0</span>  <br>&#125;)<br><span class="hljs-built_in">console</span>.log(newArr2)  <span class="hljs-comment">//[2, 4]</span><br><br><span class="hljs-comment">//reduce(fun[, initial]): 求和,initial表示初始值</span><br><span class="hljs-comment">//pre-上次求和的值</span><br><span class="hljs-comment">//item-当前元素  index-当前索引</span><br><span class="hljs-comment">//注意: 不写初始值,默认初始值是第一个元素,index从1开始(第二个元素)累加</span><br><span class="hljs-keyword">var</span> result = arr.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pre, item, index</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> pre + item<br>&#125;, <span class="hljs-number">100</span>)<br><span class="hljs-built_in">console</span>.log(result) <span class="hljs-comment">//10</span><br><br><span class="hljs-comment">//综合练习: 过滤所有偶数,映射所有偶数的平方,并且计算他们的和</span><br><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">2</span>, <span class="hljs-number">11</span>, <span class="hljs-number">32</span>, <span class="hljs-number">47</span>, <span class="hljs-number">110</span>, <span class="hljs-number">231</span>]<br><span class="hljs-comment">//以下为链式写法</span><br><span class="hljs-keyword">var</span> res = arr1.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> item % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> <br>&#125;).map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> item * item<br>&#125;).reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">preValue, item</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> preValue + item<br>&#125;)<br><span class="hljs-built_in">console</span>.log(res)<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-8-ES6类和对象"><a href="#2-8-ES6类和对象" class="headerlink" title="2.8 ES6类和对象"></a>2.8 ES6类和对象</h3><p>ES6开始，提供class关键字定义类</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;cth&quot;</span>;age=<span class="hljs-number">21</span>;<span class="hljs-function"><span class="hljs-title">say</span>(<span class="hljs-params"></span>)</span>&#123;...&#125;;  <span class="hljs-comment">//直接添加实例属性和方法即可，不用加this</span><br>    <span class="hljs-keyword">static</span> num=<span class="hljs-number">666</span>;  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span>&#123;...&#125;; <span class="hljs-comment">//静态属性和方法, 通过类名调用</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">myname,myage</span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=myname....     <br>	&#125;<br>&#125;<br><span class="hljs-comment">//当创建对象时,自动调用constructor()&#123;&#125;构造方法</span><br><span class="hljs-keyword">let</span> per=<span class="hljs-keyword">new</span> Person(“cth”,<span class="hljs-number">21</span>)  <br></code></pre></td></tr></table></figure>

<p>注意点：直接添加实例属性，大部分浏览器不支持</p>
<p>​                在ES6标准中添加实例属性需要在constructor中添加</p>
<p>​                静态属性大部分浏览器不支持static定义(类名.属性定义)</p>
<p>​                支持static定义静态方法</p>
<p>在class中直接添加的方法会添加到对象的原型中</p>
<p>如果想在class上添加方法，必须也写到constructor中</p>
<p>总结：class写在constructor中的方法都会保存在当前对象中</p>
<p>写在constructor外面的方法都会保存在原型对象</p>
<p>(ES6之前有两种给原型添加属性/方法-动态添加或自定义对象添加)</p>
<p>通过class定义类，当往原型中添加属性和方法时</p>
<p>不能自定义原型对象添加，只能动态的给原型添加属性和方法</p>
<p><strong>ES6继承</strong></p>
<p>​    extends 关键字  super(参数) 通过super调用父类构造函数并传递参数</p>
<p><strong>获取对象类型</strong></p>
<p>​    想知道对象通过什么构造函数创建的，一个对象的真实类型</p>
<p>​    通过 对象.constructor.name  获取构造函数名称</p>
<ul>
<li><strong>instanceof</strong> 关键字</li>
</ul>
<p>​    用于判断”对象”是否是指定构造函数(类)的“实例”</p>
<p>​     per instanceof person  //判断per是否是person实例</p>
<p>​     注意：只要构造函数的原型对象出现在实例对象的原型链中都会返回true</p>
<p>​     (所有对象都是Object的实例)</p>
<ul>
<li>isPrototypeOf属性</li>
</ul>
<p>​    用于判断一个对象是否是另一个对象的原型</p>
<p>​     Person.prototype.isPrototypeOf(p);  //返回true，是p的原型对象</p>
<p>​     注意点：只要原型对象是在实例对象的原型链中的，都会返回true</p>
<ul>
<li><p>in 判断对象属性</p>
<p> “name” in per  //判断per对象类中或其原型中是否有name属性</p>
</li>
</ul>
<p>​           只要有就会返回true</p>
<p>   per.hasOwnProperty(“name”);  //只会在对象中查找，不会去查找原型</p>
<p>-2021.4.4  </p>
<ul>
<li>对象增删改查</li>
</ul>
<p>​    可以通过[“”]来操作属性和方法</p>
<p>增：p.name=”cth” p[“name”]=”cth”</p>
<p>​      p.say=function(){…}  p[“say”]=function(){…}</p>
<p>​    删：delete p.name;  delete p[“name”];  delete p.say;  delete p[“say”];</p>
<p>​    改：p.name / p[“name”]=”wcr”  p.say/p[“say”]=function(){} </p>
<p>​    查：就是调用属性和方法 p.name/p[“name”]  p.say()/p<a href="">“say”</a></p>
<ul>
<li>对象的遍历</li>
</ul>
<p>就是依次取出对象中所有的属性和方法</p>
<p>​    for(let key in obj){}  //将对象所有属性方法取出赋值给key这个变量</p>
<p>​    通过obj[key]取出 不能通过obj.key</p>
<ul>
<li>对象解构赋值</li>
</ul>
<p>对象结构赋值- {}</p>
<p>​     obj={name: “cth” , age=21};</p>
<p>​     let {name,age}=obj;  //除了{}和数组[]不一样,也可使用…</p>
<p>​     不同：左边的变量名称必须和对象属性名称一致才能解构出来</p>
<p>​     应用场景：可以直接将对象和数组通过实参传给函数</p>
<p>​          在形参处用结构赋值接收</p>
<p>​     let obj={name: “cth”,age=21}  </p>
<p>​     function say({name,age}){console.log(name,age)}  say(obj);</p>
<ul>
<li>深拷贝和浅拷贝</li>
</ul>
<p>深拷贝-修改新变量的值不会影响原变量值-基本数据类型都是(栈内存)</p>
<p>浅拷贝-修改新变量值会影响原来值-引用类型都是浅拷贝(堆内存)</p>
<p>对象的深拷贝：</p>
<p>Object.assign(p2,p1);  //将p1对象的属性和方法拷贝到对象p2中</p>
<p>当p1对象中有引用类型时，以上方法将不能实现深拷贝</p>
<p>自定义深拷贝函数实现</p>
<ul>
<li>this总结</li>
</ul>
<p>*以函数形式调用时，this永远都是window</p>
<p>*以方法的形式调用时，this是调用方法的对象</p>
<p>*以构造函数的形式调用时，this是新创建的对象</p>
<p>*使用call和apply调用时，this是指定的那个对象</p>
<h3 id="2-9-其他"><a href="#2-9-其他" class="headerlink" title="2.9 其他"></a>2.9 其他</h3><h4 id="2-9-1-数组高级API"><a href="#2-9-1-数组高级API" class="headerlink" title="2.9.1 数组高级API"></a>2.9.1 数组高级API</h4><p>​    ****遍历数组****：传统方法、for-in循环(数组也是对象)</p>
<p>​          for(let key in arr){arr[key];}</p>
<p>​    不推荐for-in遍历数组，因为其是专门遍历对象的(对象属性无序)</p>
<p>​    推荐利用ES6中的 for-of 循环来遍历数组</p>
<p>​       for(let value of arr){console.log(value)};</p>
<p>​    还可以使用Array对象的forEach方法来遍历数组</p>
<p>​       arr.forEach(function(currentValue,currentIndex,currentArray){…})</p>
<p>​       传入一个函数，自动传入参数：数组值，索引，当前数组</p>
<p>​    <em><strong>*数组查找*</strong></em></p>
<p>​      findIndex方法：定制版的indexOf，找到返回索引，找不到返回-1</p>
<p>​             arr.findIndex(function(,,){}) //传入一个函数，三个参数</p>
<p>​      find方法：find方法返回找到的元素(也接收三个参数)</p>
<p>​      (注意：判断特定筛选条件时/return true;)</p>
<p>​    <em><strong>*数组过滤和数组映射*</strong></em></p>
<p>​      filter方法：将满足条件的元素添加到一个新数组中</p>
<p>​           (例: if(value%2){return true} 返回数组-所有偶数封装的)</p>
<p>​      map方法：</p>
<p>​           将满足条件的元素映射到一个新的数组中</p>
<p>​           (映射：创建一个相同大小的数组,将所有元素值设置undefined</p>
<p>​           满足条件的元素将undefined覆盖,不满足的还是undefined)</p>
<p>​      注意:方法都是传递一个函数为参数，且这个函数传递三个参数value/index/arr</p>
<p>​                                   -2021.4.5</p>
<p>​    <em><strong>*数组排序*</strong></em></p>
<p>​    arr.sort();  //接收一个函数，函数又可以接收两个参数</p>
<p>​        arr.sort(function(a,b){  //默认升序</p>
<p>  if(a&gt;b){return 1}  //return -1 就是降序</p>
<p>  else if(a&lt;b){return -1;}  //return 1就是降序</p>
<p>  else{return 0;}  //这个不用变</p>
<p>})</p>
<p>​        规律：如果数组是字母可以以上方法</p>
<p>​           如果是数值类型，那么升序返回a-b,降序返回b-a</p>
<p>​           arr.sort(function(a,b){return a-b})  //升序，b-a降序</p>
<p>​           对字符串长短进行排序：如 [“qwe”,”a”,”qwer”…]</p>
<p>​           arr.sort(function(str1,str2){return str1.length-str2.length})</p>
<p>​           //以上是升序，降序相反  (字符串相当于一个数组可以length) </p>
<h4 id="2-9-2-字符串常用方法"><a href="#2-9-2-字符串常用方法" class="headerlink" title="2.9.2 字符串常用方法"></a>2.9.2 字符串常用方法</h4><p>在底层字符串是以字符数组的形式保存的  如 [‘h’,’e’,’l’,’l’,’o’]</p>
<p>可以像操作数组一样str[index]，也可以使用数组的大部分方法</p>
<p>​    *获取字符串长度  str.length</p>
<p>​    *获取某个字符   str[index]  str.charAt(index) </p>
<p>​       区别：str[] 只有高级浏览器才支持，而charAt()没有兼容性问题</p>
<p>​    *字符串查找  indexOf / lastIndexOf / includes</p>
<p>​       和数组一样，但要加” ”  如：str.indexOf(“c”) //检查字符”c”</p>
<p>​    *字符串的拼接 concat / +</p>
<p>​       str1 + str2  str1.concat(str2)  //推荐使用+</p>
<p>​    *获取子串  slice / substring / substr</p>
<p>​       substring(a,b)和slice()功能一样，包前不包后，推荐substring()</p>
<p>​       substr(a,b)  //从索引为a开始，截取b个字符</p>
<p>   Other</p>
<p>​     *字符串切割</p>
<p>​       str.split(“-”)  //利用-来切割字符串，和arr.join(“-”);相反</p>
<p>​     *判断是否以指定字符串开头ES6</p>
<p>​       str.startsWith(“www”); //判断是否以”www”开头</p>
<p>​     *判断是否以指定字符串结尾ES6  str.endsWith(“”);</p>
<p>​     *字符串模板ES6</p>
<p>​       let str=<code>;  //除了”” ‘’ 定义字符串，还可以</code></p>
<p>​       作用：当html代码需要保存在字符串中，用``不用+拼接</p>
<p>​          console.log(“我的名字”+cth+”,年龄”+age);</p>
<p>​         =&gt;console.log(<code>我的名字$&#123;cth&#125;,年龄$&#123;age&#125;</code>);  </p>
<p>​            2021.4.6</p>
<h4 id="2-9-3-基本包装类型"><a href="#2-9-3-基本包装类型" class="headerlink" title="2.9.3 基本包装类型"></a>2.9.3 基本包装类型</h4><p>​    基本数据类型变量 没有属性和方法</p>
<p>​    对象类型 有属性和方法</p>
<p>​       能访问基本数据类型的属性和方法，因为运行时系统将其包装为对象类型</p>
<p>​       String() Number() Boolean()</p>
<h4 id="2-9-4-三大对象"><a href="#2-9-4-三大对象" class="headerlink" title="2.9.4 三大对象"></a>2.9.4 三大对象</h4><p>​    JS提供的三种自带对象：本地对象/内置对象/宿主对象</p>
<p>​    宿主：JS运行环境</p>
<p>​       本地对象：与宿主无关，ES标准定义的类(构造函数)</p>
<p>​            使用时需手动new创建</p>
<p>​            如：Boolean Number String Array Function Object Date RegExp等</p>
<p>​       内置对象：与宿主无关，ES已经帮我们创建好的对象</p>
<p>​            无需手动new  如：Global(全局对象不用关注) Math JSON</p>
<p>​       宿主对象：浏览器提供的对象</p>
<p>​            Window Document等</p>
<p>​            所有BOM和DOM都属于宿主对象</p>
<h2 id="3-JS代码规范和浏览器调试技巧"><a href="#3-JS代码规范和浏览器调试技巧" class="headerlink" title="3. JS代码规范和浏览器调试技巧"></a>3. JS代码规范和浏览器调试技巧</h2><h3 id="3-1-代码规范"><a href="#3-1-代码规范" class="headerlink" title="3.1 代码规范"></a>3.1 代码规范</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pow</span>(<span class="hljs-params">x, n</span>) </span>&#123;  <span class="hljs-comment">//1. 多个参数,后面留空格 开花括号&#123;不单独起一行且前面留空</span><br>  <span class="hljs-keyword">var</span> result = <span class="hljs-number">1</span>  <span class="hljs-comment">//2. 操作符左右两边留空格</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;  <span class="hljs-comment">//3. 循环语句;后面留空格</span><br>    result *= x  <span class="hljs-comment">//4. 代码缩进两个空格</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> result;  <span class="hljs-comment">//5. 分号可加可不加,但是在必要时必须加,如立即执行函数前面</span><br>&#125;<br><br><span class="hljs-keyword">var</span> x = prompt(<span class="hljs-string">&quot;请输入x&quot;</span>)  <span class="hljs-comment">//6. 不同功能代码块之间空行</span><br><span class="hljs-keyword">var</span> n = prompt(<span class="hljs-string">&quot;请输入n&quot;</span>)<br><br><span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//7. for/if/while后面跟空格</span><br>  <span class="hljs-built_in">console</span>.log(pow(x, n))  <span class="hljs-comment">//8. 函数多个参数传参,后面跟空格</span><br>&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">//9. &quot;&#125; else &#123;&quot; 在同一行显示</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`pow函数不支持小于0的数,你输入的n小于0,</span><br><span class="hljs-string">  请输入大于等于0的数`</span>)  <span class="hljs-comment">//10. 一行不能太长</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-2-浏览器调试技巧"><a href="#3-2-浏览器调试技巧" class="headerlink" title="3.2 浏览器调试技巧"></a>3.2 浏览器调试技巧</h3><ul>
<li><p>debug的认识</p>
<ul>
<li>终极技巧：debug</li>
<li>当代码出问题的时候，可以通过debug找出bug</li>
<li>浏览器实现debug就是打断点</li>
</ul>
</li>
<li><p>浏览器的debug</p>
<ul>
<li><p>debug过程解析</p>
<p><img src="../../public/img/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E4%B8%80.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>右侧工具栏的作用</p>
<p><img src="../../public/img/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E4%BA%8C.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>右下侧工具栏</p>
<p><img src="../../public/img/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E4%B8%89.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
</li>
<li><p>代码中的debugger</p>
<ul>
<li><p>代码中写上debugger和浏览器中打断点效果是一样的，程序都会停在那个地方</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;循环前&quot;</span>)<br><span class="hljs-keyword">var</span> result = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">debugger</span>  <span class="hljs-comment">//debugger标识符就是在代码中打断点的方式</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;foo执行啦&quot;</span>)<br>&#125;<br>foo()<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="4-DOM"><a href="#4-DOM" class="headerlink" title="4. DOM"></a>4. DOM</h2><h3 id="4-1-认识DOM"><a href="#4-1-认识DOM" class="headerlink" title="4.1 认识DOM"></a>4.1 认识DOM</h3><h4 id="4-1-1-认识DOM和BOM"><a href="#4-1-1-认识DOM和BOM" class="headerlink" title="4.1.1 认识DOM和BOM"></a>4.1.1 认识DOM和BOM</h4><ul>
<li>作用<ul>
<li>前面学习的ECMAScript是JS的基本语法部分，不涉及对网页和浏览器的操作</li>
<li>DOM和BOM是浏览器提供给开发者去操作页面和浏览器的API</li>
</ul>
</li>
<li>位置：全局Window对象中除了Array、Date等，还有DOM和BOM</li>
<li>概念<ul>
<li>DOM<ul>
<li>文档对象模型（Document Object Model），简称DOM</li>
<li>将页面所有的内容表示成可以修改的对象</li>
</ul>
</li>
<li>BOM<ul>
<li>浏览器对象模型（Browser Object Model）</li>
<li>用于处理文档之外的所有其他内容的对象，如：navigator、location、history</li>
</ul>
</li>
</ul>
</li>
<li>深入理解DOM<ul>
<li>浏览器考虑到我们会通过js操作页面的元素，所以将所有的元素抽象成了对象</li>
<li>整个文档被抽象到Document对象中 （如：通过Document.head/body就可拿到head/body元素）</li>
<li>所以学习DOM，就是学习怎样通过JS对文档进行操作</li>
</ul>
</li>
</ul>
<h4 id="4-1-2-DOM-Tree"><a href="#4-1-2-DOM-Tree" class="headerlink" title="4.1.2 DOM Tree"></a>4.1.2 DOM Tree</h4><ul>
<li>html结构中最终会形成一个树结构</li>
<li>在抽象成DOM对象的时候也会形成一个树结构-DOM Tree</li>
</ul>
<h4 id="4-1-3-DOM的学习顺序"><a href="#4-1-3-DOM的学习顺序" class="headerlink" title="4.1.3 DOM的学习顺序"></a>4.1.3 DOM的学习顺序</h4><ul>
<li>DOM的API非常多，会按照如下顺序学习<ul>
<li>DOM元素之间的关系</li>
<li>获取DOM元素</li>
<li>DOM节点的type、tag、content</li>
<li>DOM节点的attributes、properies</li>
<li>DOM元素的创建、插入、克隆、删除</li>
<li>DOM节点的样式、类</li>
<li>DOM元素/Window的大小、滚动、坐标</li>
</ul>
</li>
</ul>
<h4 id="4-1-4-DOM的继承关系"><a href="#4-1-4-DOM的继承关系" class="headerlink" title="4.1.4 DOM的继承关系"></a>4.1.4 DOM的继承关系</h4><ul>
<li><p>DOM相当于是JavaScript和HTML/CSS之间沟通的桥梁</p>
<ul>
<li>通过浏览器提供的DOM API，可以对元素及其内容做任何操作</li>
</ul>
</li>
<li><p>DOM的继承关系图</p>
<p><img src="../../public/img/DOM%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<h4 id="4-1-5-document对象"><a href="#4-1-5-document对象" class="headerlink" title="4.1.5 document对象"></a>4.1.5 document对象</h4><ul>
<li><p>Document节点表示整个载入的网页，它的实例是全局的document对象</p>
<ul>
<li>对DOM的所有操作都是从document对象开始的</li>
<li>它是DOM的入口点，可以从document开始去访问任何节点元素</li>
</ul>
</li>
<li><p>对于最顶层的html、head、body元素，我们可以直接在document对象中获取到</p>
<ul>
<li><p>html元素 - document.documentElement</p>
</li>
<li><p>body/head元素 - document.body/head</p>
</li>
<li><p>文档声明 - document.doctype</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> htmlEl = <span class="hljs-built_in">document</span>.documentElement<br><span class="hljs-keyword">var</span> headEl = <span class="hljs-built_in">document</span>.head<br><span class="hljs-keyword">var</span> bodyEl = <span class="hljs-built_in">document</span>.body<br><span class="hljs-keyword">var</span> docEl = <span class="hljs-built_in">document</span>.doctype<br><span class="hljs-built_in">console</span>.log(htmlEl, headEl, bodyEl, docEl)  <span class="hljs-comment">//html/head/body/docType</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="4-2-导航"><a href="#4-2-导航" class="headerlink" title="4.2 导航"></a>4.2 导航</h3><h4 id="4-2-1-节点之间的导航"><a href="#4-2-1-节点之间的导航" class="headerlink" title="4.2.1 节点之间的导航"></a>4.2.1 节点之间的导航</h4><ul>
<li>什么是节点之间的导航<ul>
<li>当获取到一个节点后，根据这个节点获取其他的结点</li>
<li>注意：结点包括元素、注释、空行、文本等都属于节点</li>
</ul>
</li>
<li>节点之间存在的关系<ul>
<li>父节点：parentNode</li>
<li>前兄弟节点：previousSibling</li>
<li>后兄弟节点：nextSibing</li>
<li>子节点：childNodes</li>
<li>第一个子节点：firstChild</li>
<li>最后一个子节点：lastChild</li>
</ul>
</li>
<li>代码示例</li>
</ul>
<h4 id="4-2-2-元素之间的导航"><a href="#4-2-2-元素之间的导航" class="headerlink" title="4.2.2 元素之间的导航"></a>4.2.2 元素之间的导航</h4><ul>
<li>什么是元素之间的导航<ul>
<li>同理，通过一个元素获取到其他元素</li>
</ul>
</li>
<li>元素之间存在的关系<ul>
<li>父元素：parentElement</li>
<li>前兄弟节点：previousElementSibling</li>
<li>后兄弟节点：nextElementSibing</li>
<li>子节点：children</li>
<li>第一个子节点：firstElementChild</li>
<li>最后一个子节点：lastElementChild</li>
</ul>
</li>
<li>代码示例</li>
</ul>
<h4 id="4-2-3-table元素之间的导航"><a href="#4-2-3-table元素之间的导航" class="headerlink" title="4.2.3 table元素之间的导航"></a>4.2.3 table元素之间的导航</h4><ul>
<li>table元素支持以下属性（除了上面给出的）<ul>
<li>table.rows    tr元素集合</li>
<li>table.caption/tHead/tBodies/tFoot    </li>
</ul>
</li>
<li>thead/tbody/tfoot元素提供了rows属性<ul>
<li>tbody.rows</li>
</ul>
</li>
<li>tr元素<ul>
<li>tr.cells    给定的tr中td和th的集合</li>
<li>tr.sectionRowIndex/tr.rowIndex    tr在thead/tbody/tfoot中的位置、整个表格中的位置</li>
</ul>
</li>
<li>td和th元素<ul>
<li>td.cellIndex    封闭的tr中单元格的编号</li>
</ul>
</li>
</ul>
<h4 id="4-2-4-form元素之间的导航"><a href="#4-2-4-form元素之间的导航" class="headerlink" title="4.2.4 form元素之间的导航"></a>4.2.4 form元素之间的导航</h4><ul>
<li>form元素可通过ducument来获取：document.forms</li>
<li>form元素中的内容可通过elements来获取：form.elements</li>
<li>可以通过表单子元素的name属性来获取：elements.password</li>
<li>代码示例</li>
<li></li>
</ul>
<h3 id="4-3-获取任意元素的方法"><a href="#4-3-获取任意元素的方法" class="headerlink" title="4.3 获取任意元素的方法"></a>4.3 获取任意元素的方法</h3><ul>
<li>DOM导航属性只适用于元素之间相邻或相近时（层级太多写起来不方便）</li>
<li>DOM为我们提供了以下可以任意获取元素的方法<ul>
<li>querySelector/querySeletorAll<ul>
<li>通过选择器查找元素，开发最常用</li>
</ul>
</li>
<li>getElementById/getElementsByClassName<ul>
<li>通过id/class查找元素，有时候用（适配低版本浏览器）</li>
</ul>
</li>
<li>getElementsByName/getElementsByTagName<ul>
<li>通过name属性、标签名获取（用得很少，了解）</li>
</ul>
</li>
</ul>
</li>
<li>是否能在元素上使用，是否实时（了解）<ul>
<li>query、ByClass、TagName可以在元素上使用<ul>
<li>可以通过元素.的方法调用，在其子元素中查询</li>
</ul>
</li>
<li>ByName、ByTagName、ByClassName支持实时更新<ul>
<li>元素属性先输出，再修改，也会输出最新的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-4-node节点常见属性"><a href="#4-4-node节点常见属性" class="headerlink" title="4.4 node节点常见属性"></a>4.4 node节点常见属性</h3><ul>
<li><p>主要讨论节点共有的属性</p>
</li>
<li><p>nodeType属性</p>
<ul>
<li>作用：获取节点的类型，返回的是数值类型</li>
<li>常见结点类型<ul>
<li>Node.ELEMENT_NODE  1  元素节点</li>
<li>Node.TEXT_NODE  3  文本节点</li>
<li>Node.COMMENT_NODE  8  注释节点</li>
<li>Node.DOCUMENT_NODE  9  文档节点</li>
<li>Node.DOCUMENT_TYPE_NODE  10  文档类型节点</li>
</ul>
</li>
</ul>
</li>
<li><p>nodeName、tagName属性</p>
<ul>
<li>作用：用于获取node节点的名字，元素的标签名</li>
<li>不同<ul>
<li>tagName只适用于Element节点</li>
<li>nodeName使用于任意节点</li>
</ul>
</li>
</ul>
</li>
<li><p>innerHTML、textContent属性</p>
<ul>
<li>innerHTML属性<ul>
<li>可以获取元素中的所有内容，包括HTML，以字符串形式返回</li>
<li>可以设置元素的内容（如果有HTML会解析）</li>
</ul>
</li>
<li>textContent属性<ul>
<li>仅仅获取元素中的文本内容</li>
</ul>
</li>
<li>outerHTML属性<ul>
<li>包含了元素本身的完整HTML</li>
</ul>
</li>
</ul>
</li>
<li><p>data/nodeValue</p>
<ul>
<li>用于获取非元素节点的文本内容（如：注释、文本）</li>
</ul>
</li>
<li><p>其他属性</p>
<ul>
<li>hidden属性：全局属性，设置元素的显示隐藏</li>
<li>value（表单元素）、href（a）、id（所有元素的attribute值）</li>
</ul>
</li>
</ul>
<h3 id="4-5-元素"><a href="#4-5-元素" class="headerlink" title="4.5 元素"></a>4.5 元素</h3><ul>
<li>元素的属性和特征<ul>
<li>一个元素除了有开始标签、结束标签、内容，还有很多的属性（attribute）</li>
<li>浏览器在解析HTML元素时，会将对应的attribute也创建出来放到元素上<ul>
<li>如id、class就是全局的attribute，有对应的id、class属性</li>
<li>href属性是针对于a元素的，value和type是针对于input元素的</li>
</ul>
</li>
<li>属性和特征的区分<ul>
<li>通常我们将html元素上加的属性叫做特征-attribute</li>
<li>在元素对象中封装的属性叫做-property</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-5-1-元素的特征attribute"><a href="#4-5-1-元素的特征attribute" class="headerlink" title="4.5.1 元素的特征attribute"></a>4.5.1 元素的特征attribute</h4><ul>
<li>分类<ul>
<li>标准attribute<ul>
<li>原本存在的浏览器提供的元素attribute，如：id、class、style</li>
</ul>
</li>
<li>非标准attribute<ul>
<li>自定义的attribute，如age、height</li>
</ul>
</li>
</ul>
</li>
<li>attribute的操作<ul>
<li>elem.hasAttribute(name)  检查特征是否存在</li>
<li>elem.getAttribute(name)  获取特征值</li>
<li>elem.setAttribute(name, value)  设置特征值</li>
<li>elem.removeAttribute(name)  移除特征</li>
<li>attributes  attr对象的集合，具有name、value属性</li>
</ul>
</li>
<li>attribute特征<ul>
<li>名字的大小写不敏感（id和ID获取是一样的）</li>
<li>获取到的值总是字符串类型（如checked获取到的是空字符串）</li>
</ul>
</li>
</ul>
<h4 id="4-5-2-元素的属性property"><a href="#4-5-2-元素的属性property" class="headerlink" title="4.5.2 元素的属性property"></a>4.5.2 元素的属性property</h4><ul>
<li>对于标准的attribute，会在DOM对象上创建对应的property属性</li>
<li>attribute和property相互作用<ul>
<li>改变property，通过attribute获取到的值也会改变</li>
<li>通过attribute修改，property的值也会改变</li>
</ul>
</li>
<li>推荐使用property来获取元素的attribute<ul>
<li>因为通过property获取的值是有类型的，而attribute获取的都是字符串</li>
</ul>
</li>
<li>自定义属性data的获取<ul>
<li>html中可以通过data-*自定义属性，这些attribute可以通过dataset属性获取到</li>
</ul>
</li>
</ul>
<h4 id="4-5-3-元素的class和style"><a href="#4-5-3-元素的class和style" class="headerlink" title="4.5.3 元素的class和style"></a>4.5.3 元素的class和style</h4><ul>
<li>JavaScript动态修改样式<ul>
<li>方法一：在css中写好样式，动态添加class</li>
<li>方法二：动态修改style属性</li>
<li>方法的选择<ul>
<li>大多数情况下，更推荐使用动态的class</li>
<li>某些情况不能动态修改class（如精准修改某个css属性值），就可以修改style属性</li>
</ul>
</li>
</ul>
</li>
<li>元素的className和classList<ul>
<li>元素的className<ul>
<li>元素的class attribute，对应的property叫做className，而不是class（class是关键字）</li>
<li>可以对className赋值，它会替换整个class中的字符串</li>
</ul>
</li>
<li>元素的classList<ul>
<li>当需要添加或移除单个的class，可以使用classList属性</li>
<li>elem.classList是特殊的对象<ul>
<li>elem.classList.add(class)  添加一个类</li>
<li>elem.classList.remove(class)  移除类</li>
<li>elem.classList.toggle(class)  不存在添加，存在移除类</li>
<li>elem.classList.contains(class)  检查类，返回true/false</li>
</ul>
</li>
<li>classList是可迭代对象，可以通过for…of遍历</li>
</ul>
</li>
</ul>
</li>
<li>元素的style属性<ul>
<li>单独修改某一个css属性，可以通过style来操作</li>
<li>多个样式的写法，需要使用cssText属性（不推荐）</li>
<li>注意<ul>
<li>对于多词属性，使用驼峰：boxEl.style.backgroundColor = “red”</li>
<li>如果将值设置为空字符串，会使用默认的css样式（如：boxEl.style.display=””）</li>
</ul>
</li>
</ul>
</li>
<li>元素style的读取<ul>
<li>对于内联样式，可以通过style.*的方式读取到</li>
<li>对于style标签、css文件中的样式是读取不到的<ul>
<li>可以通过getComputedStyle的全局函数来读取：getComputedStyle(“boxEl”).width</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-5-4-元素的常见操作"><a href="#4-5-4-元素的常见操作" class="headerlink" title="4.5.4 元素的常见操作"></a>4.5.4 元素的常见操作</h4><h4 id="4-5-5-元素的大小和滚动"><a href="#4-5-5-元素的大小和滚动" class="headerlink" title="4.5.5 元素的大小和滚动"></a>4.5.5 元素的大小和滚动</h4><h3 id="window的大小和滚动"><a href="#window的大小和滚动" class="headerlink" title="window的大小和滚动"></a>window的大小和滚动</h3><h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h3><p>​    属于宿主对象,包含了window和document  (浏览器提供)</p>
<p>​      window: 全局对象，代表浏览器打开的一个窗口</p>
<p>每个窗口都是一个window对象 </p>
<p>​      document: window的一个属性，这个属性是一个对象</p>
<p>​           代表当前窗口的整个网页，可以操作整个网页的所有内容</p>
<p>​      DOM：一套操作HTML标签的API(接口/方法/属性)</p>
<p>​         文档模型对象(document Object Model)</p>
<p>​         学习DOM就是学习通过document对象操作网页内容</p>
<h3 id="3-2-Dom元素获取"><a href="#3-2-Dom元素获取" class="headerlink" title="3.2 Dom元素获取"></a>3.2 Dom元素获取</h3><p>​    HTML标签也称DOM元素/使用document不用加window</p>
<p>​      通过id获取    document.getElementById(“box”)</p>
<p>​               (id只有一个，会将其包装为对象返回)</p>
<p>​      通过class获取   document.getElementsByCalssName(“”)</p>
<p>​               (返回伪数组)</p>
<p>​      通过name获取  document.getElementsByName(“test”)</p>
<p>​               (表单中的name,返回伪数组)</p>
<p>​      通过标签名获取  document.getElementsByTagName(“div”) 多个</p>
<p>​      <em><strong>*重点：*</strong></em></p>
<p>​      通过选择器获取  document.querySelector(“#box”) //所有选择器都可</p>
<p>​               (只会返回根据指定选择器找到的第一个元素)</p>
<p>​      通过选择器获取  document.querySelectorAll(“”)  //返回数组(多个)</p>
<p>​      ****其他方式****：(以下皆是属性)</p>
<p>​          *获取所有子元素：对象.children  (返回伪数组)</p>
<p>​                   对象.childNodes </p>
<p>​           区别：children获取所有子元素/childNodes获取所有节点</p>
<p>​              节点中包含了文本结点和元素(标签)  </p>
<p>​          *获取第一个子节点/子元素：.firstChild/.firstElementChild</p>
<p>​            最后一个子节点/子元素：.lastChild/.lastElementChild</p>
<p>​          *通过子元素获取父元素/父节点</p>
<p>​            子元素.parentElement  子元素.parentNode</p>
<p>​          *获取相邻上一个节点/元素 .previousSibling/.previousElementSibling  </p>
<p>​           获取相邻下一个节点/元素 .nextSibling/.nextElementSibling</p>
<p>​          *获取html根标签、body标签、所有标签</p>
<p>​           document.body  document.documentElement</p>
<p>​           document.all</p>
<h3 id="3-3-节点增删改查"><a href="#3-3-节点增删改查" class="headerlink" title="3.3 节点增删改查"></a>3.3 节点增删改查</h3><p>​      创建节点  document.createElement(“span”) 创建并返回节点对象</p>
<p>​           createTextNode(“text”) //创建文本结点并返回</p>
<p>​      添加节点  父元素.appendChild(obj)  将元素obj添加到父元素最后</p>
<p>​      插入节点  父元素.insertBefore(obj1,obj2) 将obj1添加到父元素中obj2前面</p>
<p>​      替换结点  父元素.replaceChild()(obj1,obj2)  obj1替换obj2</p>
<p>​      删除节点  节点.parentNode.removeChild(节点) //通过父元素删除指定子元素</p>
<p>​           //只能通过父元素删除，不能自己删除自己</p>
<p>​      克隆节点  obj.cloneNode()  //克隆节点obj,默认不会克隆子元素</p>
<p>克隆其包含所有子元素(指定参数true)</p>
<h3 id="3-4-属性增删改查"><a href="#3-4-属性增删改查" class="headerlink" title="3.4 属性增删改查"></a>3.4 属性增删改查</h3><p>​     无论通过document创建还是查询的标签，系统都会将元素包装成一个对象返回给我们，系统包装这个对象时，会自动将元素的属性都包装到这个对象中</p>
<p>​      所以只要拿到对象就可以拿到标签属性，操作标签属性。</p>
<p>​      获取元素属性  obj.属性名  obj.getAttribute(“属性名”)-可以获取自定义属性</p>
<p>​             //区别：通过obj.属性名无法获取到自定义属性的取值</p>
<p>​      修改元素属性  obj.属性名= ”新值” obj.setAttribute(“属性名”,”新值”) </p>
<p>//区别和获取元素属性一样</p>
<p>​      新增元素属性  obj.setAttribute(“属性名”,”新值”) </p>
<p>​             //只有一个方法新增，属性不存在就新增，存在就修改</p>
<p>​      删除元素属性  obj.属性名=”” (空)  obj.removeArribute(“属性名”) </p>
<p>​             //removeArribute不仅可以清空自带属性，还可以清空自定义</p>
<h3 id="3-5-操作元素内容和样式"><a href="#3-5-操作元素内容和样式" class="headerlink" title="3.5 操作元素内容和样式"></a>3.5 操作元素内容和样式</h3><ul>
<li><strong>操作元素内容</strong></li>
</ul>
<p>​    获取元素内容：.innerHTML  .innerText  .textContent (三个属性都可获取)</p>
<p>​            区别：innerHTML包含标签，其他两个不包含标签</p>
<p>​               innerHTML和textContent不会去除两端空格(innerText会)</p>
<p>​      设置元素内容：通过上面三个属性设置 如：obj.innerHTML=””…</p>
<p>​             通过三种方式设置新的内容都会覆盖原有内容</p>
<p>​            区别：通过innerHTML设置，如果包含标签，会转换为标签添加</p>
<p>​               另外两种方式不会转换，会当成字符串直接设置</p>
<ul>
<li><strong>操作元素样式</strong></li>
</ul>
<p>​    设置元素样式  obj.className=”” //动态设置class属性内容，从而修改样式</p>
<p>​             通过style属性：obj.style.backgroundColor=”pink”</p>
<p>​             //注意：css中通过-连接的都改为驼峰命名</p>
<p>​                 通过style添加的样式都是行内样式</p>
<p>​    获取元素样式  obj.style //只能获取行内样式值，css设置的值获取不到</p>
<p>​             let obj1= window.getComputedStyle(obj);  obj1.width</p>
<p>​             //返回一个对象，保存了css设置的样式和属性值</p>
<h3 id="3-6-事件和事件绑定"><a href="#3-6-事件和事件绑定" class="headerlink" title="3.6 事件和事件绑定"></a>3.6 事件和事件绑定</h3><p>用户和浏览器的交互行为-事件  如：点击 移入/移出</p>
<p>所有HTML标签都可以添加事件</p>
<p>​      元素.事件名称=function(){};  //事件触发时自动执行函数</p>
<p>​      单击事件：btn.onclick=function(){alert(…);}</p>
<p>​      注意：如果给元素添加了和系统同名事件，不会覆盖系统添加的事件</p>
<p>​         如果想覆盖，在function(){return false;}</p>
<p> <em><strong>*事件*</strong></em></p>
<p>​      *添加事件的三种方式   </p>
<p>​       Way1：oBtn.onclick=function(){…}  </p>
<p>//注意点：给同一元素多次添加相同事件后面的会覆盖前面的</p>
<p>​       Way2：oBtn.addEventListener(“click”,function(){…})  </p>
<p> //事件名称不加on,事件不会覆盖,IE9以上</p>
<p>​       Way3：oBtn.attachEvent(“onclick”,function(){…});</p>
<p>//事件名称加on,不会覆盖,只支持低级浏览器</p>
<p>​      *事件对象event</p>
<p>​       当注册事件被触发时，系统就会自动创建事件对象</p>
<p>​       oBtn.onclick=function(event){…}  //回调函数里传递的形参就是事件对象</p>
<p>​       注意点：低级浏览器不支持 兼容：event=event||window.event;</p>
<p>​       event.preventDefault()  //阻止默认行为(以前的return false 企业开发推荐)</p>
<p>​      *事件冒泡和捕获</p>
<p>​       事件执行的三个阶段：</p>
<p>​       First：捕获阶段(从外向内的传递事件)</p>
<p>​          父元素捕获到事件-&gt;子元素捕获到事件</p>
<p>​       Second：当前目标阶段(执行回调函数)  -&gt;触发回调函数</p>
<p>​       Third：冒泡的阶段(从内向外的传递事件)</p>
<p>​          子元素抛出事件-&gt;父元素抛出事件</p>
<p>​       注意：三个阶段只有两个会被同时执行</p>
<p>​          要么捕获和当前,要么当前和冒泡</p>
<p>​       Why: JS处理事件的历史问题,W3C将两种方式都纳入标准</p>
<p>​      How设置事件到底是捕获还是冒泡?</p>
<p>​         只能通过addEventlistener方法,接收三个参数</p>
<p>​         (事件名称,回调函数,false冒泡/true捕获)</p>
<p>​         注意：通过onXXX和attachEvent 方式添加的事件都是冒泡</p>
<p>​      事件冒泡的阻止：event.stopPropagation() //只支持高级浏览器IE9以上</p>
<p>​              event.cancelBubble=true;  //支持低浏览器</p>
<p>  <em><strong>*移入移出事件*</strong></em></p>
<p>​      移入：onmouseover/onmouseenter  例:odiv.onmouseover=function(){…}</p>
<p>​         (初学者为了避免位置的bug，建议使用onmouseenter)</p>
<p>​      移出：onmouseout/onmouseleave  (建议leave)</p>
<p>​      移动：onmousemove</p>
<p>​      两种移入移除事件的区别：</p>
<p>​        onmouseover和onmouseenter</p>
<p>​          over移入到子元素,父元素移入事件也会被触发/enter不会</p>
<p>​        onmouseout和onmouseleave</p>
<p>​          out移出子元素,父元素移出事件也会被触发/leave不会</p>
<p>​      </p>
<p>​      事件对象的属性：</p>
<p>​        event.offsetX/offsetY clientX/clientY pageX/pageY screenX/screenY</p>
<p>​        offsetX/offsetY  事件触发相对于当前元素自身的位置</p>
<p>​        clientX/clientY  事件触发相对于浏览器可视区域的位置</p>
<p>​               (可视区域是不包括滚动条滚动出去的范围)</p>
<p>​        pageX/pageY  事件触发相对于整个网页的位置(包括滚动出去的范围)</p>
<p>​        (注意: 没有滚动条时,client和page一样,但page不兼容IE9以下)</p>
<p>​        screenX/screenY 事件触发相对于显示器的位置(用不上,了解即可)</p>
<p>表单事件</p>
<p>​     表单验证-value属性拿到input值</p>
<p>​     如果想要不触发默认事件，如a链接/表单提交,那么return false即可</p>
<p>​     表单事件：</p>
<p>​         监听input获取焦点  oInput.onfocus()=function(){}</p>
<p>​         监听input失去焦点  onblur</p>
<p>​         监听input内容改变  onchange  //只有表单失去焦点才会监听改变</p>
<p>​                   oninput  //实时获取数据,IE9及以上才能使用</p>
<p>(通过代码oText.value=””给input数据，不会触发oninput事件)</p>
<p>​     补充：默认不可用-添加disabled属性</p>
<p>​        在JS中如果HTML标签的属性名和取值一样,那么JS会返回false/true</p>
<p>​        例：oSubmit.disable=true  //使按钮不可用</p>
<h3 id="3-7-定时器"><a href="#3-7-定时器" class="headerlink" title="3.7 定时器"></a>3.7 定时器</h3><p>​    *重复执行的定时器(window可省略)</p>
<p>​      创建：window.setInterval(function(){…},1000); </p>
<p>//参数：一个函数，一个毫秒值</p>
<p>​              每隔一段时间(第二个参数)，执行函数(第一个参数)</p>
<p>​      销毁：let id=window.setInterval(…);  clearInterval(id);</p>
<p>​         //创建定时器时会返回一个标识，用于销毁使用</p>
<p>​      *只执行一次的定时器  </p>
<p>​       创建：window.setTimeout(function(){…},1000) </p>
<p>//1000毫秒执行一次函数</p>
<p>​       销毁：let id=window.setTimeout(…);  clearTimeout(id);</p>
<p>​                              2021.4.10  </p>
<p>注意：谷歌浏览器默认情况下不允许自动播放音乐，</p>
<p>只有用户和网页交互后才可以播放音乐。</p>
<p>​    解决方案：让用户和网页交互后再播放  调用audio的play方法</p>
<p>​                              2021.4.13</p>
<h3 id="3-8-闭包"><a href="#3-8-闭包" class="headerlink" title="3.8 闭包"></a>3.8 闭包</h3><p>​      *什么是闭包：闭包是一种特殊的函数</p>
<p>​      *如何生成一个闭包：</p>
<p>​        当一个内部函数引用了外部函数的数据(变量/函数)时,内部函数就是闭包</p>
<p>​        所以只要满足”是函数嵌套”、”内部函数引用外部函数数据”</p>
<p>​      *闭包特点：</p>
<p>​        只要闭包还在使用外部函数的数据, 那么外部的数据就一直不会被释放</p>
<p>​        也就是说可以延长外部函数数据的生命周期</p>
<p>​      *闭包注意点</p>
<p>​    当不需要使用闭包时,要手动将闭包设置为null,否则会出现内存泄漏                         </p>
<p>​    <em><strong>*循环索引同步*</strong></em></p>
<p>​      默认情况下,代码从上至下执行,var定义的变量(除函数中)都是全局变量</p>
<p>​      循环索引同步和闭包的结合使用：利用立即执行函数+闭包</p>
<p>for( var i=0;i&lt;bun.length;i++){</p>
<p> let btn=btn[i]; </p>
<p> (function(index){  //立即执行函数和闭包实现循环索引同步</p>
<p> btn.onclick()=function(){ console.log(index);}</p>
<p>})(i);</p>
<p>}  //正常直接绑定事件，每个按钮输出的都是最后一个i</p>
<p>循环()里面var是全局变量，let定义是局部变量</p>
<p>let定义时每次执行完循环体都会重新定义一个i</p>
<p>​      ES6中由于{}是块级作用域(let),在块级作用域中定义了函数</p>
<p>​      且在函数中使用了块级作用域let定义的变量(数据)，那么这个函数就是闭包</p>
<p>​                                                                  2021.4.19</p>
<h3 id="3-10-正则表达式"><a href="#3-10-正则表达式" class="headerlink" title="3.10 正则表达式"></a>3.10 正则表达式</h3><p>​      *正则表达式是对字符串操作的一种逻辑公式</p>
<p>​      *作用：在字符串”查找”是否包含指定子串</p>
<p>​         从字符串中”提取”指定子串</p>
<p>​         对字符串中指定的内容进行”替换”</p>
<p>​      字符串查找: indexOf/lastIndexOf/includes </p>
<p>​      提取: substr/substring  替换: replace</p>
<p>​      *first 利用正则表达式匹配(查找)</p>
<p>​       创建正则表达式对象-&gt;指定匹配规则(构造函数中指定规则)</p>
<p>​        let reg=new RegExp(“a”);  //RegExp(“a”,”i”);不区分大小写</p>
<p>​       -&gt;利用test方法进行匹配</p>
<p>​        reg.test(str)  //包含a返回true,发展false</p>
<p>​        注意：正则表达式严格区分大小写(不区分大小写传递参数”i”)</p>
<p>​      通过字面量创建正则：let reg=/规则/</p>
<p>​         </p>
<p>​      *second 通过正则表达式提取符合规则的字符串</p>
<p>​       let res=str.match(reg);  //默认情况一旦匹配就停止查找</p>
<p>​       通过修饰符g-全局查找  let reg=/规则/g</p>
<p>​      *third  通过正则表达式替换符合规则的字符串</p>
<p>​       let newstr=str.replace(reg,”替换内容”);</p>
<p>//第一个参数除了字符串还可以接收正则对象</p>
<h2 id="5-BOM"><a href="#5-BOM" class="headerlink" title="5. BOM"></a>5. BOM</h2><p>BOM就是提供了一套操作浏览器的API(接口/方法/属性)</p>
<h3 id="4-1-BOM常见对象"><a href="#4-1-BOM常见对象" class="headerlink" title="4.1 BOM常见对象"></a>4.1 BOM常见对象</h3><p>​     window 代表整个浏览器窗口(BOM中的一个顶级对象(全局))</p>
<p>​     Navigator 浏览器信息-判断是什么浏览器</p>
<p>​     Location  浏览器地址栏信息-设置/获取地址信息</p>
<p>​     History  浏览器历史信息-实现刷新/上一步/下一步</p>
<p>​         (由于隐私,只能拿到用户当前历史记录,不能拿到所有历史记录)</p>
<p>​     Screen  用户的屏幕信息(了解即可)-显示器宽高</p>
<p>*Navigator对象</p>
<p>  userAgent属性：包含了浏览器信息的字符串</p>
<p>  应用：if(/chrome/i.test(Navigator.userAgent)){alert(“谷歌浏览器”)}</p>
<p>*Location对象</p>
<p>​    获取/设置当前地址栏url  location.href/location.href=””</p>
<p>​    重新加载网页(刷新)  location.reload();  </p>
<p>​    强制刷新(更新缓存)  location.reload(true);</p>
<p>*History对象</p>
<p>  前进(下一步)  history.forward()  history.go()//go可以传入一个整数-前进几步</p>
<p>  后退   history.back()   history.go()//go可以接受一个负数,代表后退几步</p>
<p>  刷新   history.go(0)  //传入0代表刷新</p>
<h3 id="4-2-JS三大家族"><a href="#4-2-JS三大家族" class="headerlink" title="4.2 JS三大家族"></a>4.2 JS三大家族</h3><p>(offset/client/scroll)</p>
<p><em><strong>*获取元素宽高方式：*</strong></em></p>
<p>   (以下方法都是将元素属性封装到对象中返回)</p>
<p>​    getComputedStyle(oDiv)  </p>
<p>获取的宽高不包括边框和内边距</p>
<p>​      不仅能获取css属性也可以获取style(行内)</p>
<p>​      只读方法(不能设置),只支持IE9及以上</p>
<p>​     oDiv.currentStyle属性   </p>
<p>​      只支持IE9以下,其他和computed一样</p>
<p>​     oDiv.style属性</p>
<p>​       只能获取行内样式,可以设置行内样式</p>
<p>​       不包括边框和内边距,支持IE9以下</p>
<p>​    <em><strong>*offset家族*</strong></em>    (三大家族-不带单位-只读)</p>
<p>​     oDiv.offsetWidth/offsetHeight</p>
<p>​       包括边框和内边距,支持IE9以下</p>
<p>​       只读,行内/css都能获取</p>
<p>​     oDiv.offsetLeft/offsetTop</p>
<p>​      获取元素到第一个定位祖先元素的偏移位(没有定位,就是距离body)</p>
<p>​     oDiv.offsetparent</p>
<p>​      获取元素第一个定位的祖先元素(没有定位就是body)</p>
<p>​    <em><strong>*client家族*</strong></em></p>
<p>​     oDiv.clientWidth/Height  元素自身+内边距</p>
<p>​     oDiv.clientLeft/Top  左边框,顶部边框</p>
<p>​    <em><strong>*scroll家族*</strong></em></p>
<p>​     oDiv.scrollWidth/Height  </p>
<p>​      内容没有超出元素范围时=元素+内边距=clientWidth/Height</p>
<p>​      超出元素范围时=元素+内边距+超出宽度</p>
<p>​     oDiv.scrollLeft/Top</p>
<p>​      滚动时(onscroll事件),内容移出去的距离(从内边距外部开始计算)</p>
<p>​      </p>
<h3 id="4-3-获取网页宽高"><a href="#4-3-获取网页宽高" class="headerlink" title="4.3 获取网页宽高"></a>4.3 获取网页宽高</h3><p>​    获取网页可视区域宽高    </p>
<p>window.innerWidth/innerHeight  //只能在IE9及以上</p>
<p>document.documentElement.clientWidth/clientHeight  标准模式</p>
<p>注意：可用于IE9以下浏览器的标准模式中获取</p>
<p>浏览器渲染网页模式：标准(默认)/混杂/怪异模式</p>
<p>如果网页没有书写文档声明<!DOCTYPE html>-混杂/怪异模式渲染</p>
<p>可通过document.compatMode获取是什么模式</p>
<p>​       混杂模式通过: document.body.clientWidth/clientHeight 获取</p>
<p>​    兼容性写法自己封装…略</p>
<h3 id="4-4-网页滚动距离"><a href="#4-4-网页滚动距离" class="headerlink" title="4.4 网页滚动距离"></a>4.4 网页滚动距离</h3><p>​    IE9及以上浏览器</p>
<p>​     window.pageXOffset/pageYOffset</p>
<p>​    标准模式下浏览器</p>
<p>​     document.documentElement.scrollTop/scrollLeft</p>
<p>​    混杂(怪异)模式下浏览器</p>
<p>​     document.body.scrollTop/scrollLeft</p>
<h3 id="4-5-函数防抖和函数节流"><a href="#4-5-函数防抖和函数节流" class="headerlink" title="4.5 函数防抖和函数节流"></a>4.5 函数防抖和函数节流</h3><ul>
<li><strong>函数防抖</strong></li>
</ul>
<p>函数防抖是优化高频率执行js代码的一种手段</p>
<p>​    可以让被调用的函数在一次连续的高频操作过程中只被调用一次</p>
<p>​    作用：减少代码执行次数,提升网页性能</p>
<p>​    应用场景：oninput/onmousemove/onscroll/onresize等事件</p>
<ul>
<li><strong>函数节流</strong></li>
</ul>
<p>​    作用和函数防抖一样</p>
<p>​     区别：函数节流是减少连续的高频操作函数执行次数</p>
<p>(例如连续调用10次,可能只执行3-4次)</p>
<p>​        函数防抖是让连续的高频操作时函数只执行一次</p>
<p>(例如连续调用10次,但只会执行1次)</p>
<p>​                                                                                                                2021/4/22</p>
<h2 id="6-JSON"><a href="#6-JSON" class="headerlink" title="6. JSON"></a>6. JSON</h2><p>JSON是一种轻量级的数据交换格式(本质上是字符串)</p>
<p>​    采用完全独立于编程语言的文本格式来存储和表示数据</p>
<p>​    JSON其实就是字符串版本的JS对象  ‘{“name”: “cth”}’</p>
<p>​    注意点：JSON的key只能是字符串,value可以是任意数据类型</p>
<p>​    转换：json=JSON.stringify(obj);  obj=JSON.parse(json);</p>
<h1 id="JS高级"><a href="#JS高级" class="headerlink" title="JS高级"></a>JS高级</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><ul>
<li>js的重要性</li>
</ul>
<p>​        所有框架都是在js的基础上编写的</p>
<ul>
<li>js应用场景</li>
</ul>
<p>​        web端 移动端 小程序 桌面应用(如vs code) 后端Node</p>
<ul>
<li><p>js让人疑惑的地方</p>
<p>函数、闭包 、作用域、面向对象(继承、原型链等)、ES新特征(ES6-12) </p>
<p>其他一系列知识(事件循环、宏任务、微任务、内存管理、Promise、await、asnyc、防抖节流等)</p>
</li>
<li><p>TypeScript会取代JavaScript吗</p>
</li>
</ul>
<p>​        TS致力于为JS提供类型检查，而不是取代JS(TS官方文档：源于JS，归于JS)</p>
<p>​        TS只是JS的一个超集，在它的基础上进行了扩展</p>
<p>​        并且最终TS还是需要转换为JS代码才能真正的运行        </p>
<ul>
<li><p>js是一门编程语言(高级的编程语言)</p>
<div class="code-wrapper"><pre><code class="hljs">机器语言(01) -&gt; 汇编语言(汇编指令) -&gt; 高级语言(c、c++、java、js、python)-编译型/解释型
</code></pre></div>
</li>
</ul>
<p>​        (计算机不认识高级语言，代码最终需要转换成机器指令)</p>
<h2 id="2-浏览器工作原理和V8引擎"><a href="#2-浏览器工作原理和V8引擎" class="headerlink" title="2. 浏览器工作原理和V8引擎"></a>2. 浏览器工作原理和V8引擎</h2><ul>
<li><strong>浏览器工作原理</strong></li>
</ul>
<p>​        域名 (DNS解析)-&gt; ip地址 -&gt;服务器地址-&gt; 返回index.html(解析)</p>
<p>​        解析过程中有link标签和script标签 -&gt; 到服务器再次下载对应css和js文件 </p>
<ul>
<li><p>浏览器内核</p>
<p>不同浏览器有不同内核组成</p>
<p>Gecko-早期Netscape和Firefox浏览器使用</p>
<p>Trident-IE4-11浏览器，Edge浏览器已转向Blik</p>
<p>Webkit-苹果开发的，基于Safari，Google之前也在使用</p>
<p>Blik-Webkit的一个分支，Google开发，目前应用于Google、Edge、Opera</p>
<p>浏览器内核-浏览器排版引擎/页面渲染引擎</p>
</li>
<li><p>浏览器渲染过程</p>
<p>html遇到js标签-&gt;停止解析html-&gt;加载执行js代码(js执行是在DOM-&gt;DOM Tree过程改变dom)</p>
<p>html、css解析(Parser) -&gt; DOM Tree+Style Rules -&gt; Render Tree(渲染树) -&gt; Display</p>
<p>如图：</p>
<p> <img src="C:\Users\Administrator\Desktop\2022\img\js高级_浏览器渲染过程.png" srcset="/img/loading.gif" lazyload></p>
<p>js代码是如何执行呢？</p>
</li>
<li><p>js引擎</p>
<p>定义：JavaScript引擎是一个专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器之中</p>
<p>浏览器/Node执行js代码  -&gt; 需要js引擎将js代码转换成CPU指令(机器代码)</p>
<p>引擎举例：</p>
<p>SpiderMonkey：第一款js引擎，由Brendan Eich开发(js作者)</p>
<p>Chakra：微软开发</p>
<p>JavaScriptCore：WebKit中的js引擎，Apple开发(小程序开发常用)</p>
<p>V8：Google开发的js引擎</p>
</li>
</ul>
<ul>
<li><p>浏览器内核和JS引擎的关系</p>
<ul>
<li><p>以Webkit为例，Webkit由两部分组成</p>
</li>
<li><p>WebCore ：负责HTML解析、布局、渲染等工作</p>
</li>
<li><p>JavaScriptCore：解析、执行js代码(小程序中编写的js就是被JSCore执行的)</p>
</li>
</ul>
</li>
<li><p>V8引擎的原理</p>
<p>V8是用c++编写的Goole开源高性能JavaScript和WebAssembly引擎，它用于Chrome和Node.js等  </p>
<p>V8可以独立运行，也可以嵌入到任何C++应用程序中</p>
<p>解析过程：</p>
<p>源码 -&gt; parse(词法分析、语法分析) -&gt;AST抽象语法树-&gt;由Ignition库转换为字节码bytecode</p>
<p>-&gt;V8将字节码转换成机器指令-CPU代码(不同平台CPU不一样所以需要先转换字节码)运行</p>
<p>TurboFan库/模块 将多次执行的代码变成优化的机器指令，下次可直接执行</p>
<p>如图：    </p>
<p><img src="C:\Users\Administrator\Desktop\2022\img\js高级_V8引擎的原理.png" srcset="/img/loading.gif" lazyload>        </p>
</li>
<li><p>代码执行流程分析</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 1. 代码解析，V8引擎内部会给我们创建一个对象(GlobalObject -&gt; go)</span><br><span class="hljs-comment"> 2. 运行代码</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><strong>扩展运算符</strong></li>
</ul>
<p>扩展运算符在函数形参列表中的作用</p>
<p>将传递给函数的所有实参打包到一个数组中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params">...arr</span>) </span>&#123;   <span class="hljs-comment">//将参数打包到arr数组</span><br>  <span class="hljs-built_in">console</span>.log(arr); <br>&#125;<br>fun(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>

<p>注意：和在等号左边一样，也只能写在形参列表最后 </p>
<ul>
<li><strong>形参默认值</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//ES6: 直接在形参指定默认值</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params">a = <span class="hljs-number">6</span>, b = <span class="hljs-number">6</span></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a, b);  <span class="hljs-comment">//Result: 6 6</span><br>&#125;<br>fun()<br></code></pre></td></tr></table></figure>

<p>可以将函数作为其他函数的参数和返回值</p>
<p>JS中函数可以嵌套定义(函数中可以定义函数)</p>
<p>​          </p>
<ul>
<li><strong>箭头函数</strong></li>
</ul>
<p>ES6新增定义函数的格式，为了简化定义函数代码 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//let 函数名称=(形参列表)=&gt;&#123;...&#125;</span><br><span class="hljs-keyword">let</span> fun=<span class="hljs-function">(<span class="hljs-params">a</span>)=&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意点：</p>
<p>​    如果()只有一个形参，括号可以省略 </p>
<p>​    如果大括号中只有一句代码，那么{}也可以省略</p>
<p>箭头函数和普通函数的区别</p>
<p>​    普通函数/方法，谁调用this就是谁</p>
<p>​    箭头函数的this，是父作用域的this，不是调用者  </p>
<p>​    注意：箭头函数中的this永远都只看它所属的作用域的this,不能通过bind/call/apply来修改   </p>
<ul>
<li><strong>作用域链</strong></li>
</ul>
<p>ES6之前作用域链：</p>
<p>​    全局作用域是0级作用域</p>
<p>​    定义函数开启的作用域是1/2/3…级</p>
<p>​    JS会将这些作用域连接起来形成作用域链</p>
<p>​    0-&gt;1-&gt;2-&gt;3-&gt;4… (0级作用域里定义的函数就是1级)</p>
<p>变量在作用域链查找规则：</p>
<p>​    先在当前找，找到就使用当前作用域的</p>
<p>​    当前没有就去上一级作用域查找</p>
<p>​    以此类推直到0级为止，0级没有找到就报错</p>
<p>ES6作用域链：</p>
<p>​    除了定义函数会开启作用域外，代码块也会开启作用域</p>
<p>​    注意点：要用ES6就全部用ES6如：let、箭头函数(不然容易混淆)</p>
<p>​    函数预解析：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//ES6之前这种定义函数方式，可以提前调用(会将函数的声明提升到当前作用域最前面)</span><br>say()  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">say</span>(<span class="hljs-params"></span>)</span>&#123;&#125;  <br><span class="hljs-comment">//报错，这样只有变量才会预解析</span><br>say()  <span class="hljs-keyword">var</span> say=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;  <br><span class="hljs-comment">//不会被预解析,let定义的</span><br>say()  <span class="hljs-keyword">let</span> say = <span class="hljs-function">() =&gt;</span> &#123;&#125;  <br></code></pre></td></tr></table></figure>



<ul>
<li>对象的属性方法分类</li>
</ul>
<p>实例属性/实例方法:</p>
<p>​    通过构造函数创建的对象 - 实例对象</p>
<p>​    通过实例对象访问的属性 - 实例属性</p>
<p>​    通过实例对象调用的方法 - 实例方法</p>
<p>静态属性/静态方法:</p>
<p>​    通过构造函数访问/调用的属性/方法就是静态属性和静态方法</p>
<p>​    构造函数也是对象：构造函数.属性=…</p>
<p><strong>prototype对象</strong> </p>
<p>可以将构造函数中公共的方法存储到prototype对象中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Person.prototype=&#123;<span class="hljs-attr">say</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;&#125;  <span class="hljs-comment">//里面放构造函数公共方法 </span><br></code></pre></td></tr></table></figure>

<p>prototype对象特点：</p>
<p>​    存储在prototype中的方法可以被对应构造函数创建的所有对象共享(也可存储属性)</p>
<p>​    prototype中出现和构造函数重名属性或方法，访问到的是构造函数中的</p>
<p>应用场景：</p>
<p>​    prototype中一般用于存储所有对象都相同的属性及方法 </p>
<ul>
<li>对象三角恋关系</li>
</ul>
<p>每个构造函数都有一个默认属性-prototype</p>
<p>prototype中保存着一个对象-原型对象</p>
<p>每个原型对象都有一个默认属性-constructor</p>
<p>constructor指向当前原型对象对应的那个构造函数</p>
<p>通过构造函数创建的对象-实例对象</p>
<p>每个实例对象都有一个默认属性 <strong>proto</strong> (两下划线)</p>
<p><strong>proto</strong> 指向创建它的那个构造函数的原型对象</p>
<ul>
<li>Function构造函数</li>
</ul>
<p>​    函数是引用类型(对象)，所有函数都是通过Function构造函数创建的对象</p>
<p>​    构造函数的__proto__比较特殊，指向它自己的原型对象(和prototype一样)</p>
<p>​    Object构造函数  Object原型对象的__proto__为null</p>
<p>​      </p>
<ul>
<li>函数关系完整关系</li>
</ul>
<p>​      Function函数是所有函数的祖先函数</p>
<p>​      所有构造函数都有一个prototype属性</p>
<p>​      所有原型对象都有一个constructor属性</p>
<p>​      所有函数都是对象</p>
<p>​      所有对象都有一个__proto__属性                 </p>
<p> <img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml2868\wps1.png" srcset="/img/loading.gif" lazyload alt="img"><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml2868\wps2.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>​     <img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml2868\wps3.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>​                            -2021.4.3</p>
<ul>
<li><p><strong>原型链</strong></p>
<p>当给构造函数的(.prototype={})赋值时，为了不破坏原有关系</p>
<p>需要在自定义的对象中手动添加constructor属性，手动指定指向谁(构造函数)</p>
<p>通过 __proto__ 连接在一起的链叫做原型链</p>
<p>当使用对象的属性和方法时，自己有用自己的，自己没有去原型中找</p>
<p>原型没有，就去原型的原型找，一直找到Object的__proto__为NULL为止</p>
<p>注意：给对象不存在的属性设置值时，不会去原型中查找，会给当前对象新增</p>
</li>
<li><p><strong>封装/继承/多态</strong></p>
</li>
</ul>
<p>JS面向对象的三大特性：封装、继承、多态</p>
<p><strong>封装性</strong></p>
<p>默认情况对象属性和方法都是公开的，拿到对象就可以操作对象的属性方法</p>
<p>构造函数中let/var设置私有属性，通过this.设置公有方法修改和访问私有属性</p>
<p><strong>继承</strong></p>
<p>bind-call-apply三个方法</p>
<p>作用：都是用于修改函数或方法中的this的</p>
<p>obj是新this的指向对象</p>
<p>bind方法：函数.bind(obj ,参数…);  会返回一个修改后的新函数</p>
<p>​     也可以函数传参，只不过参数要写在this对象后面</p>
<p>call方法： 函数.call(obj ,参数…);  会立即调用新函数  可传参</p>
<p>apply方法：也是立即调用，但传递参数格式不一样，通过数组传参</p>
<p>​      函数.apply(obj ,[参数…]);  </p>
<p>修改方法的this：方法.bind() 一样的做法…</p>
<p>JS继承的终极方法：</p>
<p>  在子类的构造函数中通过call借助父类的构造函数</p>
<p>  将子类的原型对象修改为父类的实例对象\</p>
<p><strong>多态</strong></p>
<p>强类型语言-变量使用严格符合定义：int就存储整型</p>
<p>弱类型-不要求变量使用严格符合-JS就是弱类型</p>
<p>弱类型语言不关注多态</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>数组解构赋值 </li>
</ul>
<p>ES6新增赋值方法，左边右边格式必须相同，才能完全解构</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//左右边个数可以不一样，会赋值undefined或者多余值丢弃</span><br><span class="hljs-keyword">let</span> [a,b,c]=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-keyword">let</span> [a,b=<span class="hljs-number">666</span>,c=<span class="hljs-number">1</span>]=[<span class="hljs-number">1</span>] <span class="hljs-comment">//可以给左边的值指定默认值 </span><br><br><span class="hljs-comment">//ES6扩展运算符：在最后一个字母前加... 可以将多余数据打包</span><br><span class="hljs-keyword">let</span> [a,...b]=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] <br></code></pre></td></tr></table></figure>




            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
                    
                      <a class="hover-with-bg" href="/categories/%E5%89%8D%E7%AB%AF/2-JS/">2. JS</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/JS/">JS</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/24/1.%20html/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">HTML详解</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/24/0.%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">
                        <span class="hidden-mobile">Hexo博客搭建和部署</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
  <!--《添加网站运行时间 -->
<!--<br/>-->
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date();

    function createtime() {
        var grt = new Date("01/14/2022 12:00:00"); //此处修改你的建站时间或者网站上线时间 
        now.setTime(now.getTime() + 250);
        days = (now - grt) / 1000 / 60 / 60 / 24;
        dnum = Math.floor(days);
        hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum);
        hnum = Math.floor(hours);
        if (String(hnum).length == 1) {
            hnum = "0" + hnum;
        }
        minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes);
        if (String(mnum).length == 1) {
            mnum = "0" + mnum;
        }
        seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds);
        if (String(snum).length == 1) {
            snum = "0" + snum;
        }
        document.getElementById("timeDate").innerHTML = " 本站已安全运行 " + dnum + " 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
    setInterval("createtime()", 250);
</script>
<!-- 添加网站运行时间》 -->
</footer>
<script type="text/javascript" src="/js/clicklove.js"></script>
<script type="text/javascript" src="https://libs.baidu.com/jquery/1.8.3/jquery.js"></script>
<script type="text/javascript" src="https://libs.baidu.com/jquery/1.8.3/jquery.min.js"></script>
<!-- 雪花特效 -->
<script type="text/javascript" src="/js/snow.js"></script>








  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/haru01.model.json"},"display":{"superSample":2,"width":150,"height":430,"position":"right","hOffset":0,"vOffset":-20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false});</script></body>
</html>
