

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="JS基础0. 邂逅JavaScript（了解）0.0 认识编程语言 HTML-标记语言    CSS-样式语言  HTML、CSS、JS都属于计算机语言（我们人和计算机进行沟通交流的语言）  JS不仅属于计算机语言，精确来说是一门编程语言  编程语言特征  数据和数据结构(变量、数组、对象等) 指令及流程控制（if&#x2F;for） 引用机制和重用机制 设计哲学    0.1 编程语言发展历史 机器语言">
<meta property="og:type" content="article">
<meta property="og:title" content="Javascript详解">
<meta property="og:url" content="https://kygo.top/2022/03/24/3.%20js/index.html">
<meta property="og:site_name" content="欢迎来到Kygo的博客">
<meta property="og:description" content="JS基础0. 邂逅JavaScript（了解）0.0 认识编程语言 HTML-标记语言    CSS-样式语言  HTML、CSS、JS都属于计算机语言（我们人和计算机进行沟通交流的语言）  JS不仅属于计算机语言，精确来说是一门编程语言  编程语言特征  数据和数据结构(变量、数组、对象等) 指令及流程控制（if&#x2F;for） 引用机制和重用机制 设计哲学    0.1 编程语言发展历史 机器语言">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:/Users/Administrator/Desktop/2022/img/js高级_浏览器渲染过程.png">
<meta property="og:image" content="c:/Users/Administrator/Desktop/2022/img/js高级_V8引擎的原理.png">
<meta property="og:image" content="file:///C:/Users/ADMINI~1/AppData/Local/Temp/ksohtml2868/wps1.png">
<meta property="og:image" content="file:///C:/Users/ADMINI~1/AppData/Local/Temp/ksohtml2868/wps2.png">
<meta property="og:image" content="file:///C:/Users/ADMINI~1/AppData/Local/Temp/ksohtml2868/wps3.png">
<meta property="article:published_time" content="2022-03-24T05:40:04.000Z">
<meta property="article:modified_time" content="2023-02-13T00:51:35.003Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="JS">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="c:/Users/Administrator/Desktop/2022/img/js高级_浏览器渲染过程.png">
  
  
  <title>Javascript详解 - 欢迎来到Kygo的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"kygo.top","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>东白</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/article.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Javascript详解">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-24 13:40" pubdate>
        2022-03-24 13:40:04
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      39k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      326 分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Javascript详解</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2023-02-13 08:51:35
                
              </p>
            
            <div class="markdown-body">
              <h1 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h1><h2 id="0-邂逅JavaScript（了解）"><a href="#0-邂逅JavaScript（了解）" class="headerlink" title="0. 邂逅JavaScript（了解）"></a>0. 邂逅JavaScript（了解）</h2><h3 id="0-0-认识编程语言"><a href="#0-0-认识编程语言" class="headerlink" title="0.0 认识编程语言"></a>0.0 认识编程语言</h3><ul>
<li><p>HTML-标记语言    CSS-样式语言</p>
</li>
<li><p>HTML、CSS、JS都属于<strong>计算机语言</strong>（我们人和计算机进行沟通交流的语言）</p>
</li>
<li><p>JS不仅属于计算机语言，精确来说是一门<strong>编程语言</strong></p>
</li>
<li><p><strong>编程语言特征</strong></p>
<ul>
<li>数据和数据结构(变量、数组、对象等)</li>
<li>指令及流程控制（if/for）</li>
<li>引用机制和重用机制</li>
<li>设计哲学</li>
</ul>
</li>
</ul>
<h3 id="0-1-编程语言发展历史"><a href="#0-1-编程语言发展历史" class="headerlink" title="0.1 编程语言发展历史"></a>0.1 编程语言发展历史</h3><ul>
<li>机器语言<ul>
<li>由0、1组成，也叫做机器码或二进制编码</li>
<li>一定长度的机器码组成了机器指令，用机器指令编写的程序就是机器语言</li>
<li>优点：直接被计算机识别，不需编译解析，直接对硬件产生作用，程序效率高</li>
<li>缺点：可读性差、容易出错、不易编写</li>
</ul>
</li>
<li>汇编语言<ul>
<li>用符号代替冗长的0、1代码（通过汇编器将汇编码转成0、1，从而被机器识别）</li>
<li>优点：和机器语言一样，可以直接访问、控制计算机的各种硬件设备，占用内存少执行速度快</li>
<li>缺点：代码缺乏可移植性（不同语言有不同汇编语言语法和编译器）、符号非常多难记</li>
<li>应用场景：操作系统内核、单片机程序、驱动程序</li>
</ul>
</li>
<li>高级语言<ul>
<li>高级语言就是更接近自然的语言，更符合人类的思维方式，一般使用英文编写</li>
<li>优点<ul>
<li>简单、易用、易于理解，语法结构类似于普通英文</li>
<li>远离对硬件的直接操作</li>
<li>具有可移植性，一个程序可以在不同机器上运行</li>
</ul>
</li>
<li>缺点<ul>
<li>不能直接被计算机识别，需要经编译器翻译成二进制指令后，才能运行到计算机上</li>
<li>种类繁多</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="0-2-js的历史"><a href="#0-2-js的历史" class="headerlink" title="0.2 js的历史"></a>0.2 js的历史</h3><ul>
<li><p>认识JavaScript</p>
<ul>
<li>JavaScript是一门高级的、解释型的编程语言</li>
<li>是一门基于原型的、头等函数的语言，是一门多范式的语言…</li>
<li>JavaScript是前端开发的灵魂</li>
</ul>
</li>
<li><p>1994年，网景公司（Netscape）发布了Navigator浏览器0.9版本</p>
<ul>
<li>这是历史上第一个比较成熟的网络浏览器</li>
<li>但是这个版本浏览器只能用来浏览，不能与用户互动，网景公司急需一种网页脚本语言</li>
</ul>
</li>
<li><p>网景公司当时想要选择一门语言来嵌入到浏览器中</p>
<ul>
<li>网景公司招募了程序员Brendan Eich，希望将Scheme语言作为网页脚本语言的可能</li>
<li>同时发生了一件大事：1995年Sun公司将Oka语言改名Java，正式向市场推出</li>
<li>网景公司动了心，希望和Sun公司结成联盟，将Java嵌入到网页中来运行</li>
<li>Brendan Eich本人非常热衷于Scheme，但管理层那时候有点倾向于Java</li>
</ul>
</li>
<li><p>Brendan Eich用10天时间设计出JavaScript</p>
<ul>
<li>最初这门语言得名字叫Mocha（摩卡），Navigator2.0 beta版本改名为LiveScript</li>
<li>Navigator2.0 beta 3版本正式命名为JavaScript（当时是为了给这门语言搭上Java这个热词）</li>
<li>这门语言更像是很多语言的大杂烩<ul>
<li>借鉴C语言的基本语法</li>
<li>借鉴Java语言的数据类型和内存管理</li>
<li>借鉴Scheme语言，将函数提升到”一等公民”（first class）的地位</li>
<li>借鉴Self语言，使用基于原型（prototype）的继承机制</li>
</ul>
</li>
</ul>
</li>
<li><p>微软公司于1995年首次推出Internet Explorer，从而引发了与Netscape的浏览器大战</p>
<ul>
<li>微软创建了JScript语言，这时对开发者来说是一种噩耗，因为要适配不同浏览器</li>
</ul>
</li>
<li><p>1996年11月，网景正式向ECMA（欧洲计算机制造商协会）提交语言标准</p>
<ul>
<li>1997年6月，ECMA以JavaScript语言为基础制定了ECMAScript标准规范ECMA-262</li>
<li>JavaScript成为ECMAScript最著名的实现之一（ActionScript和JScript也都是ECMAScript规范的实现语言）</li>
</ul>
</li>
<li><p>所以说，ECMAScript是一种规范，而JavaScript是这种规范的一种实现</p>
</li>
</ul>
<h3 id="0-3-js的组成"><a href="#0-3-js的组成" class="headerlink" title="0.3 js的组成"></a>0.3 js的组成</h3><ul>
<li>JavaScript是ECMAScript标准的<strong>语言层面</strong>实现</li>
<li>除了语言规范外，JS还需要对页面(DOM)和浏览器(BOM)进行各种操作</li>
<li>所以JS由三大部分组成：ECMAScript、DOM、BOM</li>
</ul>
<h3 id="0-4-js运行引擎"><a href="#0-4-js运行引擎" class="headerlink" title="0.4 js运行引擎"></a>0.4 js运行引擎</h3><ul>
<li>不同的浏览器由不同的内核组成，如：Webkit、Blink</li>
<li>通常我们说的浏览器内核是指：排版引擎，而JS是由JS引擎来执行的</li>
<li>JS引擎<ul>
<li>为什么需要JS引擎：将JS(高级语言)=&gt;CPU指令(机器码)来执行</li>
<li>常见的JS引擎<ul>
<li>SpiderMonkey：第一款JS引擎，由Brendan Eich开发（JS作者）</li>
<li>Chakra：微软开发，用于IE浏览器</li>
<li>JavaScriptCore：Webkit中的JS引擎，Apple公司开发</li>
<li>V8：Google开发的强大JS引擎，帮助Chrome浏览器脱颖而出</li>
</ul>
</li>
</ul>
</li>
<li>浏览器内核和JS引擎的关系<ul>
<li>以WebKit内核为例，由两部分组成<ul>
<li>WebCore：负责HTML解析、布局渲染等</li>
<li>JavaScriptCore：解析、执行JS代码</li>
</ul>
</li>
<li>在小程序中编写的JS也是由JSCore执行的</li>
</ul>
</li>
</ul>
<h3 id="0-5-js应用场景"><a href="#0-5-js应用场景" class="headerlink" title="0.5 js应用场景"></a>0.5 js应用场景</h3><ul>
<li>Web开发（原生JS、Vue、React、Angular开发）</li>
<li>移动端开发（ReactNative、Weex）</li>
<li>小程序开发（微信小程序、支付宝小程序、uniapp、taro）</li>
<li>桌面端开发（Electron，如VSCode）</li>
<li>后端开发（Node框架，koa、express…）</li>
</ul>
<h2 id="1-JavaScript基本知识"><a href="#1-JavaScript基本知识" class="headerlink" title="1. JavaScript基本知识"></a>1. JavaScript基本知识</h2><h3 id="1-1-JS编写方式"><a href="#1-1-JS编写方式" class="headerlink" title="1.1 JS编写方式"></a>1.1 JS编写方式</h3><ul>
<li>位置：行内/内部/外部引入  (外部src引入的script标签中不能写js代码，不然无效)</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 行内引入-HTML代码行内（不推荐） --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;行内引入js&#x27;)&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>点一下<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:alert(&#x27;行内引入js方式二&#x27;)&quot;</span>&gt;</span>点一下<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 内部引入-script标签中 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  alert(<span class="hljs-string">&quot;内部引入js&quot;</span>)</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 外部引入-外部js文件，通过script元素的src属性引入文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./out.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>注意点：js代码放到head，并需要通过js操作页面元素时就会失效(HTML从上至下执行)</p>
</li>
<li><p>解决</p>
<ul>
<li>加上window.onload=function(){ js代码 }  (内部外部都可以加)</li>
<li>将script或script-src放到body结束标签之前</li>
</ul>
</li>
</ul>
<h3 id="1-2-noscript元素"><a href="#1-2-noscript元素" class="headerlink" title="1.2 noscript元素"></a>1.2 noscript元素</h3><ul>
<li><p>浏览器不支持JavaScript或者用户关闭了浏览器的JavaScirpt功能时，可以使用noscript元素</p>
</li>
<li><p>noscript元素用于给不支持JavaScript的浏览器提供替代内容</p>
</li>
<li><p>注意：只有当浏览器不支持或关闭了javascript时，noscirpt元素才会起作用（显示出来）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>您的浏览器不支持或关闭运行JavaScript<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-3-JavaScript编写注意事项"><a href="#1-3-JavaScript编写注意事项" class="headerlink" title="1.3 JavaScript编写注意事项"></a>1.3 JavaScript编写注意事项</h3><ul>
<li>script元素不能写成单标签</li>
<li>自动省略type属性（以前的代码script中会使用type=”text/javascript”，现在不用写了）</li>
<li>加载顺序<ul>
<li>作为HTML文档的一部分，自上而下加载，<strong>推荐将js放在body子元素的最后一行</strong></li>
</ul>
</li>
<li>js代码严格区分大小写</li>
<li>script元素还有defer、async属性（后续学习）</li>
</ul>
<h3 id="1-4-JS和浏览器的交互方式"><a href="#1-4-JS和浏览器的交互方式" class="headerlink" title="1.4 JS和浏览器的交互方式"></a>1.4 JS和浏览器的交互方式</h3><ul>
<li><p>弹窗：alert()-确定按钮  confirm()-确定取消  prompt()-确定取消获取用户输入框    </p>
</li>
<li><p>网页内容区域：document.write()  </p>
</li>
<li><p>控制台：普通console.log(a,b…)  警告console.warn()  错误console.error()</p>
</li>
</ul>
<h3 id="1-5-Chrome调试工具"><a href="#1-5-Chrome调试工具" class="headerlink" title="1.5 Chrome调试工具"></a>1.5 Chrome调试工具</h3><ul>
<li><p>可以在开发者工具中的console查看log出的内容</p>
</li>
<li><p>如果代码中出现了错误或警告，会在console中显示</p>
</li>
<li><p>console中有个 &gt; 符号，表示控制台的命令行</p>
<ul>
<li>在命令行中可以直接编写js代码，按下enter键执行</li>
<li>如果想编写多行代码，按住shift+enter来换行</li>
</ul>
</li>
<li><p>还可以通过debug方式来调试、查看代码的执行流程</p>
</li>
</ul>
<h3 id="1-6-JS的语句和分号"><a href="#1-6-JS的语句和分号" class="headerlink" title="1.6 JS的语句和分号"></a>1.6 JS的语句和分号</h3><ul>
<li>语句是向浏览器发出的指令，通常表达一个操作或行为</li>
<li>通常每条语句后都会加上一个分号，表示语句的结束</li>
<li>当存在换行符时，大多数情况可以省略分号（JS将换行符理解成”隐式”的分号，也称为自动插入分号）</li>
</ul>
<h3 id="1-7-JS的注释"><a href="#1-7-JS的注释" class="headerlink" title="1.7 JS的注释"></a>1.7 JS的注释</h3><ul>
<li><p>三种注释：单行注释、多行注释、文档注释</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//我是js单行注释</span><br><br><span class="hljs-comment">/*我是js多行注释*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">文档注释：VSCode中在单独的JS文件中编写才有效，当我们调用函数时就会有提示，快捷键：&quot;/**&quot;，如下：</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 向某人打招呼</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> </span>name 姓名</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>age 年龄</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span>(<span class="hljs-params">name,age</span>)</span>&#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>注意：JS不支持注释嵌套</p>
</li>
</ul>
<h2 id="2-ECMAScript"><a href="#2-ECMAScript" class="headerlink" title="2. ECMAScript"></a>2. ECMAScript</h2><h3 id="2-1-变量和数据类型"><a href="#2-1-变量和数据类型" class="headerlink" title="2.1 变量和数据类型"></a>2.1 变量和数据类型</h3><h4 id="2-1-1-变量"><a href="#2-1-1-变量" class="headerlink" title="2.1.1 变量"></a>2.1.1 变量</h4><ul>
<li><p>作用：记录某一个之后会变化的数据</p>
</li>
<li><p>变量定义</p>
<ul>
<li><p>变量声明（var关键字） + 变量赋值（=）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//声明并且赋值，也可给多个变量声明和赋值</span><br><span class="hljs-keyword">var</span> age=<span class="hljs-number">18</span>;<br><span class="hljs-comment">//先声明再赋值（不推荐），没有初始化值为undefined</span><br><span class="hljs-keyword">var</span> a,b;  <br>a=b=<span class="hljs-number">213</span>;  <br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>变量(标识符)的命名规范（标识符-凡是自己命名的都叫标识符）</p>
<ul>
<li>命名规则（必须遵守）<ul>
<li>第一个字符必须是一个字母、下划线、美元符号，其他字符可以是数字、字母、下划线、美元符号</li>
<li>不能使用关键字和保留字命名</li>
<li>变量严格区分大小写</li>
</ul>
</li>
<li>命名规范（建议遵守）<ul>
<li>多个单词时，驼峰命名：一般小驼峰</li>
<li>= 号两边加上空格</li>
<li>每条语句结束加上分号</li>
<li>变量见名知意</li>
</ul>
</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>变量不声明直接使用会报错</li>
<li>变量有声明但没有赋值，值为undefined（不推荐，一般会给初始值如：0、””、null…）</li>
<li>不使用var声明直接赋值，也可以，但不推荐（对将变量加到window对象上）</li>
</ul>
</li>
<li><p>ES6</p>
</li>
</ul>
<p>常量：整形、实型、字符串、布尔、自定义常量(ES6: const关键字/不能改变)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span> <span class="hljs-number">1.2</span> <span class="hljs-string">&quot;2&quot;</span> <span class="hljs-literal">true</span> <br><span class="hljs-keyword">const</span> name=<span class="hljs-string">&quot;cth&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>预处理(解析)：将所有变量和函数的定义放到所有代码最前面，所以可以先使用再定义变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(a);  <span class="hljs-comment">//undefined</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>ES6变量定义：let 变量名称;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a=<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>注：let定义过的变量重新定义报错(方便查找)，而老版本的var不会</p>
<p>​        let定义的变量不会预解析，必须先定义再使用，否则会报错</p>
<p>补：字面量是具体的值，存储在常量或变量中</p>
<h4 id="2-1-2-数据类型"><a href="#2-1-2-数据类型" class="headerlink" title="2.1.2 数据类型"></a>2.1.2 数据类型</h4><ul>
<li><p>javascript是一门”动态类型”的编程语言</p>
<ul>
<li>javascript中的值都具有特定的数据类型</li>
<li>一个变量可以在上一刻是字符串，下一个是一个数字</li>
</ul>
</li>
<li><p>8种基本数据类型（7种原始类型/基本数据类型和1种复杂类型）</p>
<ul>
<li>number string boolean</li>
<li>undefined null object(引用类型)</li>
<li>BigInt Symbol（后续了解）</li>
</ul>
</li>
<li><p>typoef操作符的使用</p>
<ul>
<li><p>由来：因为ECMAScript的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型</p>
</li>
<li><p>用法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">typeof x 因为是操作符所以中间用空格连接即可</span><br><span class="hljs-comment">typeof(x) 不是一个函数，括号只是代表后面是一个整体，如：(1+2)*3</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">var</span> age = <span class="hljs-number">19</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> age)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span>(age))<br></code></pre></td></tr></table></figure></li>
<li><p>返回以下任意值之一</p>
<ul>
<li>“number”、”string” 、”boolean”、 “undefined” - 未赋值</li>
<li>“object” - 对象或null</li>
<li>“function” - 函数     “symbol”- 符号</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Number类型</strong></p>
<ul>
<li><p>范围：JS所有数值 - 整数和浮点数</p>
</li>
<li><p>除了常规数字，还包括一些 “特殊数值”：Infinity、NaN（了解）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//NAN(not a number)非数值，表示一个错误操作得到的结果</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;123cth&quot;</span>),<span class="hljs-number">3</span>*<span class="hljs-string">&quot;abc&quot;</span>);<br><span class="hljs-comment">//Infinity/-Infinity（无穷大和无穷小，全局对象的属性 window.Infinity）</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> / <span class="hljs-number">0</span>);   <span class="hljs-comment">//Infinity  0/0=NaN</span><br><span class="hljs-built_in">console</span>.log(-<span class="hljs-number">1</span> / <span class="hljs-number">0</span>);  <span class="hljs-comment">//-Infinity</span><br></code></pre></td></tr></table></figure></li>
<li><p>数字的进制表示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//十进制</span><br><span class="hljs-keyword">var</span> num1=<span class="hljs-number">111</span>;<br><span class="hljs-comment">//十六进制</span><br><span class="hljs-keyword">var</span> num2=<span class="hljs-number">0x111</span>;<br><span class="hljs-comment">//八进制</span><br><span class="hljs-keyword">var</span> num3=<span class="hljs-number">0o111</span>;<br><span class="hljs-comment">//二进制</span><br><span class="hljs-keyword">var</span> num4=<span class="hljs-number">0b111</span>;<br><span class="hljs-built_in">console</span>.log(num1,num2,num3,num4);<br></code></pre></td></tr></table></figure></li>
<li><p>数字表示范围</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.MAX_VALUE); <span class="hljs-comment">//最大正数值</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.MIN_VALUE); <span class="hljs-comment">//最小正数值，小于这个数会转化为0</span><br></code></pre></td></tr></table></figure></li>
<li><p>isNaN: 判断是否不是一个数字（NAN），不是数字返回true</p>
</li>
<li><p>注意：不要使用js进行精度要求较高的计算</p>
</li>
</ul>
</li>
<li><p><strong>String类型</strong></p>
<ul>
<li><p>用途：表示一段文本</p>
</li>
<li><p>三种使用方法：单引号””、双引号’’、反引号`（ES6语法）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name=<span class="hljs-string">&quot;kygo&quot;</span><br><span class="hljs-keyword">var</span> name=<span class="hljs-string">&#x27;kygo~&#x27;</span><br><span class="hljs-keyword">var</span> name=<span class="hljs-string">`kygo~~`</span><br><span class="hljs-comment">//反引号,$&#123;变量/表达式&#125;</span><br><span class="hljs-keyword">var</span> msg=<span class="hljs-string">`my name is <span class="hljs-subst">$&#123;name&#125;</span>,age is <span class="hljs-subst">$&#123;<span class="hljs-number">17</span>+<span class="hljs-number">1</span>&#125;</span>`</span><br></code></pre></td></tr></table></figure></li>
<li><p>如果字符串本身使用双引号，那么字符串中可以使用单引号，反之也可</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> desc=<span class="hljs-string">&quot;kygo is &#x27;shuaige&#x27;&quot;</span><br><span class="hljs-keyword">var</span> desc1=<span class="hljs-string">&#x27;kygo is &quot;shuaige&quot;&#x27;</span><br></code></pre></td></tr></table></figure></li>
<li><p>转义字符（了解）</p>
<ul>
<li><p>一些有特殊功能的字符可以通过转移字符的形式放入字符串中</p>
</li>
<li><p>都是斜杠\开头</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">\\ 斜杠<br>\n \t 换行符、制表符<br>\<span class="hljs-string">&#x27; \&quot;  单引号、双引号</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>字符串的属性和方法</p>
<ul>
<li><p>字符串拼接：通过 + 连接</p>
</li>
<li><p>获取字符串长度</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> msg1 = <span class="hljs-string">&quot;my name is&quot;</span><br><span class="hljs-keyword">var</span> msg2 = <span class="hljs-string">&quot;kygo&quot;</span><br><span class="hljs-keyword">var</span> msg3 = msg1 + msg2<br><span class="hljs-keyword">var</span> msg4 = <span class="hljs-string">`my name is <span class="hljs-subst">$&#123;msg2&#125;</span>`</span> <span class="hljs-comment">//推荐</span><br><span class="hljs-built_in">console</span>.log(msg3,msg3.length);<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>Boolean类型</p>
<ul>
<li>作用：用于表示真假</li>
<li>值：真、假 - true/false</li>
</ul>
</li>
</ul>
<ul>
<li><p>Undefined类型</p>
<ul>
<li><p>只有一个值，就是undefined</p>
<ul>
<li>如果只声明变量没有赋值，默认值就是undefined</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>最好在变量定义时进行初始化，而不是只是声明变量</li>
<li>不要把变量显示的赋值为undefined（可以初始化为0、””、null等）</li>
</ul>
</li>
</ul>
</li>
<li><p>Object类型和Null类型</p>
<ul>
<li><p>通常被称为引用类型或复杂类型</p>
</li>
<li><p>作用：表示一组数据，是其他数据的一个集合</p>
</li>
<li><p>表示方法：用花括号{}的方式来表示一个对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj=&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-attr">height</span>: <span class="hljs-number">1.88</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(obj.name);<br></code></pre></td></tr></table></figure></li>
<li><p>Null类型</p>
<ul>
<li>值：只有一个值null</li>
<li>作用：通常用来表示一个对象为空，用来给一个对象进行初始化时，会赋值为null</li>
<li>也属于object类型：使用typeof操作符返回object</li>
</ul>
</li>
<li><p>null和undefined的关系</p>
<ul>
<li><p>undefined通常只有在一个变量声明但未初始化时，默认值是undefined才会用到</p>
</li>
<li><p>不推荐直接给变量赋值为undefined，所以很少主动来使用</p>
</li>
<li><p>null值非常常用，当我们变量准备保存一个对象，而对象不确定时，可以先赋值null</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-1-3-数据类型的转换"><a href="#2-1-3-数据类型的转换" class="headerlink" title="2.1.3 数据类型的转换"></a>2.1.3 数据类型的转换</h4><ul>
<li>String类型的转换<ul>
<li>隐式类型转换：一个字符串和其他类型进行+操作</li>
<li>显示转换：String()函数、toString()方法</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//三种方法：toString()  String()  +&quot;&quot;</span><br><span class="hljs-keyword">var</span> num = <span class="hljs-number">2</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">String</span>(num) + <span class="hljs-string">&quot; 类型：&quot;</span> + <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">String</span>(num));<br><span class="hljs-built_in">console</span>.log(num.toString() + <span class="hljs-string">&quot; 类型：&quot;</span> + <span class="hljs-keyword">typeof</span> num.toString());<br><span class="hljs-built_in">console</span>.log(num + <span class="hljs-string">&quot;&quot;</span> + <span class="hljs-string">&quot; 类型：&quot;</span> + <span class="hljs-keyword">typeof</span>(num + <span class="hljs-string">&quot;&quot;</span>));<br><span class="hljs-comment">/*Result</span><br><span class="hljs-comment">2 类型：string</span><br><span class="hljs-comment">2 类型：string</span><br><span class="hljs-comment">2 类型：string */</span><br><br><span class="hljs-comment">//toString()转换undefined与null类型会报错,toString()可以转换数字进制，在()指定</span><br><span class="hljs-keyword">var</span> num = <span class="hljs-number">7</span><br><span class="hljs-built_in">console</span>.log(num.toString(<span class="hljs-number">2</span>));	<span class="hljs-comment">//进制转换 111</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span>.toString()); <span class="hljs-comment">//报错</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span>.toString());	<span class="hljs-comment">//报错</span><br></code></pre></td></tr></table></figure>



<ul>
<li><p>Number类型的转换</p>
<ul>
<li><p>隐式转换：在算术运算时，通常会将其他类型转成数字类型来运行（除了+运算且一边是字符串）</p>
</li>
<li><p>显示转换：Number()函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//Number()  +  </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> + <span class="hljs-number">0</span>);  <span class="hljs-comment">//+不能转换字符串为数字</span><br><br><span class="hljs-comment">//string转number 如果不是纯数字-&gt; NaN</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;value=&quot;</span> + <span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;123a&quot;</span>) + <span class="hljs-string">&quot; type=&quot;</span> + <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;123a&quot;</span>));<br></code></pre></td></tr></table></figure></li>
<li><p>其他类型转数字的规则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//空、空格字符串/null/false都是0  undefined/非纯数字-&gt;NaN</span><br>console.log(<span class="hljs-string">&quot;false:&quot;</span> + Number(<span class="hljs-keyword">false</span>) + <span class="hljs-string">&quot; 空:&quot;</span> + Number(<span class="hljs-string">&quot; &quot;</span>) + <span class="hljs-string">&quot; null:&quot;</span> + Number(<span class="hljs-keyword">null</span>) <br>            + <span class="hljs-string">&quot; undefined:&quot;</span> + Number(undefined));<br><span class="hljs-comment">//Result</span><br><span class="hljs-keyword">false</span>:<span class="hljs-number">0</span> 空:<span class="hljs-number">0</span> <span class="hljs-keyword">null</span>:<span class="hljs-number">0</span> undefined:NaN<br></code></pre></td></tr></table></figure></li>
<li><p>扩展：parseInt/parseFloat-字符串转数字专用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">parseInt() 和 parseFloat()专门用于转换非纯数字</span><br><span class="hljs-comment">解析到第一个非数值为止  如parseInt(c3px) -&gt;NaN */</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;value=&quot;</span> + <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;123a&quot;</span>) + <span class="hljs-string">&quot; type=&quot;</span> + <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;123a&quot;</span>));<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;value=&quot;</span> + <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;123.123a&quot;</span>) + <span class="hljs-string">&quot; type=&quot;</span> + <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;123a&quot;</span>));<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>Boolean类型的转换  <ul>
<li>通过Boolean()函数 或 隐式转换!!</li>
<li>转换规则：直观上为空的值（0、””、null、undefined和NaN）都转成false</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//Boolean()  !!</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-string">&quot;Kygo&quot;</span>));<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Res: &quot;</span> + !!<span class="hljs-string">&quot;kygo&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>注意：空字符串/0/NaN/null/undefined  -&gt;false</p>
<p>​    </p>
<h3 id="2-2-运算符"><a href="#2-2-运算符" class="headerlink" title="2.2 运算符"></a>2.2 运算符</h3><ul>
<li><p>运算符和运算元</p>
<ul>
<li><p>运算符：计算机最基本的操作就是执行运算，而执行运算就需要使用运算符来操作</p>
</li>
<li><p>运算元</p>
<ul>
<li>运算符应用的对象</li>
<li>一个运算符对应的只有一个运算元叫一元运算符，一个运算符对应两个运算元…</li>
</ul>
</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li><p>功能分：算数运算符/赋值运算符/关系(比较)运算符/逻辑运算符</p>
</li>
<li><p>操作数分：单目/双目/三目运算符</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-2-1-算数运算符"><a href="#2-2-1-算数运算符" class="headerlink" title="2.2.1 算数运算符"></a>2.2.1 算数运算符</h4><ul>
<li>注意<ul>
<li>左结合性(从左到右计算)</li>
<li>NaN和任何运算都是NaN，都会先转换为number再计算(+””除外)</li>
<li>取余操作：m%n=余数  m&gt;n<del>余数  m&lt;n</del>m  n=0~NaN  （结果正负性取决于m）</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//加减乘除、取余、幂(ES7，和Math.pow()函数类似)</span><br>+ - * / % **<br></code></pre></td></tr></table></figure>

<h4 id="2-2-2-赋值运算符"><a href="#2-2-2-赋值运算符" class="headerlink" title="2.2.2 赋值运算符"></a>2.2.2 赋值运算符</h4><ul>
<li>优先级低于算数运算符、右结合性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//最常用的赋值运算符：=</span><br>=   <br><span class="hljs-comment">//链式赋值，从右往左计算</span><br><span class="hljs-keyword">var</span> num=num1=num2=<span class="hljs-number">1</span>+<span class="hljs-number">1</span><br><span class="hljs-comment">//原地修改：对一个变量做运算，并将新的结果存储到同一个变量中</span><br>+=  -=  *=  /=  %= **=<br></code></pre></td></tr></table></figure>

<h4 id="2-2-3-自增自减运算符"><a href="#2-2-3-自增自减运算符" class="headerlink" title="2.2.3 自增自减运算符"></a>2.2.3 自增自减运算符</h4><ul>
<li>注意<ul>
<li>自增/自减只能应用于变量，应用于数值（比如5++）会报错</li>
<li>尽量单独出现，不推荐在表达式中写（阅读性较差）</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//n++和++n区别：n++表达式值为n, ++n为n+1</span><br>++  --  <br><span class="hljs-comment">//四种实现方法</span><br><span class="hljs-keyword">var</span> Index=<span class="hljs-number">0</span><br>index=index+<span class="hljs-number">1</span><br>index+=<span class="hljs-number">1</span><br>index++<br>++index<br></code></pre></td></tr></table></figure>

<h4 id="2-2-4-关系-比较-运算符"><a href="#2-2-4-关系-比较-运算符" class="headerlink" title="2.2.4 关系(比较)运算符"></a>2.2.4 关系(比较)运算符</h4><ul>
<li>注意：<ul>
<li>关系运算符返回布尔值：关系成立就返回true，不成立就返回false</li>
<li>任何非数值类型，先转换为数值类型再判断(字符串和字符串比较除外)</li>
<li>参与比较的都是字符串，比较对应的Unicode编码(一位一位比较Unicode)</li>
<li>任何数据和NaN比较，返回值都是false</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//左结合性,前四个优先级高后四</span><br>&gt;  &lt;  &gt;=  &lt;=  ==  !=  ===  !==  <br> <br><span class="hljs-comment">/*== 和 ===区别：===只有取值和数据类型完全相同才会返回true（完全相等）</span><br><span class="hljs-comment">比较不同类型时，==两侧的值会先转成数字再进行比较（null除外）</span><br><span class="hljs-comment">开发建议都使用===、!==来降低犯错的可能性</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1&quot;</span> == <span class="hljs-literal">true</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1&quot;</span> === <span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">//三种特殊比较 （了解）</span><br><span class="hljs-literal">null</span>==<span class="hljs-number">0</span> <span class="hljs-literal">false</span> <br><span class="hljs-literal">undefined</span>==<span class="hljs-number">0</span> <span class="hljs-literal">false</span>  <br><span class="hljs-literal">null</span>==<span class="hljs-literal">undefined</span> <span class="hljs-literal">true</span> 	<span class="hljs-comment">//null衍生的</span><br><br><span class="hljs-comment">//判断是否是NaN，NaN==NaN(不能这样判断)  </span><br><span class="hljs-built_in">isNaN</span>()  <br></code></pre></td></tr></table></figure>



<h4 id="2-2-5-逻辑运算符"><a href="#2-2-5-逻辑运算符" class="headerlink" title="2.2.5 逻辑运算符"></a>2.2.5 逻辑运算符</h4><ul>
<li><p>三个逻辑运算符：&amp;&amp;(与)、 ||(或)、 !(非)</p>
</li>
<li><p>作用：将多个表达式或值放到一起来获得最终值</p>
</li>
<li><p>规则</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&amp;&amp;  	<span class="hljs-comment">//逻辑与 一假则假  </span><br>||  	<span class="hljs-comment">//逻辑或 一真则真  </span><br>!   	<span class="hljs-comment">//逻辑非 取反</span><br></code></pre></td></tr></table></figure></li>
<li><p>注意</p>
<ul>
<li>左结合性 、&amp;&amp;优先级高于||  </li>
<li>不是boolean先转换为boolean再计算</li>
</ul>
</li>
</ul>
<ul>
<li><p>短路现象：&amp;&amp;只要前面是假，后面的语句不会执行(检查)，||相反</p>
</li>
<li><p><strong>逻辑与/或的本质</strong></p>
<ul>
<li><p>逻辑或的本质（返回第一个真值运算元的初始值，不存在真值就返回最后一个）</p>
<ul>
<li>从左到右依次计算操作数，处理每一个运算元时都将其转成布尔值</li>
<li>一旦遇到某个运算元结果是true则停止计算，返回这个运算元的<strong>初始值</strong></li>
<li>如果所有运算元都被计算过（转换结果是true），则返回最后一个</li>
</ul>
</li>
<li><p>逻辑与的本质：返回第一个假值的运算元初始值，不存在返回最后一个</p>
</li>
<li><p>注意：返回的值是运算元的初始形式，不会转化为Boolean类型</p>
</li>
<li><p>总结：返回第一个能够决定表达式真假的运算元，如果没有则返回最后一个</p>
</li>
</ul>
</li>
<li><p>逻辑与、或在开发中的应用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//逻辑或-获取第一个有值的结果</span><br><span class="hljs-keyword">var</span> info=<span class="hljs-string">&quot;123&quot;</span><br><span class="hljs-keyword">var</span> message=info||<span class="hljs-string">&quot;默认值&quot;</span><br><br><span class="hljs-comment">//逻辑与-对一些对象中的方法进行有值判断</span><br><span class="hljs-keyword">var</span> obj=&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Kygo&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-function"><span class="hljs-title">sayHello</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;hello&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">//调用sayHello函数</span><br>obj &amp;&amp; obj.sayHello &amp;&amp; obj.sayHello()<br></code></pre></td></tr></table></figure></li>
<li><p>逻辑非 !</p>
<ul>
<li>接收一个参数，先将操作数转为布尔类型，再返回取反的值</li>
<li>应用：两个非运算符!!用来将某个值转为布尔类型</li>
</ul>
</li>
</ul>
<ul>
<li><p>其他运算符</p>
<ul>
<li><p>三元运算符：条件表达式 ? 结果A : 结果B  true-返回A</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//常见用法：如果info有值就使用info，否则给个默认值</span><br>info=&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span>&#125;<br><span class="hljs-keyword">var</span> obj = info ? info : &#123;&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>逗号运算符：简化代码/优先级最低/左结合性/运算结果是最后一个表达式结果</p>
</li>
<li><p>单目运算符：typeof/+/ -  +可用于隐式类型转换为number  </p>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-流程控制"><a href="#2-3-流程控制" class="headerlink" title="2.3 流程控制"></a>2.3 流程控制</h3><ul>
<li>流程控制基本知识<ul>
<li>程序的执行顺序：顺序结构、选择(分支)结构、循环结构</li>
<li>代码块{}<ul>
<li>多行代码的集合，通过一个花括号{}放到一起</li>
<li>可以通过流程控制语句来指定如何执行一个代码块</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-3-1-选择结构（分支语句）"><a href="#2-3-1-选择结构（分支语句）" class="headerlink" title="2.3.1 选择结构（分支语句）"></a>2.3.1 选择结构（分支语句）</h4><ul>
<li><p>if 分支语句、if else多分支语句、if  else if … else多分支语句</p>
</li>
<li><p>switch分支语句</p>
<ul>
<li>通过判断表达式结果（或变量）是否等于case语句的常量</li>
<li>if可以做值的范围判断，switch语句只能做值的相等判断（全等===）</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>如果代码块中语句只有一行，花括号{}可以省略</li>
<li>()括号内的表达式会自动转成布尔类型来判断是否执行代码块</li>
</ul>
</li>
<li><p>if/switch如何选择：对区间判断用if  对固定值判断用switch（能用if就用if）</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//只有一个会执行非布尔先转布尔再判断 </span><br><span class="hljs-keyword">if</span> / <span class="hljs-keyword">if</span> <span class="hljs-keyword">else</span> / <span class="hljs-keyword">if</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ...  <span class="hljs-keyword">else</span> <br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">switch语句中至少有一个case代码块和一个可选的default代码块</span><br><span class="hljs-comment">case穿透问题：一条case语句执行完后会自动指定下一条，使用break解决</span><br><span class="hljs-comment">break关键字：结束整个switch语句，一般在每个case后都加</span><br><span class="hljs-comment">case判断的是===  ()和case的表达式可以是常量/变量/表达式</span><br><span class="hljs-comment">default可以省略且不一定在最后（一般放在最后）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">switch</span>(表达式/变量)&#123;<br>  <span class="hljs-keyword">case</span> 常量<span class="hljs-number">1</span>: <br>    <span class="hljs-comment">//语句一</span><br>    <span class="hljs-keyword">break</span> <br>  <span class="hljs-keyword">case</span>... <br>  <span class="hljs-attr">default</span>: <br>    <span class="hljs-comment">//语句n</span><br>&#125;  <br></code></pre></td></tr></table></figure>



<h4 id="2-3-2-循环结构（循环语句）"><a href="#2-3-2-循环结构（循环语句）" class="headerlink" title="2.3.2 循环结构（循环语句）"></a>2.3.2 循环结构（循环语句）</h4><ul>
<li><p>重复运行同一段代码的方法，对列表进行循环操作也叫遍历或迭代</p>
</li>
<li><p>三种循环方式：while、do-while、for</p>
</li>
<li><p>注意</p>
<ul>
<li>尽量避免条件一直成立，造成死循环</li>
<li>for中用let定义的i只能在for中使用,变量作用域-let定义的变量在{}中有局部作用域</li>
<li>循环是可以嵌套的</li>
</ul>
</li>
<li><p>循环控制-break/continue关键字</p>
<ul>
<li>作用：终止循环的执行，可以是某次循环或直接结束整个循环</li>
<li>break：跳出当前循环</li>
<li>continue：本次循环不再执行continue后面的代码，跳入下次循环</li>
</ul>
</li>
<li><p>使用场景：在不知道具体循环次数的时候用while（for循环更加灵活，能用for就用for）</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//执行顺序：先执行begin(只执行一次)，然后进行迭代（先判断condition，成立再执行body，然后step...）</span><br><span class="hljs-keyword">for</span>(begin;condition;step)&#123;<br>  <span class="hljs-comment">//循环代码块</span><br>&#125;<br><span class="hljs-comment">//条件成立执行代码块，不成立不执行</span><br><span class="hljs-keyword">while</span>(循环条件)&#123;<br>  <span class="hljs-comment">//循环代码块</span><br>&#125;<br><span class="hljs-comment">//不管条件成不成立，都会先执行一次循环  </span><br><span class="hljs-keyword">do</span>&#123;<br>	<span class="hljs-comment">//循环代码块 </span><br>&#125;<span class="hljs-keyword">while</span>(循环条件)<br></code></pre></td></tr></table></figure>

<h3 id="2-4-函数"><a href="#2-4-函数" class="headerlink" title="2.4 函数"></a>2.4 函数</h3><h4 id="2-4-1-认识函数"><a href="#2-4-1-认识函数" class="headerlink" title="2.4.1 认识函数"></a>2.4.1 认识函数</h4><ul>
<li><p>程序中的foo、bar、baz</p>
<ul>
<li>作用：经常用作函数、变量、文件的名称，本身没有特殊意义</li>
</ul>
</li>
<li><p>什么是函数</p>
<ul>
<li>已经学习过的函数：alert、prompt、consloe.log、Number…</li>
<li>作用：用于封装一段可以随时反复执行的代码块</li>
</ul>
</li>
</ul>
<h4 id="2-4-2-函数的使用步骤"><a href="#2-4-2-函数的使用步骤" class="headerlink" title="2.4.2 函数的使用步骤"></a>2.4.2 函数的使用步骤</h4><ul>
<li><p>声明函数(定义函数) ：是对某些功能的封装过程</p>
</li>
<li><p>调用函数：调用自己封装好的某个函数，也可调用默认提供的或第三方库定义好的函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//使用关键字function声明函数，()调用函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params">形参列表</span>)</span>&#123;... <span class="hljs-keyword">return</span>;&#125;  <br>fun();<br></code></pre></td></tr></table></figure></li>
<li><p>注意</p>
<ul>
<li>函数命名规则和变量一样，定义完函数是不会执行的，必须通过()调用才会执行</li>
<li>形参和返回值可有可无，无返回值默认返回undefined</li>
<li>return语句和break语句一样后面不要跟代码，永远不会执行</li>
</ul>
</li>
<li><p>函数的参数</p>
<ul>
<li>形参(parameter)：定义函数时，小括号中的参数，用来接收参数用的，在函数内部作为变量使用</li>
<li>实参(argument)：调用函数时，小括号中的参数，用来把数据传递到函数内部用的</li>
</ul>
</li>
<li><p>函数的返回值</p>
<ul>
<li>使用return关键字来返回结果</li>
<li>一旦在函数中执行return，当前函数会终止</li>
<li>没有使用return或return后什么也不跟，都是返回undefined</li>
</ul>
</li>
<li><p>arguments变量(JS高级学习)</p>
<ul>
<li>由来：arguments对象是所有(非箭头)函数中都可用的局部变量</li>
<li>作用：该对象中保存所有传递给函数的实参（从0位置开始，依次存放）</li>
<li>注意：arguments变量类型是object(array-like)，不是一个数组</li>
</ul>
</li>
</ul>
<h4 id="2-4-3-函数的递归"><a href="#2-4-3-函数的递归" class="headerlink" title="2.4.3 函数的递归"></a>2.4.3 函数的递归</h4><ul>
<li><p>作用：将一个复杂的任务，转换成可以重复执行的相同任务</p>
</li>
<li><p>函数自己调用自己的过程就叫做递归-Recursion（必须有结束条件，否则会无限调用，造成报错）</p>
</li>
<li><p>练习</p>
<ul>
<li>用递归实现一个自己的幂函数pow</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//x的n次幂: pow(x,n)=x * pow(x,n-1)</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pow</span>(<span class="hljs-params">x,n</span>)</span>&#123;<br>  <span class="hljs-keyword">if</span>(n === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x<br>  <span class="hljs-keyword">return</span> x * pow(x,n-<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>实现斐波那契数列（使用递归和不使用递归都实现一编）<ul>
<li>某一个数是前两个数的和：1 1 2 3 5 8 13 21… （第一第二个数都是1）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-4-4-函数作用域"><a href="#2-4-4-函数作用域" class="headerlink" title="2.4.4 函数作用域"></a>2.4.4 函数作用域</h4><ul>
<li><p>什么是作用域：变量在某一个范围内可以使用</p>
</li>
<li><p>由来：在JS(ES5之前-var定义的)中没有块级作用域的概念，但是函数可以定义自己的作用域</p>
</li>
<li><p>函数作用域定义：函数作用域表示在函数内部定义的变量，只有在函数内部才能访问到</p>
</li>
<li><p>外部变量、局部变量</p>
<ul>
<li>局部变量：定义在函数内部的变量</li>
<li>外部变量：定义在函数外部的变量（在a函数外，但可能在其他函数中，叫做a的外部变量）</li>
</ul>
</li>
<li><p>全局变量</p>
<ul>
<li>范围：在所有函数外部(script中)声明的变量</li>
<li>全局变量在任何函数中都是可见的</li>
<li>通过var声明的全局变量会在window对象上添加一个属性</li>
</ul>
</li>
<li><p>函数中的变量访问顺序</p>
<ul>
<li>优先访问自己函数中的变量=&gt;没有找到就依次往外部找</li>
<li>外部函数里也没有=&gt;window对象=&gt;没有定义报错</li>
</ul>
</li>
<li><p>后续学习的：块级作用域、作用域链、变量提升、AO VO GO</p>
</li>
</ul>
<h4 id="2-4-5-函数表达式"><a href="#2-4-5-函数表达式" class="headerlink" title="2.4.5 函数表达式"></a>2.4.5 函数表达式</h4><ul>
<li><p>函数的另外一种定义方式 - 函数表达式</p>
<ul>
<li>函数也是引用数据类型(对象)，所以可以保存到变量中</li>
<li>function 后面一般省略函数名</li>
<li>无论怎么创建函数，函数都是一个特殊的值，值类型是一个对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;...&#125;<br>foo()<br></code></pre></td></tr></table></figure></li>
<li><p>函数声明 VS 函数表达式</p>
<ul>
<li><p>语法不同：函数声明是单独的语句声明函数，函数表达式是在表达式或另外的语句中创建函数</p>
</li>
<li><p>JS内部创建函数的时机不同</p>
<ul>
<li><p>函数表达式是代码执行到的时候函数才被创建，函数仅从那一刻开始可用</p>
</li>
<li><p>当JS准备运行脚本时，会在脚本寻找全局函数声明，并创建这些函数，然后再去运行脚本</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">foo()  <span class="hljs-comment">//可以成功调用foo函数，因为JS引擎在执行js脚本前会提前创建全局声明的函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;...&#125;<br><br>bar()  <span class="hljs-comment">//报错，找不到bar，因为是使用函数表达式创建函数，属于表达式，不会提前创建函数</span><br><span class="hljs-keyword">var</span> bar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;...&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>开发选择：首先考虑函数声明语法，因为它更加灵活 - 可以在声明函数前就调用这些函数</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-4-6-头等函数"><a href="#2-4-6-头等函数" class="headerlink" title="2.4.6 头等函数"></a>2.4.6 头等函数</h4><ul>
<li><p>定义：是指在程序设计语言中，函数被当做头等公民</p>
<ul>
<li>函数可以作为<strong>别的函数的参数、返回值、赋值给变量或存储在数据结构中</strong></li>
</ul>
</li>
<li><p>函数式编程 - 函数作为头等公民的编程方式</p>
</li>
<li><p>头等函数的体现</p>
<ul>
<li><p>函数可以被赋值给变量 - 函数表达式写法就是它的一种体现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;...&#125;<br><span class="hljs-keyword">var</span> bar = foo<br>bar()<br></code></pre></td></tr></table></figure></li>
<li><p>函数作为另外一个函数的参数、返回值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>)</span>&#123;...&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">fn</span>)</span>&#123;<br>  fn()<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baz</span>(<span class="hljs-params"></span>)</span>&#123;...&#125;<br>  <span class="hljs-comment">//函数作为返回值</span><br>  <span class="hljs-keyword">return</span> baz<br>&#125;<br><span class="hljs-comment">//函数作为参数传递</span><br>foo(bar)<br></code></pre></td></tr></table></figure></li>
<li><p>将函数存储在另外一个数据结构中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span>,<br>  <span class="hljs-attr">running</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;...&#125;<br>&#125;<br>foo.running()<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="2-4-7-回调函数"><a href="#2-4-7-回调函数" class="headerlink" title="2.4.7 回调函数"></a>2.4.7 回调函数</h4><ul>
<li><p>函数回调的理解（Callback Function）</p>
<ul>
<li><p>函数作为参数传递到另外一个函数内部，通过参数去调用函数称为函数的回调</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>)</span>&#123;...&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">fn</span>)</span>&#123;<br>  <span class="hljs-comment">//通过fn去调用bar的过程称为函数的回调</span><br>  fn()<br>&#125;<br>foo(bar)<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>函数回调的案例</p>
<ul>
<li><p>需求：通过URL向服务器发送网络请求，需要花较长时间拿到返回的结果</p>
</li>
<li><p>因为拿到结果需要一定的时间，所以我们可以传入一个回调函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span>(<span class="hljs-params">url,callback</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;通过URL向服务器发送网络请求，需要花较长时间拿到返回的结果&quot;</span>)<br>  <span class="hljs-comment">//假如拿到了结果</span><br>  <span class="hljs-keyword">var</span> resultList = [<span class="hljs-string">&quot;JS&quot;</span>, <span class="hljs-string">&quot;Vue&quot;</span>, <span class="hljs-string">&quot;React&quot;</span>]<br>  callback(resultList)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleResult</span>(<span class="hljs-params">res</span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;在handleResult中拿到的结果:&quot;</span>,res)&#125;<br><span class="hljs-comment">//传入函数，拿到结果</span><br>request(<span class="hljs-string">&quot;http://www.baidu.com/abc/getResult&quot;</span>, handleResult)<br><br><span class="hljs-comment">/*-----------代码重构--------------*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span>(<span class="hljs-params">url,callback</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;通过URL向服务器发送网络请求，需要花较长时间拿到返回的结果&quot;</span>)<br>  <span class="hljs-comment">//假如拿到了结果</span><br>  <span class="hljs-keyword">var</span> resultList = [<span class="hljs-string">&quot;JS&quot;</span>, <span class="hljs-string">&quot;Vue&quot;</span>, <span class="hljs-string">&quot;React&quot;</span>]<br>  callback(resultList)<br>&#125;<br><span class="hljs-comment">//传入的函数是没有名字的 - 匿名函数</span><br>request(<span class="hljs-string">&quot;http://www.baidu.com/abc/getResult&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;在handleResult中拿到的结果:&quot;</span>,res<br>&#125;)<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>高阶函数和匿名函数</p>
<ul>
<li>高阶函数至少满足两个条件<ul>
<li>接受一个或多个函数作为输入</li>
<li>输出一个函数</li>
</ul>
</li>
<li><strong>匿名函数</strong><ul>
<li>如果在传入一个函数时，我们没有指定这个变量的名称或通过函数表达式创建函数就称为匿名函数</li>
<li>应用：匿名函数经常作为其他函数的参数或返回值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-4-8-立即执行函数"><a href="#2-4-8-立即执行函数" class="headerlink" title="2.4.8 立即执行函数"></a>2.4.8 立即执行函数</h4><ul>
<li><p>什么是立即执行函数</p>
<ul>
<li><p>专业名字：IIFE - Immediately-Invoked Function Expression（立即调用函数表达式）</p>
</li>
<li><p>含义：函数定义完后立即执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//匿名函数 + ()</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是一个立即执行函数&quot;</span>)<br>&#125;)()<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>立即执行函数的作用</p>
<ul>
<li>立即执行函数中定义的变量有自己的作用域 - 函数作用域</li>
<li>会创建一个函数作用域，可以避免外界访问或修改内部变量</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li><p>场景一：ES6之前的协同开发就是使用这种方式-防止全局变量的命名冲突</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//应用一: 有自己的函数作用域,可以防止变量的命名冲突</span><br><span class="hljs-keyword">var</span> kygoModule = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">//定义要对外暴露的对象</span><br>  <span class="hljs-keyword">var</span> kygoModule = &#123;&#125;<br>  <br>  <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;kygo&quot;</span><br>  <span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span><br>  <br>  <span class="hljs-comment">//将外界需要用到的变量和函数添加到对象上</span><br>  kygoModule.age = age<br>  <span class="hljs-keyword">return</span> kygoModule<br>&#125;)()<br><span class="hljs-comment">//只能通过暴露的对象访问</span><br><span class="hljs-built_in">console</span>.log(kygoModule.age)<br></code></pre></td></tr></table></figure></li>
<li><p>场景二：获取所有按钮的监听点击</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//应用二: 遍历按钮并依次添加点击事件,要求打印出第n个按钮被点击了</span><br><span class="hljs-comment">//问题: 每次点击任意按钮都会打印出: 第4个按钮被点击了</span><br><span class="hljs-keyword">var</span> Eles = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;.btn&quot;</span>)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  Eles[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`我是第<span class="hljs-subst">$&#123;i + <span class="hljs-number">1</span>&#125;</span>个按钮`</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//重构代码: 使用立即执行函数的函数作用域解决问题</span><br><span class="hljs-comment">//也可以直接使用let定义i就可解决问题</span><br><span class="hljs-keyword">var</span> Eles = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;.btn&quot;</span>)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  <span class="hljs-comment">//这里光光使用立即执行函数包裹是不行的,需要每次传递i进入立即函数作用域中</span><br>  (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>)</span>&#123;<br>    Eles[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`我是第<span class="hljs-subst">$&#123;j + <span class="hljs-number">1</span>&#125;</span>个按钮`</span>)<br>  &#125;<br>  &#125;)(i)<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>立即执行函数的其他写法</p>
<ul>
<li><p>立即执行函数必须是一个表达式（整体），不能是一个函数声明</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//错误的写法，这种情况()前面的会被当做函数声明，因为不是一个整体</span><br><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;...&#125;()<br><span class="hljs-comment">//正确写法，()前面会被当做一个表达式</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;...&#125;)()<br><span class="hljs-comment">//其他写法(了解即可)</span><br>+<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;...&#125;()<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="2-5-对象"><a href="#2-5-对象" class="headerlink" title="2.5 对象"></a>2.5 对象</h3><h4 id="2-5-1-对象的基本使用"><a href="#2-5-1-对象的基本使用" class="headerlink" title="2.5.1 对象的基本使用"></a>2.5.1 对象的基本使用</h4><ul>
<li><p>为什么需要对象类型？</p>
<ul>
<li>基本数据类型可以存储一些简单的值，但是当需要存储比如：一辆车的信息，一个人的信息</li>
<li>对象类型就是将一类事物的特征和行为组织到了一起</li>
</ul>
</li>
<li><p>对象类型的语法和使用</p>
<ul>
<li><p>使用{Key: Value}  键值对的方式来表示对象</p>
</li>
<li><p>键值对可以是：属性、方法</p>
</li>
<li><p>Key是字符串（我们一般省略引号不写）</p>
</li>
<li><p>value可以是任意类型：基本数据类型、函数、对象等</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//创建一个对象</span><br><span class="hljs-keyword">var</span> foo = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span>,<br>  <span class="hljs-attr">running</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;I am Running!&quot;</span>)<br>  &#125;,<br>  <span class="hljs-string">&quot;my friend&quot;</span>: &#123;  <span class="hljs-comment">//不推荐这样写，只是为了验证key是字符串</span><br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobe&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>函数和方法</p>
<ul>
<li>Function  通过function默认定义的结构就是函数</li>
<li>Method  将一个函数放到对象中作为对象的一个属性，那么这个函数称为方法</li>
</ul>
</li>
</ul>
<h4 id="2-5-2-对象的创建方式"><a href="#2-5-2-对象的创建方式" class="headerlink" title="2.5.2 对象的创建方式"></a>2.5.2 对象的创建方式</h4><ul>
<li><p>创建对象的三种方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//方式一: 对象字面量创建</span><br><span class="hljs-keyword">var</span> foo = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span><br>&#125;<br><br><span class="hljs-comment">//方式二: 通过new Obj创建</span><br><span class="hljs-keyword">var</span> foo1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()<br>foo1.name = <span class="hljs-string">&quot;kygo1&quot;</span><br><br><span class="hljs-comment">//方式三: 通过其他类创建</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Bar</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><span class="hljs-keyword">var</span> foo2 = <span class="hljs-keyword">new</span> Bar()<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-5-3-对象的常见操作"><a href="#2-5-3-对象的常见操作" class="headerlink" title="2.5.3 对象的常见操作"></a>2.5.3 对象的常见操作</h4><ul>
<li><p>对象属性、方法的增删改查</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = &#123;&#125;<br><span class="hljs-comment">//增加</span><br>foo.name = <span class="hljs-string">&quot;kygo&quot;</span><br>foo.age = <span class="hljs-number">18</span><br>foo.bar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><br><span class="hljs-comment">//删除 delete操作符</span><br><span class="hljs-keyword">delete</span> foo.age<br><br><span class="hljs-comment">//修改（没有属性增加，有属性修改）</span><br>foo.name = <span class="hljs-string">&quot;kygo1&quot;</span><br><br><span class="hljs-comment">//查询</span><br><span class="hljs-built_in">console</span>.log(foo.name)<br><br><span class="hljs-comment">//删除对象属性: </span><br><span class="hljs-keyword">delete</span> obj.name;<br></code></pre></td></tr></table></figure></li>
<li><p>对象的方括号使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//操作对象属性另一种方式:对象[&quot;属性名&quot;]=属性值 (属性名可不遵守规则)</span><br><span class="hljs-keyword">var</span> baz = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span>,<br>  <span class="hljs-string">&quot;my friend&quot;</span>: <span class="hljs-string">&quot;kobe&quot;</span>,<br>  <span class="hljs-string">&quot;eating something&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(baz[<span class="hljs-string">&quot;my friend&quot;</span>])<br><span class="hljs-comment">//将字符串保存在变量中,通过[]使用属性、调用方法</span><br><span class="hljs-keyword">var</span> nameKey = <span class="hljs-string">&quot;name&quot;</span>,eatKey = <span class="hljs-string">&quot;eating something&quot;</span><br><span class="hljs-built_in">console</span>.log(baz[nameKey])<br>baz[eatKey]()<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-5-4-对象的遍历"><a href="#2-5-4-对象的遍历" class="headerlink" title="2.5.4 对象的遍历"></a>2.5.4 对象的遍历</h4><ul>
<li><p>两种遍历数组的方式</p>
<ul>
<li>遍历/迭代：获取对象的所有属性和方法</li>
<li>Object.key(obj) 会返回一个对象的属性名组成的数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-attr">height</span>: <span class="hljs-number">1.88</span><br>&#125;<br><br><span class="hljs-comment">//普通for循环遍历: 先拿到对象的属性名和属性个数-object.keys</span><br><span class="hljs-keyword">var</span> items = <span class="hljs-built_in">Object</span>.keys(foo)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; items.length; i++) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;items[i]&#125;</span>: <span class="hljs-subst">$&#123;foo[items[i]]&#125;</span>`</span>)<br>&#125;<br><br><span class="hljs-comment">//for...in遍历数组,item会依次拿到每个属性名</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> foo)&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;item&#125;</span>: <span class="hljs-subst">$&#123;foo[item]&#125;</span>`</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-5-5-JS内存分配"><a href="#2-5-5-JS内存分配" class="headerlink" title="2.5.5 JS内存分配"></a>2.5.5 JS内存分配</h4><ul>
<li><p>堆内存heap和栈内存stack</p>
<ul>
<li>程序是需要加载到内存中执行的，而内存可以分为堆内存和栈内存</li>
<li>原始类型占据的空间是在栈内存中分配的</li>
<li>对象类型占据的空间是在堆内存中分配的</li>
</ul>
</li>
<li><p>值类型和引用类型</p>
<ul>
<li><p>值类型：原始数据类型在变量中保存的是值本身</p>
</li>
<li><p>引用类型：对象类型在变量中保存的是对象的 “引用”</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//bar存储在栈内存中，保存的是值类型</span><br><span class="hljs-keyword">var</span> bar = <span class="hljs-string">&quot;kygo&quot;</span><br><br><span class="hljs-comment">//foo对象是分为两个地方存储</span><br><span class="hljs-comment">//&#123;...&#125;对象存储在堆内存中: 假如内存地址是0X110</span><br><span class="hljs-comment">//在栈内存中会存储对象的引用: foo = 0X110 来指向对象</span><br><span class="hljs-keyword">var</span> foo = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>一些现象的解释</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//现象一： 引用类型的比较</span><br><span class="hljs-keyword">var</span> foo = &#123;&#125;<br><span class="hljs-keyword">var</span> foo1 = &#123;&#125;<br><span class="hljs-built_in">console</span>.log(foo === foo1)<span class="hljs-comment">//false</span><br><br><span class="hljs-comment">//现象二： 引用类型的赋值</span><br><span class="hljs-keyword">var</span> bar = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span>,<br>  <span class="hljs-attr">friend</span>: &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobe&quot;</span><br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> friend = bar.friend<br>friend.name = <span class="hljs-string">&quot;kobe1&quot;</span><br><span class="hljs-built_in">console</span>.log(bar.friend.name)<span class="hljs-comment">//kobe1</span><br><br><span class="hljs-comment">//现象三： 值传递</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-number">213</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baz</span>(<span class="hljs-params">arg</span>) </span>&#123;<br>  arg = <span class="hljs-number">318</span><br>&#125;<br>baz(b)<br><span class="hljs-built_in">console</span>.log(b)<span class="hljs-comment">//213</span><br><br><span class="hljs-comment">//现象四： 引用传递，但是在函数中创建了一个新对象，没有对传入对象进行修改</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo2</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>  obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobe&quot;</span><br>  &#125;<br>&#125;<br>foo2(obj)<br><span class="hljs-built_in">console</span>.log(obj)<span class="hljs-comment">//&quot;kygo&quot;</span><br><br><span class="hljs-comment">//现象五： 引用传递，但是对传入的对象进行了修改</span><br><span class="hljs-keyword">var</span> obj1 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo3</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>  obj.name = <span class="hljs-string">&quot;kobe&quot;</span><br>&#125;<br>foo3(obj1)<br><span class="hljs-built_in">console</span>.log(obj1)<span class="hljs-comment">//&quot;kobe&quot;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-5-6-函数中的this指向"><a href="#2-5-6-函数中的this指向" class="headerlink" title="2.5.6 函数中的this指向"></a>2.5.6 函数中的this指向</h4><ul>
<li><p>什么是this</p>
<ul>
<li>函数中有一个this的变量，大多数情况下this会指向一个对象</li>
</ul>
</li>
<li><p>this的指向</p>
<ul>
<li><p>以默认的方式调用一个函数，this指向window</p>
</li>
<li><p>通过对象调用，this指向调用的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//普通函数声明的this</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>&#125; <br>foo() <span class="hljs-comment">//指向window</span><br><br><span class="hljs-comment">//方法的调用（通过对象调用）</span><br><span class="hljs-keyword">var</span> bar = &#123;<br>  <span class="hljs-attr">baz</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>  &#125;,<br>  <span class="hljs-attr">friend</span>: &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobe&quot;</span>,<br>    <span class="hljs-attr">running</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">//谁调用this就指向谁</span><br><span class="hljs-built_in">console</span>.log(bar.baz())  <span class="hljs-comment">//指向bar对象</span><br>bar.friend.running()  <span class="hljs-comment">//指向bar.friend对象</span><br><br><br><span class="hljs-comment">//考验题目一</span><br><span class="hljs-keyword">var</span> baz = bar.baz<br>baz() <span class="hljs-comment">//  this指向window对象</span><br><span class="hljs-comment">//考验题目二</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>&#125;<br><span class="hljs-keyword">var</span> foo1 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span>,<br>  <span class="hljs-attr">fun</span>: fun<br>&#125;<br>foo1.fun()  <span class="hljs-comment">//this指向foo1</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>this的应用</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kygo&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-attr">running</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">//没有this的情况</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;foo.name&#125;</span> is running! age is <span class="hljs-subst">$&#123;foo.age&#125;</span>`</span>)<br>    <span class="hljs-comment">//使用this</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> is running! age is <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.age&#125;</span>`</span>)<br>  &#125;<br>&#125;<br>foo.running()<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-5-7-构造函数和类"><a href="#2-5-7-构造函数和类" class="headerlink" title="2.5.7 构造函数和类"></a>2.5.7 构造函数和类</h4><ul>
<li><p>创建一系列相似对象的方式</p>
<ul>
<li>在开发中需要创建一系列的相似对象，如一系列的学生对象</li>
<li>一种方法是直接创建一系列对象，但是这样重复代码太多</li>
<li>第二种方法是封装一个函数用于创建对象 - 工厂函数</li>
<li>第三种方法就是使用构造函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//方式一: 挨个创建</span><br><span class="hljs-keyword">var</span> obj1 = &#123;&#125;<br><span class="hljs-keyword">var</span> obj2 = &#123;&#125;<br><br><span class="hljs-comment">//方式二: 工厂函数创建对象，缺点-打印的对象都是Object类型</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">name, age, heigt</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> obj = &#123;&#125;<br>  obj.name = name<br>  obj.age = age<br>  obj.height = heigt<br>  <span class="hljs-keyword">return</span> obj<br>&#125;<br><span class="hljs-keyword">var</span> foo1 = foo(<span class="hljs-string">&quot;kygo&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">1.88</span>)<br><span class="hljs-keyword">var</span> foo2 = foo(<span class="hljs-string">&quot;kobe&quot;</span>, <span class="hljs-number">30</span>, <span class="hljs-number">1.98</span>)<br><span class="hljs-built_in">console</span>.log(foo1, foo2)<br></code></pre></td></tr></table></figure></li>
<li><p>认识构造函数</p>
<ul>
<li>构造函数也称为构造器constructor，是我们在创建对象时会调用的函数</li>
<li>在其他编程语言中，构造函数其实是类中的一个方法，称之为构造方法</li>
<li>JS中的构造函数有点不太一样，构造函数扮演了其他语言中类的角色</li>
<li>ES5之前，都是通过function来声明一个构造函数(类)，之后通过new关键字来对其调用</li>
<li>ES6之后，JS可以向别的语言一样，通过class来声明一个类</li>
<li>类和对象的关系：类是一类事物的统称(如：水果)，而对象是具体的体现（如：苹果）</li>
</ul>
</li>
</ul>
<ul>
<li><p>类(ES5)</p>
<ul>
<li>JS中的类的表示形式就是构造函数，构造函数===类</li>
<li>构造函数<ul>
<li>构造函数也是一个普通的函数，表现形式和其他函数没有任何区别</li>
<li>如果一个普通函数使用new操作符来调用了，这个函数就称为构造函数</li>
</ul>
</li>
<li>函数被new操作符调用了，会执行以下操作（了解）<ul>
<li>在内存中创建一个新的空对象</li>
<li>这个对象内部的[prototype]属性会被赋值为该构造函数的[prototype]属性</li>
<li>构造函数内部的this，会指向创建出来的新对象</li>
<li>执行函数的内部代码</li>
<li>如果构造函数没有返回非空对象，则返回创建出来的新对象</li>
</ul>
</li>
<li>构造函数的补充<ul>
<li>构造函数的名称：使用大驼峰</li>
</ul>
</li>
</ul>
</li>
<li><p>创建对象的方案 - 类</p>
<ul>
<li><p>构造函数可以确保创建的对象是Person类型的(实际是constructor属性)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//构造函数创建对象</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age, height</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name<br>  <span class="hljs-built_in">this</span>.age = age<br>  <span class="hljs-built_in">this</span>.height = height<br>  <span class="hljs-built_in">this</span>.running = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`my name is <span class="hljs-subst">$&#123;name&#125;</span>`</span>)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;kygo&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">1.88</span>)<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;kobe&quot;</span>, <span class="hljs-number">30</span>, <span class="hljs-number">1.98</span>)<br><span class="hljs-built_in">console</span>.log(person1, person2)<br></code></pre></td></tr></table></figure></li>
<li><p>构造函数的其他特征（JS高级）</p>
<ul>
<li>原型、原型链、实现继承的方案</li>
<li>ES6中的类、继承的实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-5-8-全局对象window"><a href="#2-5-8-全局对象window" class="headerlink" title="2.5.8 全局对象window"></a>2.5.8 全局对象window</h4><ul>
<li><p>由来</p>
<ul>
<li>浏览器中有一个全局对象window</li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li><p>查找变量最终会查找到window上</p>
</li>
<li><p>将一些浏览器全局提供给我们的变量、函数、对象，放在window对象上</p>
</li>
<li><p>使用var定义的变量会被默认添加到window上面</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.console === <span class="hljs-built_in">console</span>)  <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.document === <span class="hljs-built_in">document</span>)  <span class="hljs-comment">//true</span><br><br><span class="hljs-keyword">var</span> foo = <span class="hljs-number">213</span>, bar = &#123;&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.foo, <span class="hljs-built_in">window</span>.bar === bar) <span class="hljs-comment">//213</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="2-5-9-函数也是对象"><a href="#2-5-9-函数也是对象" class="headerlink" title="2.5.9 函数也是对象"></a>2.5.9 函数也是对象</h4><h3 id="2-6-数组"><a href="#2-6-数组" class="headerlink" title="2.6 数组"></a>2.6 数组</h3><ul>
<li>数组的创建方式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//对象创建</span><br><span class="hljs-keyword">let</span> arr=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(size);<br><span class="hljs-comment">//构造函数创建</span><br><span class="hljs-keyword">let</span> arr=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(data1,data2...);  <span class="hljs-comment">//空/data/size</span><br><span class="hljs-comment">//字面量创建(一般使用)</span><br><span class="hljs-keyword">let</span> arr=[data1,data2...];  <span class="hljs-comment">//可为空数组</span><br></code></pre></td></tr></table></figure>



<ul>
<li><p>数组的注意点</p>
<ul>
<li><p>数组对应索引没有存储数据时默认为undefined</p>
</li>
<li><p>访问数组不存在的索引不会报错，返回undefined</p>
</li>
<li><p>数组存储空间不足时会自动扩容</p>
</li>
<li><p>数组可以存储不同的数据类型</p>
</li>
<li><p>数组分配的存储空间不一定是连续的(因为存储的数据类型不同)</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>数组的遍历</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arr.length /arr.forEach()<br></code></pre></td></tr></table></figure>



<ul>
<li>数组解构赋值 </li>
</ul>
<p>ES6新增赋值方法，左边右边格式必须相同，才能完全解构</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//左右边个数可以不一样，会赋值undefined或者多余值丢弃</span><br><span class="hljs-keyword">let</span> [a,b,c]=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-keyword">let</span> [a,b=<span class="hljs-number">666</span>,c=<span class="hljs-number">1</span>]=[<span class="hljs-number">1</span>] <span class="hljs-comment">//可以给左边的值指定默认值 </span><br><br><span class="hljs-comment">//ES6扩展运算符：在最后一个字母前加... 可以将多余数据打包</span><br><span class="hljs-keyword">let</span> [a,...b]=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] <br></code></pre></td></tr></table></figure>

<p>​    </p>
<ul>
<li>数组增删改查</li>
</ul>
<p>改：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//参数1:开始索引 2:删除元素个数 3:增添元素</span><br>arr.splice(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;t&quot;</span>...) <br></code></pre></td></tr></table></figure>

<p> 增：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//数组后添加 一个或多个参数 返回新增后长度 </span><br>arr.push(<span class="hljs-string">&quot;cth&quot;</span>,<span class="hljs-string">&quot;wcr&quot;</span>...)<br><span class="hljs-comment">//数组前添加 一个或多个参数 返回长度</span><br>arr.unshift(<span class="hljs-string">&quot;cth&quot;</span>) <br></code></pre></td></tr></table></figure>

<p>删</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arr.pop() <span class="hljs-comment">//数组最后元素删除 返回删除数据</span><br><br>arr.shift()  <span class="hljs-comment">//数组最前元素删除 返回删除数据</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">splice方法:</span><br><span class="hljs-comment">可用于：替换元素，增加元素，删除元素</span><br><span class="hljs-comment">参数：索引位置、删除个数(可为0)，其他参数(增加的元素)</span><br><span class="hljs-comment">前两个参数必须</span><br><span class="hljs-comment">*/</span><br>arr.splice(m,n) <span class="hljs-comment">//从索引为m的元素删除n个元素</span><br></code></pre></td></tr></table></figure>



<ul>
<li>数组常用方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//清空数组</span><br>arr=[];  arr.length=<span class="hljs-number">0</span>;  arr.splice(<span class="hljs-number">0</span>,arr.length);<br><br><span class="hljs-comment">//数组转换为字符串</span><br>arr.toString();  <br><span class="hljs-comment">//转换成指定格式字符串,将+(参数)作为元素连接符</span><br>arr.join(<span class="hljs-string">&quot;+&quot;</span>)  <br><br><span class="hljs-comment">//数组拼接</span><br>arr1.concat(arr2);<br><span class="hljs-comment">/*arr2拼接到arr1后面，返回新数组，原数组不影响</span><br><span class="hljs-comment">扩展运算符在等号右边：表示将数组所有元素解开，放到所在位置*/</span><br><span class="hljs-keyword">let</span> arr=[...arr1,...arr2];<span class="hljs-comment">//推荐使用</span><br><br><span class="hljs-comment">//数组反转,会修改原有数组</span><br>arr.reverse()  <br><br><span class="hljs-comment">//截取指定范围内容,包头不包尾(m,n为头和尾的索引) </span><br>arr.slice(m,n)  <br><br><span class="hljs-comment">/*查找元素位置,m-查找的元素 n-什么位置开始查找</span><br><span class="hljs-comment">左到右找，返回第一个出现的索引(找不到返回-1)*/</span><br>arr.indexOf(m,n);  <br><span class="hljs-comment">//从右到左找,其他一样</span><br>lastIndexOf(m,n)  <br><br><br><span class="hljs-comment">//是否包含某个元素,返回-1</span><br>indexOf/lastIndexOf  <br><span class="hljs-comment">//ES6,参数是要查找的元素(返回true/false，用这个更好)</span><br>arr.includes();<br><br><span class="hljs-comment">//设置数组所有元素值为指定数据(这里是0)</span><br>arr.fill(<span class="hljs-number">0</span>)  <br></code></pre></td></tr></table></figure>



<ul>
<li>二维数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr=[ [],[]... ];<br></code></pre></td></tr></table></figure>



<p>​       </p>
<h3 id="2-8-ES6类和对象"><a href="#2-8-ES6类和对象" class="headerlink" title="2.8 ES6类和对象"></a>2.8 ES6类和对象</h3><p>ES6开始，提供class关键字定义类</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;cth&quot;</span>;age=<span class="hljs-number">21</span>;<span class="hljs-function"><span class="hljs-title">say</span>(<span class="hljs-params"></span>)</span>&#123;...&#125;;  <span class="hljs-comment">//直接添加实例属性和方法即可，不用加this</span><br>    <span class="hljs-keyword">static</span> num=<span class="hljs-number">666</span>;  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span>&#123;...&#125;; <span class="hljs-comment">//静态属性和方法, 通过类名调用</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">myname,myage</span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=myname....     <br>	&#125;<br>&#125;<br><span class="hljs-comment">//当创建对象时,自动调用constructor()&#123;&#125;构造方法</span><br><span class="hljs-keyword">let</span> per=<span class="hljs-keyword">new</span> Person(“cth”,<span class="hljs-number">21</span>)  <br></code></pre></td></tr></table></figure>

<p>注意点：直接添加实例属性，大部分浏览器不支持</p>
<p>​                在ES6标准中添加实例属性需要在constructor中添加</p>
<p>​                静态属性大部分浏览器不支持static定义(类名.属性定义)</p>
<p>​                支持static定义静态方法</p>
<p>在class中直接添加的方法会添加到对象的原型中</p>
<p>如果想在class上添加方法，必须也写到constructor中</p>
<p>总结：class写在constructor中的方法都会保存在当前对象中</p>
<p>写在constructor外面的方法都会保存在原型对象</p>
<p>(ES6之前有两种给原型添加属性/方法-动态添加或自定义对象添加)</p>
<p>通过class定义类，当往原型中添加属性和方法时</p>
<p>不能自定义原型对象添加，只能动态的给原型添加属性和方法</p>
<p><strong>ES6继承</strong></p>
<p>​    extends 关键字  super(参数) 通过super调用父类构造函数并传递参数</p>
<p><strong>获取对象类型</strong></p>
<p>​    想知道对象通过什么构造函数创建的，一个对象的真实类型</p>
<p>​    通过 对象.constructor.name  获取构造函数名称</p>
<ul>
<li><strong>instanceof</strong> 关键字</li>
</ul>
<p>​    用于判断”对象”是否是指定构造函数(类)的“实例”</p>
<p>​     per instanceof person  //判断per是否是person实例</p>
<p>​     注意：只要构造函数的原型对象出现在实例对象的原型链中都会返回true</p>
<p>​     (所有对象都是Object的实例)</p>
<ul>
<li>isPrototypeOf属性</li>
</ul>
<p>​    用于判断一个对象是否是另一个对象的原型</p>
<p>​     Person.prototype.isPrototypeOf(p);  //返回true，是p的原型对象</p>
<p>​     注意点：只要原型对象是在实例对象的原型链中的，都会返回true</p>
<ul>
<li><p>in 判断对象属性</p>
<p> “name” in per  //判断per对象类中或其原型中是否有name属性</p>
</li>
</ul>
<p>​           只要有就会返回true</p>
<p>   per.hasOwnProperty(“name”);  //只会在对象中查找，不会去查找原型</p>
<p>-2021.4.4  </p>
<ul>
<li>对象增删改查</li>
</ul>
<p>​    可以通过[“”]来操作属性和方法</p>
<p>增：p.name=”cth” p[“name”]=”cth”</p>
<p>​      p.say=function(){…}  p[“say”]=function(){…}</p>
<p>​    删：delete p.name;  delete p[“name”];  delete p.say;  delete p[“say”];</p>
<p>​    改：p.name / p[“name”]=”wcr”  p.say/p[“say”]=function(){} </p>
<p>​    查：就是调用属性和方法 p.name/p[“name”]  p.say()/p<a href="">“say”</a></p>
<ul>
<li>对象的遍历</li>
</ul>
<p>就是依次取出对象中所有的属性和方法</p>
<p>​    for(let key in obj){}  //将对象所有属性方法取出赋值给key这个变量</p>
<p>​    通过obj[key]取出 不能通过obj.key</p>
<ul>
<li>对象解构赋值</li>
</ul>
<p>对象结构赋值- {}</p>
<p>​     obj={name: “cth” , age=21};</p>
<p>​     let {name,age}=obj;  //除了{}和数组[]不一样,也可使用…</p>
<p>​     不同：左边的变量名称必须和对象属性名称一致才能解构出来</p>
<p>​     应用场景：可以直接将对象和数组通过实参传给函数</p>
<p>​          在形参处用结构赋值接收</p>
<p>​     let obj={name: “cth”,age=21}  </p>
<p>​     function say({name,age}){console.log(name,age)}  say(obj);</p>
<ul>
<li>深拷贝和浅拷贝</li>
</ul>
<p>深拷贝-修改新变量的值不会影响原变量值-基本数据类型都是(栈内存)</p>
<p>浅拷贝-修改新变量值会影响原来值-引用类型都是浅拷贝(堆内存)</p>
<p>对象的深拷贝：</p>
<p>Object.assign(p2,p1);  //将p1对象的属性和方法拷贝到对象p2中</p>
<p>当p1对象中有引用类型时，以上方法将不能实现深拷贝</p>
<p>自定义深拷贝函数实现</p>
<ul>
<li>this总结</li>
</ul>
<p>*以函数形式调用时，this永远都是window</p>
<p>*以方法的形式调用时，this是调用方法的对象</p>
<p>*以构造函数的形式调用时，this是新创建的对象</p>
<p>*使用call和apply调用时，this是指定的那个对象</p>
<h3 id="2-9-其他"><a href="#2-9-其他" class="headerlink" title="2.9 其他"></a>2.9 其他</h3><h4 id="2-9-1-数组高级API"><a href="#2-9-1-数组高级API" class="headerlink" title="2.9.1 数组高级API"></a>2.9.1 数组高级API</h4><p>​    ****遍历数组****：传统方法、for-in循环(数组也是对象)</p>
<p>​          for(let key in arr){arr[key];}</p>
<p>​    不推荐for-in遍历数组，因为其是专门遍历对象的(对象属性无序)</p>
<p>​    推荐利用ES6中的 for-of 循环来遍历数组</p>
<p>​       for(let value of arr){console.log(value)};</p>
<p>​    还可以使用Array对象的forEach方法来遍历数组</p>
<p>​       arr.forEach(function(currentValue,currentIndex,currentArray){…})</p>
<p>​       传入一个函数，自动传入参数：数组值，索引，当前数组</p>
<p>​    <em><strong>*数组查找*</strong></em></p>
<p>​      findIndex方法：定制版的indexOf，找到返回索引，找不到返回-1</p>
<p>​             arr.findIndex(function(,,){}) //传入一个函数，三个参数</p>
<p>​      find方法：find方法返回找到的元素(也接收三个参数)</p>
<p>​      (注意：判断特定筛选条件时/return true;)</p>
<p>​    <em><strong>*数组过滤和数组映射*</strong></em></p>
<p>​      filter方法：将满足条件的元素添加到一个新数组中</p>
<p>​           (例: if(value%2){return true} 返回数组-所有偶数封装的)</p>
<p>​      map方法：</p>
<p>​           将满足条件的元素映射到一个新的数组中</p>
<p>​           (映射：创建一个相同大小的数组,将所有元素值设置undefined</p>
<p>​           满足条件的元素将undefined覆盖,不满足的还是undefined)</p>
<p>​      注意:方法都是传递一个函数为参数，且这个函数传递三个参数value/index/arr</p>
<p>​                                   -2021.4.5</p>
<p>​    <em><strong>*数组排序*</strong></em></p>
<p>​    arr.sort();  //接收一个函数，函数又可以接收两个参数</p>
<p>​        arr.sort(function(a,b){  //默认升序</p>
<p>  if(a&gt;b){return 1}  //return -1 就是降序</p>
<p>  else if(a&lt;b){return -1;}  //return 1就是降序</p>
<p>  else{return 0;}  //这个不用变</p>
<p>})</p>
<p>​        规律：如果数组是字母可以以上方法</p>
<p>​           如果是数值类型，那么升序返回a-b,降序返回b-a</p>
<p>​           arr.sort(function(a,b){return a-b})  //升序，b-a降序</p>
<p>​           对字符串长短进行排序：如 [“qwe”,”a”,”qwer”…]</p>
<p>​           arr.sort(function(str1,str2){return str1.length-str2.length})</p>
<p>​           //以上是升序，降序相反  (字符串相当于一个数组可以length) </p>
<h4 id="2-9-2-字符串常用方法"><a href="#2-9-2-字符串常用方法" class="headerlink" title="2.9.2 字符串常用方法"></a>2.9.2 字符串常用方法</h4><p>在底层字符串是以字符数组的形式保存的  如 [‘h’,’e’,’l’,’l’,’o’]</p>
<p>可以像操作数组一样str[index]，也可以使用数组的大部分方法</p>
<p>​    *获取字符串长度  str.length</p>
<p>​    *获取某个字符   str[index]  str.charAt(index) </p>
<p>​       区别：str[] 只有高级浏览器才支持，而charAt()没有兼容性问题</p>
<p>​    *字符串查找  indexOf / lastIndexOf / includes</p>
<p>​       和数组一样，但要加” ”  如：str.indexOf(“c”) //检查字符”c”</p>
<p>​    *字符串的拼接 concat / +</p>
<p>​       str1 + str2  str1.concat(str2)  //推荐使用+</p>
<p>​    *获取子串  slice / substring / substr</p>
<p>​       substring(a,b)和slice()功能一样，包前不包后，推荐substring()</p>
<p>​       substr(a,b)  //从索引为a开始，截取b个字符</p>
<p>   Other</p>
<p>​     *字符串切割</p>
<p>​       str.split(“-”)  //利用-来切割字符串，和arr.join(“-”);相反</p>
<p>​     *判断是否以指定字符串开头ES6</p>
<p>​       str.startsWith(“www”); //判断是否以”www”开头</p>
<p>​     *判断是否以指定字符串结尾ES6  str.endsWith(“”);</p>
<p>​     *字符串模板ES6</p>
<p>​       let str=<code>;  //除了”” ‘’ 定义字符串，还可以</code></p>
<p>​       作用：当html代码需要保存在字符串中，用``不用+拼接</p>
<p>​          console.log(“我的名字”+cth+”,年龄”+age);</p>
<p>​         =&gt;console.log(<code>我的名字$&#123;cth&#125;,年龄$&#123;age&#125;</code>);  </p>
<p>​            2021.4.6</p>
<h4 id="2-9-3-基本包装类型"><a href="#2-9-3-基本包装类型" class="headerlink" title="2.9.3 基本包装类型"></a>2.9.3 基本包装类型</h4><p>​    基本数据类型变量 没有属性和方法</p>
<p>​    对象类型 有属性和方法</p>
<p>​       能访问基本数据类型的属性和方法，因为运行时系统将其包装为对象类型</p>
<p>​       String() Number() Boolean()</p>
<h4 id="2-9-4-三大对象"><a href="#2-9-4-三大对象" class="headerlink" title="2.9.4 三大对象"></a>2.9.4 三大对象</h4><p>​    JS提供的三种自带对象：本地对象/内置对象/宿主对象</p>
<p>​    宿主：JS运行环境</p>
<p>​       本地对象：与宿主无关，ES标准定义的类(构造函数)</p>
<p>​            使用时需手动new创建</p>
<p>​            如：Boolean Number String Array Function Object Date RegExp等</p>
<p>​       内置对象：与宿主无关，ES已经帮我们创建好的对象</p>
<p>​            无需手动new  如：Global(全局对象不用关注) Math JSON</p>
<p>​       宿主对象：浏览器提供的对象</p>
<p>​            Window Document等</p>
<p>​            所有BOM和DOM都属于宿主对象</p>
<h4 id="2-9-5-Math"><a href="#2-9-5-Math" class="headerlink" title="2.9.5 Math"></a>2.9.5 Math</h4><p>​     属于一个工具类，不用创建对象  Math.E  Math.PI</p>
<p>​    Math.floor() 向下取整  Math.ceil() 向上取整(小数部分有值进1)</p>
<div class="code-wrapper"><pre><code class="hljs"> Math.round() 四舍五入  Math.abs() 绝对值
</code></pre></div>
<p>​    Math.random随机数  产生 [0,1)随机数</p>
<p>-2021.4.7</p>
<h2 id="3-DOM"><a href="#3-DOM" class="headerlink" title="3. DOM"></a>3. DOM</h2><h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h3><p>​    属于宿主对象,包含了window和document  (浏览器提供)</p>
<p>​      window: 全局对象，代表浏览器打开的一个窗口</p>
<p>每个窗口都是一个window对象 </p>
<p>​      document: window的一个属性，这个属性是一个对象</p>
<p>​           代表当前窗口的整个网页，可以操作整个网页的所有内容</p>
<p>​      DOM：一套操作HTML标签的API(接口/方法/属性)</p>
<p>​         文档模型对象(document Object Model)</p>
<p>​         学习DOM就是学习通过document对象操作网页内容</p>
<h3 id="3-2-Dom元素获取"><a href="#3-2-Dom元素获取" class="headerlink" title="3.2 Dom元素获取"></a>3.2 Dom元素获取</h3><p>​    HTML标签也称DOM元素/使用document不用加window</p>
<p>​      通过id获取    document.getElementById(“box”)</p>
<p>​               (id只有一个，会将其包装为对象返回)</p>
<p>​      通过class获取   document.getElementsByCalssName(“”)</p>
<p>​               (返回伪数组)</p>
<p>​      通过name获取  document.getElementsByName(“test”)</p>
<p>​               (表单中的name,返回伪数组)</p>
<p>​      通过标签名获取  document.getElementsByTagName(“div”) 多个</p>
<p>​      <em><strong>*重点：*</strong></em></p>
<p>​      通过选择器获取  document.querySelector(“#box”) //所有选择器都可</p>
<p>​               (只会返回根据指定选择器找到的第一个元素)</p>
<p>​      通过选择器获取  document.querySelectorAll(“”)  //返回数组(多个)</p>
<p>​      ****其他方式****：(以下皆是属性)</p>
<p>​          *获取所有子元素：对象.children  (返回伪数组)</p>
<p>​                   对象.childNodes </p>
<p>​           区别：children获取所有子元素/childNodes获取所有节点</p>
<p>​              节点中包含了文本结点和元素(标签)  </p>
<p>​          *获取第一个子节点/子元素：.firstChild/.firstElementChild</p>
<p>​            最后一个子节点/子元素：.lastChild/.lastElementChild</p>
<p>​          *通过子元素获取父元素/父节点</p>
<p>​            子元素.parentElement  子元素.parentNode</p>
<p>​          *获取相邻上一个节点/元素 .previousSibling/.previousElementSibling  </p>
<p>​           获取相邻下一个节点/元素 .nextSibling/.nextElementSibling</p>
<p>​          *获取html根标签、body标签、所有标签</p>
<p>​           document.body  document.documentElement</p>
<p>​           document.all</p>
<h3 id="3-3-节点增删改查"><a href="#3-3-节点增删改查" class="headerlink" title="3.3 节点增删改查"></a>3.3 节点增删改查</h3><p>​      创建节点  document.createElement(“span”) 创建并返回节点对象</p>
<p>​           createTextNode(“text”) //创建文本结点并返回</p>
<p>​      添加节点  父元素.appendChild(obj)  将元素obj添加到父元素最后</p>
<p>​      插入节点  父元素.insertBefore(obj1,obj2) 将obj1添加到父元素中obj2前面</p>
<p>​      替换结点  父元素.replaceChild()(obj1,obj2)  obj1替换obj2</p>
<p>​      删除节点  节点.parentNode.removeChild(节点) //通过父元素删除指定子元素</p>
<p>​           //只能通过父元素删除，不能自己删除自己</p>
<p>​      克隆节点  obj.cloneNode()  //克隆节点obj,默认不会克隆子元素</p>
<p>克隆其包含所有子元素(指定参数true)</p>
<h3 id="3-4-属性增删改查"><a href="#3-4-属性增删改查" class="headerlink" title="3.4 属性增删改查"></a>3.4 属性增删改查</h3><p>​     无论通过document创建还是查询的标签，系统都会将元素包装成一个对象返回给我们，系统包装这个对象时，会自动将元素的属性都包装到这个对象中</p>
<p>​      所以只要拿到对象就可以拿到标签属性，操作标签属性。</p>
<p>​      获取元素属性  obj.属性名  obj.getAttribute(“属性名”)-可以获取自定义属性</p>
<p>​             //区别：通过obj.属性名无法获取到自定义属性的取值</p>
<p>​      修改元素属性  obj.属性名= ”新值” obj.setAttribute(“属性名”,”新值”) </p>
<p>//区别和获取元素属性一样</p>
<p>​      新增元素属性  obj.setAttribute(“属性名”,”新值”) </p>
<p>​             //只有一个方法新增，属性不存在就新增，存在就修改</p>
<p>​      删除元素属性  obj.属性名=”” (空)  obj.removeArribute(“属性名”) </p>
<p>​             //removeArribute不仅可以清空自带属性，还可以清空自定义</p>
<h3 id="3-5-操作元素内容和样式"><a href="#3-5-操作元素内容和样式" class="headerlink" title="3.5 操作元素内容和样式"></a>3.5 操作元素内容和样式</h3><ul>
<li><strong>操作元素内容</strong></li>
</ul>
<p>​    获取元素内容：.innerHTML  .innerText  .textContent (三个属性都可获取)</p>
<p>​            区别：innerHTML包含标签，其他两个不包含标签</p>
<p>​               innerHTML和textContent不会去除两端空格(innerText会)</p>
<p>​      设置元素内容：通过上面三个属性设置 如：obj.innerHTML=””…</p>
<p>​             通过三种方式设置新的内容都会覆盖原有内容</p>
<p>​            区别：通过innerHTML设置，如果包含标签，会转换为标签添加</p>
<p>​               另外两种方式不会转换，会当成字符串直接设置</p>
<ul>
<li><strong>操作元素样式</strong></li>
</ul>
<p>​    设置元素样式  obj.className=”” //动态设置class属性内容，从而修改样式</p>
<p>​             通过style属性：obj.style.backgroundColor=”pink”</p>
<p>​             //注意：css中通过-连接的都改为驼峰命名</p>
<p>​                 通过style添加的样式都是行内样式</p>
<p>​    获取元素样式  obj.style //只能获取行内样式值，css设置的值获取不到</p>
<p>​             let obj1= window.getComputedStyle(obj);  obj1.width</p>
<p>​             //返回一个对象，保存了css设置的样式和属性值</p>
<h3 id="3-6-事件和事件绑定"><a href="#3-6-事件和事件绑定" class="headerlink" title="3.6 事件和事件绑定"></a>3.6 事件和事件绑定</h3><p>用户和浏览器的交互行为-事件  如：点击 移入/移出</p>
<p>所有HTML标签都可以添加事件</p>
<p>​      元素.事件名称=function(){};  //事件触发时自动执行函数</p>
<p>​      单击事件：btn.onclick=function(){alert(…);}</p>
<p>​      注意：如果给元素添加了和系统同名事件，不会覆盖系统添加的事件</p>
<p>​         如果想覆盖，在function(){return false;}</p>
<p> <em><strong>*事件*</strong></em></p>
<p>​      *添加事件的三种方式   </p>
<p>​       Way1：oBtn.onclick=function(){…}  </p>
<p>//注意点：给同一元素多次添加相同事件后面的会覆盖前面的</p>
<p>​       Way2：oBtn.addEventListener(“click”,function(){…})  </p>
<p> //事件名称不加on,事件不会覆盖,IE9以上</p>
<p>​       Way3：oBtn.attachEvent(“onclick”,function(){…});</p>
<p>//事件名称加on,不会覆盖,只支持低级浏览器</p>
<p>​      *事件对象event</p>
<p>​       当注册事件被触发时，系统就会自动创建事件对象</p>
<p>​       oBtn.onclick=function(event){…}  //回调函数里传递的形参就是事件对象</p>
<p>​       注意点：低级浏览器不支持 兼容：event=event||window.event;</p>
<p>​       event.preventDefault()  //阻止默认行为(以前的return false 企业开发推荐)</p>
<p>​      *事件冒泡和捕获</p>
<p>​       事件执行的三个阶段：</p>
<p>​       First：捕获阶段(从外向内的传递事件)</p>
<p>​          父元素捕获到事件-&gt;子元素捕获到事件</p>
<p>​       Second：当前目标阶段(执行回调函数)  -&gt;触发回调函数</p>
<p>​       Third：冒泡的阶段(从内向外的传递事件)</p>
<p>​          子元素抛出事件-&gt;父元素抛出事件</p>
<p>​       注意：三个阶段只有两个会被同时执行</p>
<p>​          要么捕获和当前,要么当前和冒泡</p>
<p>​       Why: JS处理事件的历史问题,W3C将两种方式都纳入标准</p>
<p>​      How设置事件到底是捕获还是冒泡?</p>
<p>​         只能通过addEventlistener方法,接收三个参数</p>
<p>​         (事件名称,回调函数,false冒泡/true捕获)</p>
<p>​         注意：通过onXXX和attachEvent 方式添加的事件都是冒泡</p>
<p>​      事件冒泡的阻止：event.stopPropagation() //只支持高级浏览器IE9以上</p>
<p>​              event.cancelBubble=true;  //支持低浏览器</p>
<p>  <em><strong>*移入移出事件*</strong></em></p>
<p>​      移入：onmouseover/onmouseenter  例:odiv.onmouseover=function(){…}</p>
<p>​         (初学者为了避免位置的bug，建议使用onmouseenter)</p>
<p>​      移出：onmouseout/onmouseleave  (建议leave)</p>
<p>​      移动：onmousemove</p>
<p>​      两种移入移除事件的区别：</p>
<p>​        onmouseover和onmouseenter</p>
<p>​          over移入到子元素,父元素移入事件也会被触发/enter不会</p>
<p>​        onmouseout和onmouseleave</p>
<p>​          out移出子元素,父元素移出事件也会被触发/leave不会</p>
<p>​      </p>
<p>​      事件对象的属性：</p>
<p>​        event.offsetX/offsetY clientX/clientY pageX/pageY screenX/screenY</p>
<p>​        offsetX/offsetY  事件触发相对于当前元素自身的位置</p>
<p>​        clientX/clientY  事件触发相对于浏览器可视区域的位置</p>
<p>​               (可视区域是不包括滚动条滚动出去的范围)</p>
<p>​        pageX/pageY  事件触发相对于整个网页的位置(包括滚动出去的范围)</p>
<p>​        (注意: 没有滚动条时,client和page一样,但page不兼容IE9以下)</p>
<p>​        screenX/screenY 事件触发相对于显示器的位置(用不上,了解即可)</p>
<p>表单事件</p>
<p>​     表单验证-value属性拿到input值</p>
<p>​     如果想要不触发默认事件，如a链接/表单提交,那么return false即可</p>
<p>​     表单事件：</p>
<p>​         监听input获取焦点  oInput.onfocus()=function(){}</p>
<p>​         监听input失去焦点  onblur</p>
<p>​         监听input内容改变  onchange  //只有表单失去焦点才会监听改变</p>
<p>​                   oninput  //实时获取数据,IE9及以上才能使用</p>
<p>(通过代码oText.value=””给input数据，不会触发oninput事件)</p>
<p>​     补充：默认不可用-添加disabled属性</p>
<p>​        在JS中如果HTML标签的属性名和取值一样,那么JS会返回false/true</p>
<p>​        例：oSubmit.disable=true  //使按钮不可用</p>
<h3 id="3-7-定时器"><a href="#3-7-定时器" class="headerlink" title="3.7 定时器"></a>3.7 定时器</h3><p>​    *重复执行的定时器(window可省略)</p>
<p>​      创建：window.setInterval(function(){…},1000); </p>
<p>//参数：一个函数，一个毫秒值</p>
<p>​              每隔一段时间(第二个参数)，执行函数(第一个参数)</p>
<p>​      销毁：let id=window.setInterval(…);  clearInterval(id);</p>
<p>​         //创建定时器时会返回一个标识，用于销毁使用</p>
<p>​      *只执行一次的定时器  </p>
<p>​       创建：window.setTimeout(function(){…},1000) </p>
<p>//1000毫秒执行一次函数</p>
<p>​       销毁：let id=window.setTimeout(…);  clearTimeout(id);</p>
<p>​                              2021.4.10  </p>
<p>注意：谷歌浏览器默认情况下不允许自动播放音乐，</p>
<p>只有用户和网页交互后才可以播放音乐。</p>
<p>​    解决方案：让用户和网页交互后再播放  调用audio的play方法</p>
<p>​                              2021.4.13</p>
<h3 id="3-8-闭包"><a href="#3-8-闭包" class="headerlink" title="3.8 闭包"></a>3.8 闭包</h3><p>​      *什么是闭包：闭包是一种特殊的函数</p>
<p>​      *如何生成一个闭包：</p>
<p>​        当一个内部函数引用了外部函数的数据(变量/函数)时,内部函数就是闭包</p>
<p>​        所以只要满足”是函数嵌套”、”内部函数引用外部函数数据”</p>
<p>​      *闭包特点：</p>
<p>​        只要闭包还在使用外部函数的数据, 那么外部的数据就一直不会被释放</p>
<p>​        也就是说可以延长外部函数数据的生命周期</p>
<p>​      *闭包注意点</p>
<p>​    当不需要使用闭包时,要手动将闭包设置为null,否则会出现内存泄漏                         </p>
<p>​    <em><strong>*循环索引同步*</strong></em></p>
<p>​      默认情况下,代码从上至下执行,var定义的变量(除函数中)都是全局变量</p>
<p>​      循环索引同步和闭包的结合使用：利用立即执行函数+闭包</p>
<p>for( var i=0;i&lt;bun.length;i++){</p>
<p> let btn=btn[i]; </p>
<p> (function(index){  //立即执行函数和闭包实现循环索引同步</p>
<p> btn.onclick()=function(){ console.log(index);}</p>
<p>})(i);</p>
<p>}  //正常直接绑定事件，每个按钮输出的都是最后一个i</p>
<p>循环()里面var是全局变量，let定义是局部变量</p>
<p>let定义时每次执行完循环体都会重新定义一个i</p>
<p>​      ES6中由于{}是块级作用域(let),在块级作用域中定义了函数</p>
<p>​      且在函数中使用了块级作用域let定义的变量(数据)，那么这个函数就是闭包</p>
<p>​                                                                  2021.4.19</p>
<h3 id="3-9-日期对象Date"><a href="#3-9-日期对象Date" class="headerlink" title="3.9 日期对象Date"></a>3.9 日期对象Date</h3><p>​      *获取当前时间</p>
<p>​      let date = new Date();  //封装代码执行的当前时间</p>
<p>​      *获取当前时间距1970.1.1(世界标准时间)起的毫秒</p>
<p>​      Date.now()  date.valueOf()  //静态方法和对象方法,其他都一样</p>
<p>​      *创建指定时间</p>
<p>​      new Date(“月/日/年(或)年-月-日  时:分:秒”);</p>
<p>new Date(2000,2,18,1,1,1) //这种方式月份从0开始</p>
<p>​      *获取指定时间的年月日时分秒</p>
<p>​      getFullYear()  getMonth()  getDate()  getDay()    </p>
<p>年    月(0-11)   日(1-31)  周(0-6)     </p>
<p>​      getHours()  getMinutes()  getSeconds()  getMilliseconds()</p>
<p>​       时(0-23)   分(0-59)    秒(0-59)   毫秒(0-999)</p>
<p>​      (注意：除了月份现在仍然是0-11,其他都不是)</p>
<p>​      *时间格式化</p>
<p>​      <code>$&#123;time.getFullYear()&#125;-$&#123;time.getMonth()+1&#125;-$&#123;...&#125; $&#123;...&#125;:$&#123;...&#125;:$&#123;...&#125;</code></p>
<p>​      *时间差的计算   </p>
<p>​      let time=new Date(“– ::”);  let time1=new Date(“– ::”);</p>
<p>​      let difftime=time1-time  //可以直接将时间对象作计算</p>
<p>​      (相当于 time1.valueOf()-time.valueOf()  ****毫秒****值相减)</p>
<p>​      总秒数/每一天秒数  day=parseInt(difftime/1000/(24<em>60</em>60)); </p>
<p>总秒数/小时秒数%24  hour=parseInt(difftime/1000/(60*60)%24);  </p>
<p>​      总秒数/分钟秒数%60  minutes=parseInt(difftime/1000/60%60);</p>
<p>​      总秒数%60      second=difftime/1000%60;</p>
<h3 id="3-10-正则表达式"><a href="#3-10-正则表达式" class="headerlink" title="3.10 正则表达式"></a>3.10 正则表达式</h3><p>​      *正则表达式是对字符串操作的一种逻辑公式</p>
<p>​      *作用：在字符串”查找”是否包含指定子串</p>
<p>​         从字符串中”提取”指定子串</p>
<p>​         对字符串中指定的内容进行”替换”</p>
<p>​      字符串查找: indexOf/lastIndexOf/includes </p>
<p>​      提取: substr/substring  替换: replace</p>
<p>​      *first 利用正则表达式匹配(查找)</p>
<p>​       创建正则表达式对象-&gt;指定匹配规则(构造函数中指定规则)</p>
<p>​        let reg=new RegExp(“a”);  //RegExp(“a”,”i”);不区分大小写</p>
<p>​       -&gt;利用test方法进行匹配</p>
<p>​        reg.test(str)  //包含a返回true,发展false</p>
<p>​        注意：正则表达式严格区分大小写(不区分大小写传递参数”i”)</p>
<p>​      通过字面量创建正则：let reg=/规则/</p>
<p>​         </p>
<p>​      *second 通过正则表达式提取符合规则的字符串</p>
<p>​       let res=str.match(reg);  //默认情况一旦匹配就停止查找</p>
<p>​       通过修饰符g-全局查找  let reg=/规则/g</p>
<p>​      *third  通过正则表达式替换符合规则的字符串</p>
<p>​       let newstr=str.replace(reg,”替换内容”);</p>
<p>//第一个参数除了字符串还可以接收正则对象</p>
<h2 id="4-BOM"><a href="#4-BOM" class="headerlink" title="4. BOM"></a>4. BOM</h2><p>BOM就是提供了一套操作浏览器的API(接口/方法/属性)</p>
<h3 id="4-1-BOM常见对象"><a href="#4-1-BOM常见对象" class="headerlink" title="4.1 BOM常见对象"></a>4.1 BOM常见对象</h3><p>​     window 代表整个浏览器窗口(BOM中的一个顶级对象(全局))</p>
<p>​     Navigator 浏览器信息-判断是什么浏览器</p>
<p>​     Location  浏览器地址栏信息-设置/获取地址信息</p>
<p>​     History  浏览器历史信息-实现刷新/上一步/下一步</p>
<p>​         (由于隐私,只能拿到用户当前历史记录,不能拿到所有历史记录)</p>
<p>​     Screen  用户的屏幕信息(了解即可)-显示器宽高</p>
<p>*Navigator对象</p>
<p>  userAgent属性：包含了浏览器信息的字符串</p>
<p>  应用：if(/chrome/i.test(Navigator.userAgent)){alert(“谷歌浏览器”)}</p>
<p>*Location对象</p>
<p>​    获取/设置当前地址栏url  location.href/location.href=””</p>
<p>​    重新加载网页(刷新)  location.reload();  </p>
<p>​    强制刷新(更新缓存)  location.reload(true);</p>
<p>*History对象</p>
<p>  前进(下一步)  history.forward()  history.go()//go可以传入一个整数-前进几步</p>
<p>  后退   history.back()   history.go()//go可以接受一个负数,代表后退几步</p>
<p>  刷新   history.go(0)  //传入0代表刷新</p>
<h3 id="4-2-JS三大家族"><a href="#4-2-JS三大家族" class="headerlink" title="4.2 JS三大家族"></a>4.2 JS三大家族</h3><p>(offset/client/scroll)</p>
<p><em><strong>*获取元素宽高方式：*</strong></em></p>
<p>   (以下方法都是将元素属性封装到对象中返回)</p>
<p>​    getComputedStyle(oDiv)  </p>
<p>获取的宽高不包括边框和内边距</p>
<p>​      不仅能获取css属性也可以获取style(行内)</p>
<p>​      只读方法(不能设置),只支持IE9及以上</p>
<p>​     oDiv.currentStyle属性   </p>
<p>​      只支持IE9以下,其他和computed一样</p>
<p>​     oDiv.style属性</p>
<p>​       只能获取行内样式,可以设置行内样式</p>
<p>​       不包括边框和内边距,支持IE9以下</p>
<p>​    <em><strong>*offset家族*</strong></em>    (三大家族-不带单位-只读)</p>
<p>​     oDiv.offsetWidth/offsetHeight</p>
<p>​       包括边框和内边距,支持IE9以下</p>
<p>​       只读,行内/css都能获取</p>
<p>​     oDiv.offsetLeft/offsetTop</p>
<p>​      获取元素到第一个定位祖先元素的偏移位(没有定位,就是距离body)</p>
<p>​     oDiv.offsetparent</p>
<p>​      获取元素第一个定位的祖先元素(没有定位就是body)</p>
<p>​    <em><strong>*client家族*</strong></em></p>
<p>​     oDiv.clientWidth/Height  元素自身+内边距</p>
<p>​     oDiv.clientLeft/Top  左边框,顶部边框</p>
<p>​    <em><strong>*scroll家族*</strong></em></p>
<p>​     oDiv.scrollWidth/Height  </p>
<p>​      内容没有超出元素范围时=元素+内边距=clientWidth/Height</p>
<p>​      超出元素范围时=元素+内边距+超出宽度</p>
<p>​     oDiv.scrollLeft/Top</p>
<p>​      滚动时(onscroll事件),内容移出去的距离(从内边距外部开始计算)</p>
<p>​      </p>
<h3 id="4-3-获取网页宽高"><a href="#4-3-获取网页宽高" class="headerlink" title="4.3 获取网页宽高"></a>4.3 获取网页宽高</h3><p>​    获取网页可视区域宽高    </p>
<p>window.innerWidth/innerHeight  //只能在IE9及以上</p>
<p>document.documentElement.clientWidth/clientHeight  标准模式</p>
<p>注意：可用于IE9以下浏览器的标准模式中获取</p>
<p>浏览器渲染网页模式：标准(默认)/混杂/怪异模式</p>
<p>如果网页没有书写文档声明<!DOCTYPE html>-混杂/怪异模式渲染</p>
<p>可通过document.compatMode获取是什么模式</p>
<p>​       混杂模式通过: document.body.clientWidth/clientHeight 获取</p>
<p>​    兼容性写法自己封装…略</p>
<h3 id="4-4-网页滚动距离"><a href="#4-4-网页滚动距离" class="headerlink" title="4.4 网页滚动距离"></a>4.4 网页滚动距离</h3><p>​    IE9及以上浏览器</p>
<p>​     window.pageXOffset/pageYOffset</p>
<p>​    标准模式下浏览器</p>
<p>​     document.documentElement.scrollTop/scrollLeft</p>
<p>​    混杂(怪异)模式下浏览器</p>
<p>​     document.body.scrollTop/scrollLeft</p>
<h3 id="4-5-函数防抖和函数节流"><a href="#4-5-函数防抖和函数节流" class="headerlink" title="4.5 函数防抖和函数节流"></a>4.5 函数防抖和函数节流</h3><ul>
<li><strong>函数防抖</strong></li>
</ul>
<p>函数防抖是优化高频率执行js代码的一种手段</p>
<p>​    可以让被调用的函数在一次连续的高频操作过程中只被调用一次</p>
<p>​    作用：减少代码执行次数,提升网页性能</p>
<p>​    应用场景：oninput/onmousemove/onscroll/onresize等事件</p>
<ul>
<li><strong>函数节流</strong></li>
</ul>
<p>​    作用和函数防抖一样</p>
<p>​     区别：函数节流是减少连续的高频操作函数执行次数</p>
<p>(例如连续调用10次,可能只执行3-4次)</p>
<p>​        函数防抖是让连续的高频操作时函数只执行一次</p>
<p>(例如连续调用10次,但只会执行1次)</p>
<p>​                                                                                                                2021/4/22</p>
<h2 id="5-JSON"><a href="#5-JSON" class="headerlink" title="5. JSON"></a>5. JSON</h2><p>JSON是一种轻量级的数据交换格式(本质上是字符串)</p>
<p>​    采用完全独立于编程语言的文本格式来存储和表示数据</p>
<p>​    JSON其实就是字符串版本的JS对象  ‘{“name”: “cth”}’</p>
<p>​    注意点：JSON的key只能是字符串,value可以是任意数据类型</p>
<p>​    转换：json=JSON.stringify(obj);  obj=JSON.parse(json);</p>
<h1 id="JS高级"><a href="#JS高级" class="headerlink" title="JS高级"></a>JS高级</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><ul>
<li>js的重要性</li>
</ul>
<p>​        所有框架都是在js的基础上编写的</p>
<ul>
<li>js应用场景</li>
</ul>
<p>​        web端 移动端 小程序 桌面应用(如vs code) 后端Node</p>
<ul>
<li><p>js让人疑惑的地方</p>
<p>函数、闭包 、作用域、面向对象(继承、原型链等)、ES新特征(ES6-12) </p>
<p>其他一系列知识(事件循环、宏任务、微任务、内存管理、Promise、await、asnyc、防抖节流等)</p>
</li>
<li><p>TypeScript会取代JavaScript吗</p>
</li>
</ul>
<p>​        TS致力于为JS提供类型检查，而不是取代JS(TS官方文档：源于JS，归于JS)</p>
<p>​        TS只是JS的一个超集，在它的基础上进行了扩展</p>
<p>​        并且最终TS还是需要转换为JS代码才能真正的运行        </p>
<ul>
<li><p>js是一门编程语言(高级的编程语言)</p>
<div class="code-wrapper"><pre><code class="hljs">机器语言(01) -&gt; 汇编语言(汇编指令) -&gt; 高级语言(c、c++、java、js、python)-编译型/解释型
</code></pre></div>
</li>
</ul>
<p>​        (计算机不认识高级语言，代码最终需要转换成机器指令)</p>
<h2 id="2-浏览器工作原理和V8引擎"><a href="#2-浏览器工作原理和V8引擎" class="headerlink" title="2. 浏览器工作原理和V8引擎"></a>2. 浏览器工作原理和V8引擎</h2><ul>
<li><strong>浏览器工作原理</strong></li>
</ul>
<p>​        域名 (DNS解析)-&gt; ip地址 -&gt;服务器地址-&gt; 返回index.html(解析)</p>
<p>​        解析过程中有link标签和script标签 -&gt; 到服务器再次下载对应css和js文件 </p>
<ul>
<li><p>浏览器内核</p>
<p>不同浏览器有不同内核组成</p>
<p>Gecko-早期Netscape和Firefox浏览器使用</p>
<p>Trident-IE4-11浏览器，Edge浏览器已转向Blik</p>
<p>Webkit-苹果开发的，基于Safari，Google之前也在使用</p>
<p>Blik-Webkit的一个分支，Google开发，目前应用于Google、Edge、Opera</p>
<p>浏览器内核-浏览器排版引擎/页面渲染引擎</p>
</li>
<li><p>浏览器渲染过程</p>
<p>html遇到js标签-&gt;停止解析html-&gt;加载执行js代码(js执行是在DOM-&gt;DOM Tree过程改变dom)</p>
<p>html、css解析(Parser) -&gt; DOM Tree+Style Rules -&gt; Render Tree(渲染树) -&gt; Display</p>
<p>如图：</p>
<p> <img src="C:\Users\Administrator\Desktop\2022\img\js高级_浏览器渲染过程.png" srcset="/img/loading.gif" lazyload></p>
<p>js代码是如何执行呢？</p>
</li>
<li><p>js引擎</p>
<p>定义：JavaScript引擎是一个专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器之中</p>
<p>浏览器/Node执行js代码  -&gt; 需要js引擎将js代码转换成CPU指令(机器代码)</p>
<p>引擎举例：</p>
<p>SpiderMonkey：第一款js引擎，由Brendan Eich开发(js作者)</p>
<p>Chakra：微软开发</p>
<p>JavaScriptCore：WebKit中的js引擎，Apple开发(小程序开发常用)</p>
<p>V8：Google开发的js引擎</p>
</li>
</ul>
<ul>
<li><p>浏览器内核和JS引擎的关系</p>
<ul>
<li><p>以Webkit为例，Webkit由两部分组成</p>
</li>
<li><p>WebCore ：负责HTML解析、布局、渲染等工作</p>
</li>
<li><p>JavaScriptCore：解析、执行js代码(小程序中编写的js就是被JSCore执行的)</p>
</li>
</ul>
</li>
<li><p>V8引擎的原理</p>
<p>V8是用c++编写的Goole开源高性能JavaScript和WebAssembly引擎，它用于Chrome和Node.js等  </p>
<p>V8可以独立运行，也可以嵌入到任何C++应用程序中</p>
<p>解析过程：</p>
<p>源码 -&gt; parse(词法分析、语法分析) -&gt;AST抽象语法树-&gt;由Ignition库转换为字节码bytecode</p>
<p>-&gt;V8将字节码转换成机器指令-CPU代码(不同平台CPU不一样所以需要先转换字节码)运行</p>
<p>TurboFan库/模块 将多次执行的代码变成优化的机器指令，下次可直接执行</p>
<p>如图：    </p>
<p><img src="C:\Users\Administrator\Desktop\2022\img\js高级_V8引擎的原理.png" srcset="/img/loading.gif" lazyload>        </p>
</li>
<li><p>代码执行流程分析</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 1. 代码解析，V8引擎内部会给我们创建一个对象(GlobalObject -&gt; go)</span><br><span class="hljs-comment"> 2. 运行代码</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><strong>扩展运算符</strong></li>
</ul>
<p>扩展运算符在函数形参列表中的作用</p>
<p>将传递给函数的所有实参打包到一个数组中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params">...arr</span>) </span>&#123;   <span class="hljs-comment">//将参数打包到arr数组</span><br>  <span class="hljs-built_in">console</span>.log(arr); <br>&#125;<br>fun(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>

<p>注意：和在等号左边一样，也只能写在形参列表最后 </p>
<ul>
<li><strong>形参默认值</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//ES6: 直接在形参指定默认值</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params">a = <span class="hljs-number">6</span>, b = <span class="hljs-number">6</span></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a, b);  <span class="hljs-comment">//Result: 6 6</span><br>&#125;<br>fun()<br></code></pre></td></tr></table></figure>

<p>可以将函数作为其他函数的参数和返回值</p>
<p>JS中函数可以嵌套定义(函数中可以定义函数)</p>
<p>​          </p>
<ul>
<li><strong>箭头函数</strong></li>
</ul>
<p>ES6新增定义函数的格式，为了简化定义函数代码 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//let 函数名称=(形参列表)=&gt;&#123;...&#125;</span><br><span class="hljs-keyword">let</span> fun=<span class="hljs-function">(<span class="hljs-params">a</span>)=&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意点：</p>
<p>​    如果()只有一个形参，括号可以省略 </p>
<p>​    如果大括号中只有一句代码，那么{}也可以省略</p>
<p>箭头函数和普通函数的区别</p>
<p>​    普通函数/方法，谁调用this就是谁</p>
<p>​    箭头函数的this，是父作用域的this，不是调用者  </p>
<p>​    注意：箭头函数中的this永远都只看它所属的作用域的this,不能通过bind/call/apply来修改   </p>
<ul>
<li><strong>作用域链</strong></li>
</ul>
<p>ES6之前作用域链：</p>
<p>​    全局作用域是0级作用域</p>
<p>​    定义函数开启的作用域是1/2/3…级</p>
<p>​    JS会将这些作用域连接起来形成作用域链</p>
<p>​    0-&gt;1-&gt;2-&gt;3-&gt;4… (0级作用域里定义的函数就是1级)</p>
<p>变量在作用域链查找规则：</p>
<p>​    先在当前找，找到就使用当前作用域的</p>
<p>​    当前没有就去上一级作用域查找</p>
<p>​    以此类推直到0级为止，0级没有找到就报错</p>
<p>ES6作用域链：</p>
<p>​    除了定义函数会开启作用域外，代码块也会开启作用域</p>
<p>​    注意点：要用ES6就全部用ES6如：let、箭头函数(不然容易混淆)</p>
<p>​    函数预解析：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//ES6之前这种定义函数方式，可以提前调用(会将函数的声明提升到当前作用域最前面)</span><br>say()  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">say</span>(<span class="hljs-params"></span>)</span>&#123;&#125;  <br><span class="hljs-comment">//报错，这样只有变量才会预解析</span><br>say()  <span class="hljs-keyword">var</span> say=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;  <br><span class="hljs-comment">//不会被预解析,let定义的</span><br>say()  <span class="hljs-keyword">let</span> say = <span class="hljs-function">() =&gt;</span> &#123;&#125;  <br></code></pre></td></tr></table></figure>



<ul>
<li>对象的属性方法分类</li>
</ul>
<p>实例属性/实例方法:</p>
<p>​    通过构造函数创建的对象 - 实例对象</p>
<p>​    通过实例对象访问的属性 - 实例属性</p>
<p>​    通过实例对象调用的方法 - 实例方法</p>
<p>静态属性/静态方法:</p>
<p>​    通过构造函数访问/调用的属性/方法就是静态属性和静态方法</p>
<p>​    构造函数也是对象：构造函数.属性=…</p>
<p><strong>prototype对象</strong> </p>
<p>可以将构造函数中公共的方法存储到prototype对象中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Person.prototype=&#123;<span class="hljs-attr">say</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;&#125;  <span class="hljs-comment">//里面放构造函数公共方法 </span><br></code></pre></td></tr></table></figure>

<p>prototype对象特点：</p>
<p>​    存储在prototype中的方法可以被对应构造函数创建的所有对象共享(也可存储属性)</p>
<p>​    prototype中出现和构造函数重名属性或方法，访问到的是构造函数中的</p>
<p>应用场景：</p>
<p>​    prototype中一般用于存储所有对象都相同的属性及方法 </p>
<ul>
<li>对象三角恋关系</li>
</ul>
<p>每个构造函数都有一个默认属性-prototype</p>
<p>prototype中保存着一个对象-原型对象</p>
<p>每个原型对象都有一个默认属性-constructor</p>
<p>constructor指向当前原型对象对应的那个构造函数</p>
<p>通过构造函数创建的对象-实例对象</p>
<p>每个实例对象都有一个默认属性 <strong>proto</strong> (两下划线)</p>
<p><strong>proto</strong> 指向创建它的那个构造函数的原型对象</p>
<ul>
<li>Function构造函数</li>
</ul>
<p>​    函数是引用类型(对象)，所有函数都是通过Function构造函数创建的对象</p>
<p>​    构造函数的__proto__比较特殊，指向它自己的原型对象(和prototype一样)</p>
<p>​    Object构造函数  Object原型对象的__proto__为null</p>
<p>​      </p>
<ul>
<li>函数关系完整关系</li>
</ul>
<p>​      Function函数是所有函数的祖先函数</p>
<p>​      所有构造函数都有一个prototype属性</p>
<p>​      所有原型对象都有一个constructor属性</p>
<p>​      所有函数都是对象</p>
<p>​      所有对象都有一个__proto__属性                 </p>
<p> <img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml2868\wps1.png" srcset="/img/loading.gif" lazyload alt="img"><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml2868\wps2.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>​     <img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml2868\wps3.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>​                            -2021.4.3</p>
<ul>
<li><p><strong>原型链</strong></p>
<p>当给构造函数的(.prototype={})赋值时，为了不破坏原有关系</p>
<p>需要在自定义的对象中手动添加constructor属性，手动指定指向谁(构造函数)</p>
<p>通过 __proto__ 连接在一起的链叫做原型链</p>
<p>当使用对象的属性和方法时，自己有用自己的，自己没有去原型中找</p>
<p>原型没有，就去原型的原型找，一直找到Object的__proto__为NULL为止</p>
<p>注意：给对象不存在的属性设置值时，不会去原型中查找，会给当前对象新增</p>
</li>
<li><p><strong>封装/继承/多态</strong></p>
</li>
</ul>
<p>JS面向对象的三大特性：封装、继承、多态</p>
<p><strong>封装性</strong></p>
<p>默认情况对象属性和方法都是公开的，拿到对象就可以操作对象的属性方法</p>
<p>构造函数中let/var设置私有属性，通过this.设置公有方法修改和访问私有属性</p>
<p><strong>继承</strong></p>
<p>bind-call-apply三个方法</p>
<p>作用：都是用于修改函数或方法中的this的</p>
<p>obj是新this的指向对象</p>
<p>bind方法：函数.bind(obj ,参数…);  会返回一个修改后的新函数</p>
<p>​     也可以函数传参，只不过参数要写在this对象后面</p>
<p>call方法： 函数.call(obj ,参数…);  会立即调用新函数  可传参</p>
<p>apply方法：也是立即调用，但传递参数格式不一样，通过数组传参</p>
<p>​      函数.apply(obj ,[参数…]);  </p>
<p>修改方法的this：方法.bind() 一样的做法…</p>
<p>JS继承的终极方法：</p>
<p>  在子类的构造函数中通过call借助父类的构造函数</p>
<p>  将子类的原型对象修改为父类的实例对象\</p>
<p><strong>多态</strong></p>
<p>强类型语言-变量使用严格符合定义：int就存储整型</p>
<p>弱类型-不要求变量使用严格符合-JS就是弱类型</p>
<p>弱类型语言不关注多态</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
                    
                      <a class="hover-with-bg" href="/categories/%E5%89%8D%E7%AB%AF/2-JS/">2. JS</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/JS/">JS</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/24/1.%20html/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">HTML详解</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/24/0.%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">
                        <span class="hidden-mobile">Hexo博客搭建和部署</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
  <!--《添加网站运行时间 -->
<!--<br/>-->
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date();

    function createtime() {
        var grt = new Date("01/14/2022 12:00:00"); //此处修改你的建站时间或者网站上线时间 
        now.setTime(now.getTime() + 250);
        days = (now - grt) / 1000 / 60 / 60 / 24;
        dnum = Math.floor(days);
        hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum);
        hnum = Math.floor(hours);
        if (String(hnum).length == 1) {
            hnum = "0" + hnum;
        }
        minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes);
        if (String(mnum).length == 1) {
            mnum = "0" + mnum;
        }
        seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds);
        if (String(snum).length == 1) {
            snum = "0" + snum;
        }
        document.getElementById("timeDate").innerHTML = " 本站已安全运行 " + dnum + " 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
    setInterval("createtime()", 250);
</script>
<!-- 添加网站运行时间》 -->
</footer>
<script type="text/javascript" src="/js/clicklove.js"></script>
<script type="text/javascript" src="https://libs.baidu.com/jquery/1.8.3/jquery.js"></script>
<script type="text/javascript" src="https://libs.baidu.com/jquery/1.8.3/jquery.min.js"></script>
<!-- 雪花特效 -->
<script type="text/javascript" src="/js/snow.js"></script>








  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/haru01.model.json"},"display":{"superSample":2,"width":150,"height":430,"position":"right","hOffset":0,"vOffset":-20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false});</script></body>
</html>
